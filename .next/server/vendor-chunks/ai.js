"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/ai";
exports.ids = ["vendor-chunks/ai"];
exports.modules = {

/***/ "(ssr)/./node_modules/ai/rsc/dist/rsc-shared.mjs":
/*!*************************************************!*\
  !*** ./node_modules/ai/rsc/dist/rsc-shared.mjs ***!
  \*************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("var react__WEBPACK_IMPORTED_MODULE_0___namespace_cache;\n__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   InternalAIProvider: () => (/* binding */ InternalAIProvider),\n/* harmony export */   readStreamableValue: () => (/* binding */ readStreamableValue),\n/* harmony export */   useAIState: () => (/* binding */ useAIState),\n/* harmony export */   useActions: () => (/* binding */ useActions),\n/* harmony export */   useStreamableValue: () => (/* binding */ useStreamableValue),\n/* harmony export */   useSyncUIState: () => (/* binding */ useSyncUIState),\n/* harmony export */   useUIState: () => (/* binding */ useUIState)\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\n/* harmony import */ var jsondiffpatch__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! jsondiffpatch */ \"(ssr)/./node_modules/jsondiffpatch/lib/index.js\");\n/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react/jsx-runtime */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react-jsx-runtime.js\");\n/* __next_internal_client_entry_do_not_use__ InternalAIProvider,readStreamableValue,useAIState,useActions,useStreamableValue,useSyncUIState,useUIState auto */ // rsc/streamable-value/streamable-value.ts\nvar STREAMABLE_VALUE_TYPE = Symbol.for(\"ui.streamable.value\");\n// rsc/streamable-value/is-streamable-value.ts\nfunction isStreamableValue(value) {\n    return value != null && typeof value === \"object\" && \"type\" in value && value.type === STREAMABLE_VALUE_TYPE;\n}\n// rsc/streamable-value/read-streamable-value.tsx\nfunction readStreamableValue(streamableValue) {\n    if (!isStreamableValue(streamableValue)) {\n        throw new Error(\"Invalid value: this hook only accepts values created via `createStreamableValue`.\");\n    }\n    return {\n        [Symbol.asyncIterator] () {\n            let row = streamableValue;\n            let value = row.curr;\n            let isDone = false;\n            let isFirstIteration = true;\n            return {\n                async next () {\n                    if (isDone) return {\n                        value,\n                        done: true\n                    };\n                    row = await row;\n                    if (row.error !== void 0) {\n                        throw row.error;\n                    }\n                    if (\"curr\" in row || row.diff) {\n                        if (row.diff) {\n                            if (row.diff[0] === 0) {\n                                if (typeof value !== \"string\") {\n                                    throw new Error(\"Invalid patch: can only append to string types. This is a bug in the AI SDK.\");\n                                }\n                                value = value + row.diff[1];\n                            }\n                        } else {\n                            value = row.curr;\n                        }\n                        if (!row.next) {\n                            isDone = true;\n                            return {\n                                value,\n                                done: false\n                            };\n                        }\n                    }\n                    if (row.next === void 0) {\n                        return {\n                            value,\n                            done: true\n                        };\n                    }\n                    row = row.next;\n                    if (isFirstIteration) {\n                        isFirstIteration = false;\n                        if (value === void 0) {\n                            return this.next();\n                        }\n                    }\n                    return {\n                        value,\n                        done: false\n                    };\n                }\n            };\n        }\n    };\n}\n// rsc/streamable-value/use-streamable-value.tsx\n\nfunction checkStreamableValue(value) {\n    const hasSignature = isStreamableValue(value);\n    if (!hasSignature && value !== void 0) {\n        throw new Error(\"Invalid value: this hook only accepts values created via `createStreamableValue`.\");\n    }\n    return hasSignature;\n}\nfunction useStreamableValue(streamableValue) {\n    const [curr, setCurr] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(checkStreamableValue(streamableValue) ? streamableValue.curr : void 0);\n    const [error, setError] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(checkStreamableValue(streamableValue) ? streamableValue.error : void 0);\n    const [pending, setPending] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(checkStreamableValue(streamableValue) ? !!streamableValue.next : false);\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useLayoutEffect)(()=>{\n        if (!checkStreamableValue(streamableValue)) return;\n        let cancelled = false;\n        const iterator = readStreamableValue(streamableValue);\n        if (streamableValue.next) {\n            (0,react__WEBPACK_IMPORTED_MODULE_0__.startTransition)(()=>{\n                if (cancelled) return;\n                setPending(true);\n            });\n        }\n        (async ()=>{\n            try {\n                for await (const value of iterator){\n                    if (cancelled) return;\n                    (0,react__WEBPACK_IMPORTED_MODULE_0__.startTransition)(()=>{\n                        if (cancelled) return;\n                        setCurr(value);\n                    });\n                }\n            } catch (e) {\n                if (cancelled) return;\n                (0,react__WEBPACK_IMPORTED_MODULE_0__.startTransition)(()=>{\n                    if (cancelled) return;\n                    setError(e);\n                });\n            } finally{\n                if (cancelled) return;\n                (0,react__WEBPACK_IMPORTED_MODULE_0__.startTransition)(()=>{\n                    if (cancelled) return;\n                    setPending(false);\n                });\n            }\n        })();\n        return ()=>{\n            cancelled = true;\n        };\n    }, [\n        streamableValue\n    ]);\n    return [\n        curr,\n        error,\n        pending\n    ];\n}\n// rsc/shared-client/context.tsx\n\n\n// util/is-function.ts\nvar isFunction = (value)=>typeof value === \"function\";\n// rsc/shared-client/context.tsx\n\nvar InternalUIStateProvider = /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createContext(null);\nvar InternalAIStateProvider = /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createContext(void 0);\nvar InternalActionProvider = /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createContext(null);\nvar InternalSyncUIStateProvider = /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createContext(null);\nfunction InternalAIProvider({ children, initialUIState, initialAIState, initialAIStatePatch, wrappedActions, wrappedSyncUIState }) {\n    if (!(\"use\" in /*#__PURE__*/ (react__WEBPACK_IMPORTED_MODULE_0___namespace_cache || (react__WEBPACK_IMPORTED_MODULE_0___namespace_cache = __webpack_require__.t(react__WEBPACK_IMPORTED_MODULE_0__, 2))))) {\n        throw new Error(\"Unsupported React version.\");\n    }\n    const uiState = react__WEBPACK_IMPORTED_MODULE_0__.useState(initialUIState);\n    const setUIState = uiState[1];\n    const resolvedInitialAIStatePatch = initialAIStatePatch ? react__WEBPACK_IMPORTED_MODULE_0__.use(initialAIStatePatch) : void 0;\n    initialAIState = react__WEBPACK_IMPORTED_MODULE_0__.useMemo(()=>{\n        if (resolvedInitialAIStatePatch) {\n            return jsondiffpatch__WEBPACK_IMPORTED_MODULE_2__.patch(jsondiffpatch__WEBPACK_IMPORTED_MODULE_2__.clone(initialAIState), resolvedInitialAIStatePatch);\n        }\n        return initialAIState;\n    }, [\n        initialAIState,\n        resolvedInitialAIStatePatch\n    ]);\n    const aiState = react__WEBPACK_IMPORTED_MODULE_0__.useState(initialAIState);\n    const setAIState = aiState[1];\n    const aiStateRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef(aiState[0]);\n    react__WEBPACK_IMPORTED_MODULE_0__.useEffect(()=>{\n        aiStateRef.current = aiState[0];\n    }, [\n        aiState[0]\n    ]);\n    const clientWrappedActions = react__WEBPACK_IMPORTED_MODULE_0__.useMemo(()=>Object.fromEntries(Object.entries(wrappedActions).map(([key, action])=>[\n                key,\n                async (...args)=>{\n                    const aiStateSnapshot = aiStateRef.current;\n                    const [aiStateDelta, result] = await action(aiStateSnapshot, ...args);\n                    (async ()=>{\n                        const delta = await aiStateDelta;\n                        if (delta !== void 0) {\n                            aiState[1](jsondiffpatch__WEBPACK_IMPORTED_MODULE_2__.patch(jsondiffpatch__WEBPACK_IMPORTED_MODULE_2__.clone(aiStateSnapshot), delta));\n                        }\n                    })();\n                    return result;\n                }\n            ])), [\n        wrappedActions\n    ]);\n    const clientWrappedSyncUIStateAction = react__WEBPACK_IMPORTED_MODULE_0__.useMemo(()=>{\n        if (!wrappedSyncUIState) {\n            return ()=>{};\n        }\n        return async ()=>{\n            const aiStateSnapshot = aiStateRef.current;\n            const [aiStateDelta, uiState2] = await wrappedSyncUIState(aiStateSnapshot);\n            if (uiState2 !== void 0) {\n                setUIState(uiState2);\n            }\n            const delta = await aiStateDelta;\n            if (delta !== void 0) {\n                const patchedAiState = jsondiffpatch__WEBPACK_IMPORTED_MODULE_2__.patch(jsondiffpatch__WEBPACK_IMPORTED_MODULE_2__.clone(aiStateSnapshot), delta);\n                setAIState(patchedAiState);\n            }\n        };\n    }, [\n        wrappedSyncUIState\n    ]);\n    return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(InternalAIStateProvider.Provider, {\n        value: aiState,\n        children: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(InternalUIStateProvider.Provider, {\n            value: uiState,\n            children: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(InternalActionProvider.Provider, {\n                value: clientWrappedActions,\n                children: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(InternalSyncUIStateProvider.Provider, {\n                    value: clientWrappedSyncUIStateAction,\n                    children\n                })\n            })\n        })\n    });\n}\nfunction useUIState() {\n    const state = react__WEBPACK_IMPORTED_MODULE_0__.useContext(InternalUIStateProvider);\n    if (state === null) {\n        throw new Error(\"`useUIState` must be used inside an <AI> provider.\");\n    }\n    if (!Array.isArray(state)) {\n        throw new Error(\"Invalid state\");\n    }\n    if (state[0] === void 0) {\n        throw new Error(\"`initialUIState` must be provided to `createAI` or `<AI>`\");\n    }\n    return state;\n}\nfunction useAIState(...args) {\n    const state = react__WEBPACK_IMPORTED_MODULE_0__.useContext(InternalAIStateProvider);\n    if (state === null) {\n        throw new Error(\"`useAIState` must be used inside an <AI> provider.\");\n    }\n    if (!Array.isArray(state)) {\n        throw new Error(\"Invalid state\");\n    }\n    if (state[0] === void 0) {\n        throw new Error(\"`initialAIState` must be provided to `createAI` or `<AI>`\");\n    }\n    if (args.length >= 1 && typeof state[0] !== \"object\") {\n        throw new Error(\"When using `useAIState` with a key, the AI state must be an object.\");\n    }\n    const key = args[0];\n    const setter = react__WEBPACK_IMPORTED_MODULE_0__.useCallback(typeof key === \"undefined\" ? state[1] : (newState)=>{\n        if (isFunction(newState)) {\n            return state[1]((s)=>{\n                return {\n                    ...s,\n                    [key]: newState(s[key])\n                };\n            });\n        } else {\n            return state[1]({\n                ...state[0],\n                [key]: newState\n            });\n        }\n    }, [\n        key\n    ]);\n    if (args.length === 0) {\n        return state;\n    } else {\n        return [\n            state[0][args[0]],\n            setter\n        ];\n    }\n}\nfunction useActions() {\n    const actions = react__WEBPACK_IMPORTED_MODULE_0__.useContext(InternalActionProvider);\n    return actions;\n}\nfunction useSyncUIState() {\n    const syncUIState = react__WEBPACK_IMPORTED_MODULE_0__.useContext(InternalSyncUIStateProvider);\n    if (syncUIState === null) {\n        throw new Error(\"`useSyncUIState` must be used inside an <AI> provider.\");\n    }\n    return syncUIState;\n}\n //# sourceMappingURL=rsc-shared.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvYWkvcnNjL2Rpc3QvcnNjLXNoYXJlZC5tanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7O0FBQU8sSUFBTUEsd0JBQXdCQyxPQUFPQyxHQUFBLENBQUk7O0FDRXpDLFNBQVNDLGtCQUFrQkMsS0FBQTtJQUNoQyxPQUNFQSxTQUFTLFFBQ1QsT0FBT0EsVUFBVSxZQUNqQixVQUFVQSxTQUNWQSxNQUFNQyxJQUFBLEtBQVNMO0FBRW5COztBQ3dCTyxTQUFTTSxvQkFDZEMsZUFBQTtJQUVBLElBQUksQ0FBQ0osa0JBQWtCSSxrQkFBa0I7UUFDdkMsTUFBTSxJQUFJQyxNQUNSO0lBRUo7SUFFQSxPQUFPO1FBQ0wsQ0FBQ1AsT0FBT1EsYUFBYTtZQUNuQixJQUFJQyxNQUNGSDtZQUNGLElBQUlILFFBQVFNLElBQUlDLElBQUE7WUFDaEIsSUFBSUMsU0FBUztZQUNiLElBQUlDLG1CQUFtQjtZQUV2QixPQUFPO2dCQUNMLE1BQU1DO29CQUVKLElBQUlGLFFBQVEsT0FBTzt3QkFBRVI7d0JBQU9XLE1BQU07b0JBQUs7b0JBR3ZDTCxNQUFNLE1BQU1BO29CQUdaLElBQUlBLElBQUlNLEtBQUEsS0FBVSxRQUFXO3dCQUMzQixNQUFNTixJQUFJTSxLQUFBO29CQUNaO29CQUdBLElBQUksVUFBVU4sT0FBT0EsSUFBSU8sSUFBQSxFQUFNO3dCQUM3QixJQUFJUCxJQUFJTyxJQUFBLEVBQU07NEJBRVosSUFBSVAsSUFBSU8sSUFBQSxDQUFLLEVBQUMsS0FBTSxHQUFHO2dDQUNyQixJQUFJLE9BQU9iLFVBQVUsVUFBVTtvQ0FDN0IsTUFBTSxJQUFJSSxNQUNSO2dDQUVKO2dDQUdDSixRQUFtQkEsUUFBUU0sSUFBSU8sSUFBQSxDQUFLLEVBQUM7NEJBQ3hDO3dCQUNGLE9BQU87NEJBRUxiLFFBQVFNLElBQUlDLElBQUE7d0JBQ2Q7d0JBSUEsSUFBSSxDQUFDRCxJQUFJSSxJQUFBLEVBQU07NEJBQ2JGLFNBQVM7NEJBQ1QsT0FBTztnQ0FBRVI7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QU0sSUFBSXBFLE1BQ1I7SUFFSjtJQUNBLElBQUkyRCxLQUFLYyxNQUFBLElBQVUsS0FBSyxPQUFPTCxLQUFBLENBQU0sRUFBQyxLQUFNLFVBQVU7UUFDcEQsTUFBTSxJQUFJcEUsTUFDUjtJQUVKO0lBRUEsTUFBTXlELE1BQU1FLElBQUEsQ0FBSyxFQUFDO0lBQ2xCLE1BQU1lLFNBQWVuRCw4Q0FBQSxDQUNuQixPQUFPa0MsUUFBUSxjQUNYVyxLQUFBLENBQU0sRUFBQyxHQUNQLENBQUNRO1FBQ0MsSUFBSW5ELFdBQVdtRCxXQUFXO1lBQ3hCLE9BQU9SLEtBQUEsQ0FBTSxFQUFDLENBQUUsQ0FBQVM7Z0JBQ2QsT0FBTztvQkFBRSxHQUFHQSxDQUFBO29CQUFHLENBQUNwQixJQUFHLEVBQUdtQixTQUFTQyxDQUFBLENBQUVwQixJQUFJO2dCQUFFO1lBQ3pDO1FBQ0YsT0FBTztZQUNMLE9BQU9XLEtBQUEsQ0FBTSxFQUFDLENBQUU7Z0JBQUUsR0FBR0EsS0FBQSxDQUFNLEVBQUM7Z0JBQUcsQ0FBQ1gsSUFBRyxFQUFHbUI7WUFBUztRQUNqRDtJQUNGLEdBQ0o7UUFBQ25CO0tBQUc7SUFHTixJQUFJRSxLQUFLYyxNQUFBLEtBQVcsR0FBRztRQUNyQixPQUFPTDtJQUNULE9BQU87UUFDTCxPQUFPO1lBQUNBLEtBQUEsQ0FBTSxFQUFDLENBQUVULElBQUEsQ0FBSyxFQUFFO1lBQUdlO1NBQU07SUFDbkM7QUFDRjtBQUVPLFNBQVNJO0lBR2QsTUFBTUMsVUFBZ0J4RCw2Q0FBQSxDQUFjTztJQUNwQyxPQUFPaUQ7QUFDVDtBQUVPLFNBQVNDO0lBQ2QsTUFBTUMsY0FBb0IxRCw2Q0FBQSxDQUN4QlE7SUFHRixJQUFJa0QsZ0JBQWdCLE1BQU07UUFDeEIsTUFBTSxJQUFJakYsTUFBTTtJQUNsQjtJQUVBLE9BQU9pRjtBQUNUIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vYXNrX2RvYy8uLi9zdHJlYW1hYmxlLXZhbHVlL3N0cmVhbWFibGUtdmFsdWUudHM/YzVlMSIsIndlYnBhY2s6Ly9hc2tfZG9jLy4uL3N0cmVhbWFibGUtdmFsdWUvaXMtc3RyZWFtYWJsZS12YWx1ZS50cz9mYWI0Iiwid2VicGFjazovL2Fza19kb2MvLi4vc3RyZWFtYWJsZS12YWx1ZS9yZWFkLXN0cmVhbWFibGUtdmFsdWUudHN4PzA1NmIiLCJ3ZWJwYWNrOi8vYXNrX2RvYy8uLi9zdHJlYW1hYmxlLXZhbHVlL3VzZS1zdHJlYW1hYmxlLXZhbHVlLnRzeD9iNTZhIiwid2VicGFjazovL2Fza19kb2MvLi4vc2hhcmVkLWNsaWVudC9jb250ZXh0LnRzeD9jYjNmIiwid2VicGFjazovL2Fza19kb2MvLi4vLi4vdXRpbC9pcy1mdW5jdGlvbi50cz8yZDRjIl0sInNvdXJjZXNDb250ZW50IjpbImV4cG9ydCBjb25zdCBTVFJFQU1BQkxFX1ZBTFVFX1RZUEUgPSBTeW1ib2wuZm9yKCd1aS5zdHJlYW1hYmxlLnZhbHVlJyk7XG5cbmV4cG9ydCB0eXBlIFN0cmVhbWFibGVQYXRjaCA9IHVuZGVmaW5lZCB8IFswLCBzdHJpbmddOyAvLyBBcHBlbmQgc3RyaW5nLlxuXG5kZWNsYXJlIGNvbnN0IF9faW50ZXJuYWxfY3VycjogdW5pcXVlIHN5bWJvbDtcbmRlY2xhcmUgY29uc3QgX19pbnRlcm5hbF9lcnJvcjogdW5pcXVlIHN5bWJvbDtcblxuLyoqXG4gKiBTdHJlYW1hYmxlVmFsdWUgaXMgYSB2YWx1ZSB0aGF0IGNhbiBiZSBzdHJlYW1lZCBvdmVyIHRoZSBuZXR3b3JrIHZpYSBBSSBBY3Rpb25zLlxuICogVG8gcmVhZCB0aGUgc3RyZWFtZWQgdmFsdWVzLCB1c2UgdGhlIGByZWFkU3RyZWFtYWJsZVZhbHVlYCBvciBgdXNlU3RyZWFtYWJsZVZhbHVlYCBBUElzLlxuICovXG5leHBvcnQgdHlwZSBTdHJlYW1hYmxlVmFsdWU8VCA9IGFueSwgRSA9IGFueT4gPSB7XG4gIC8qKlxuICAgKiBAaW50ZXJuYWwgVXNlIGByZWFkU3RyZWFtYWJsZVZhbHVlYCB0byByZWFkIHRoZSB2YWx1ZXMuXG4gICAqL1xuICB0eXBlPzogdHlwZW9mIFNUUkVBTUFCTEVfVkFMVUVfVFlQRTtcbiAgLyoqXG4gICAqIEBpbnRlcm5hbCBVc2UgYHJlYWRTdHJlYW1hYmxlVmFsdWVgIHRvIHJlYWQgdGhlIHZhbHVlcy5cbiAgICovXG4gIGN1cnI/OiBUO1xuICAvKipcbiAgICogQGludGVybmFsIFVzZSBgcmVhZFN0cmVhbWFibGVWYWx1ZWAgdG8gcmVhZCB0aGUgdmFsdWVzLlxuICAgKi9cbiAgZXJyb3I/OiBFO1xuICAvKipcbiAgICogQGludGVybmFsIFVzZSBgcmVhZFN0cmVhbWFibGVWYWx1ZWAgdG8gcmVhZCB0aGUgdmFsdWVzLlxuICAgKi9cbiAgZGlmZj86IFN0cmVhbWFibGVQYXRjaDtcbiAgLyoqXG4gICAqIEBpbnRlcm5hbCBVc2UgYHJlYWRTdHJlYW1hYmxlVmFsdWVgIHRvIHJlYWQgdGhlIHZhbHVlcy5cbiAgICovXG4gIG5leHQ/OiBQcm9taXNlPFN0cmVhbWFibGVWYWx1ZTxULCBFPj47XG5cbiAgLy8gYnJhbmRlZCB0eXBlcyB0byBtYWludGFpbiB0eXBlIHNpZ25hdHVyZSBhZnRlciBpbnRlcm5hbCBwcm9wZXJ0aWVzIGFyZSBzdHJpcHBlZC5cbiAgW19faW50ZXJuYWxfY3Vycl0/OiBUO1xuICBbX19pbnRlcm5hbF9lcnJvcl0/OiBFO1xufTtcbiIsImltcG9ydCB7IFNUUkVBTUFCTEVfVkFMVUVfVFlQRSwgU3RyZWFtYWJsZVZhbHVlIH0gZnJvbSAnLi9zdHJlYW1hYmxlLXZhbHVlJztcblxuZXhwb3J0IGZ1bmN0aW9uIGlzU3RyZWFtYWJsZVZhbHVlKHZhbHVlOiB1bmtub3duKTogdmFsdWUgaXMgU3RyZWFtYWJsZVZhbHVlIHtcbiAgcmV0dXJuIChcbiAgICB2YWx1ZSAhPSBudWxsICYmXG4gICAgdHlwZW9mIHZhbHVlID09PSAnb2JqZWN0JyAmJlxuICAgICd0eXBlJyBpbiB2YWx1ZSAmJlxuICAgIHZhbHVlLnR5cGUgPT09IFNUUkVBTUFCTEVfVkFMVUVfVFlQRVxuICApO1xufVxuIiwiaW1wb3J0IHsgaXNTdHJlYW1hYmxlVmFsdWUgfSBmcm9tICcuL2lzLXN0cmVhbWFibGUtdmFsdWUnO1xuaW1wb3J0IHsgU3RyZWFtYWJsZVZhbHVlIH0gZnJvbSAnLi9zdHJlYW1hYmxlLXZhbHVlJztcblxuLyoqXG4gKiBgcmVhZFN0cmVhbWFibGVWYWx1ZWAgdGFrZXMgYSBzdHJlYW1hYmxlIHZhbHVlIGNyZWF0ZWQgdmlhIHRoZSBgY3JlYXRlU3RyZWFtYWJsZVZhbHVlKCkudmFsdWVgIEFQSSxcbiAqIGFuZCByZXR1cm5zIGFuIGFzeW5jIGl0ZXJhdG9yLlxuICpcbiAqIGBgYGpzXG4gKiAvLyBJbnNpZGUgeW91ciBBSSBhY3Rpb246XG4gKlxuICogYXN5bmMgZnVuY3Rpb24gYWN0aW9uKCkge1xuICogICAndXNlIHNlcnZlcidcbiAqICAgY29uc3Qgc3RyZWFtYWJsZSA9IGNyZWF0ZVN0cmVhbWFibGVWYWx1ZSgpO1xuICpcbiAqICAgc3RyZWFtYWJsZS51cGRhdGUoMSk7XG4gKiAgIHN0cmVhbWFibGUudXBkYXRlKDIpO1xuICogICBzdHJlYW1hYmxlLmRvbmUoMyk7XG4gKiAgIC8vIC4uLlxuICogICByZXR1cm4gc3RyZWFtYWJsZS52YWx1ZTtcbiAqIH1cbiAqIGBgYFxuICpcbiAqIEFuZCB0byByZWFkIHRoZSB2YWx1ZTpcbiAqXG4gKiBgYGBqc1xuICogY29uc3Qgc3RyZWFtYWJsZVZhbHVlID0gYXdhaXQgYWN0aW9uKClcbiAqIGZvciBhd2FpdCAoY29uc3QgdiBvZiByZWFkU3RyZWFtYWJsZVZhbHVlKHN0cmVhbWFibGVWYWx1ZSkpIHtcbiAqICAgY29uc29sZS5sb2codilcbiAqIH1cbiAqIGBgYFxuICpcbiAqIFRoaXMgbG9ncyBvdXQgMSwgMiwgMyBvbiBjb25zb2xlLlxuICovXG5leHBvcnQgZnVuY3Rpb24gcmVhZFN0cmVhbWFibGVWYWx1ZTxUID0gdW5rbm93bj4oXG4gIHN0cmVhbWFibGVWYWx1ZTogU3RyZWFtYWJsZVZhbHVlPFQ+LFxuKTogQXN5bmNJdGVyYWJsZTxUIHwgdW5kZWZpbmVkPiB7XG4gIGlmICghaXNTdHJlYW1hYmxlVmFsdWUoc3RyZWFtYWJsZVZhbHVlKSkge1xuICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICdJbnZhbGlkIHZhbHVlOiB0aGlzIGhvb2sgb25seSBhY2NlcHRzIHZhbHVlcyBjcmVhdGVkIHZpYSBgY3JlYXRlU3RyZWFtYWJsZVZhbHVlYC4nLFxuICAgICk7XG4gIH1cblxuICByZXR1cm4ge1xuICAgIFtTeW1ib2wuYXN5bmNJdGVyYXRvcl0oKSB7XG4gICAgICBsZXQgcm93OiBTdHJlYW1hYmxlVmFsdWU8VD4gfCBQcm9taXNlPFN0cmVhbWFibGVWYWx1ZTxUPj4gPVxuICAgICAgICBzdHJlYW1hYmxlVmFsdWU7XG4gICAgICBsZXQgdmFsdWUgPSByb3cuY3VycjsgLy8gdGhlIGN1cnJlbnQgdmFsdWVcbiAgICAgIGxldCBpc0RvbmUgPSBmYWxzZTtcbiAgICAgIGxldCBpc0ZpcnN0SXRlcmF0aW9uID0gdHJ1ZTtcblxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgYXN5bmMgbmV4dCgpIHtcbiAgICAgICAgICAvLyB0aGUgaXRlcmF0aW9uIGlzIGRvbmUgYWxyZWFkeSwgcmV0dXJuIHRoZSBsYXN0IHZhbHVlOlxuICAgICAgICAgIGlmIChpc0RvbmUpIHJldHVybiB7IHZhbHVlLCBkb25lOiB0cnVlIH07XG5cbiAgICAgICAgICAvLyByZXNvbHZlIHRoZSBwcm9taXNlIGF0IHRoZSBiZWdpbm5pbmcgb2YgZWFjaCBpdGVyYXRpb246XG4gICAgICAgICAgcm93ID0gYXdhaXQgcm93O1xuXG4gICAgICAgICAgLy8gdGhyb3cgZXJyb3IgaWYgYW55OlxuICAgICAgICAgIGlmIChyb3cuZXJyb3IgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhyb3cgcm93LmVycm9yO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIC8vIGlmIHRoZXJlIGlzIGEgdmFsdWUgb3IgYSBwYXRjaCwgdXNlIGl0OlxuICAgICAgICAgIGlmICgnY3VycicgaW4gcm93IHx8IHJvdy5kaWZmKSB7XG4gICAgICAgICAgICBpZiAocm93LmRpZmYpIHtcbiAgICAgICAgICAgICAgLy8gc3RyZWFtYWJsZSBwYXRjaCAodGV4dCBvbmx5KTpcbiAgICAgICAgICAgICAgaWYgKHJvdy5kaWZmWzBdID09PSAwKSB7XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICAgICAgICAgICAgJ0ludmFsaWQgcGF0Y2g6IGNhbiBvbmx5IGFwcGVuZCB0byBzdHJpbmcgdHlwZXMuIFRoaXMgaXMgYSBidWcgaW4gdGhlIEFJIFNESy4nLFxuICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvLyBjYXN0aW5nIHJlcXVpcmVkIHRvIHJlbW92ZSBUICYgc3RyaW5nIGxpbWl0YXRpb25cbiAgICAgICAgICAgICAgICAodmFsdWUgYXMgc3RyaW5nKSA9IHZhbHVlICsgcm93LmRpZmZbMV07XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIC8vIHJlcGxhY2UgdGhlIHZhbHVlIChmdWxsIG5ldyB2YWx1ZSlcbiAgICAgICAgICAgICAgdmFsdWUgPSByb3cuY3VycjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gVGhlIGxhc3QgZW1pdHRlZCB7IGRvbmU6IHRydWUgfSB3b24ndCBiZSB1c2VkIGFzIHRoZSB2YWx1ZVxuICAgICAgICAgICAgLy8gYnkgdGhlIGZvciBhd2FpdC4uLm9mIHN5bnRheC5cbiAgICAgICAgICAgIGlmICghcm93Lm5leHQpIHtcbiAgICAgICAgICAgICAgaXNEb25lID0gdHJ1ZTtcbiAgICAgICAgICAgICAgcmV0dXJuIHsgdmFsdWUsIGRvbmU6IGZhbHNlIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgLy8gdGhlcmUgYXJlIG5vIGZ1cnRoZXIgcm93cyB0byBpdGVyYXRlIG92ZXI6XG4gICAgICAgICAgaWYgKHJvdy5uZXh0ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJldHVybiB7IHZhbHVlLCBkb25lOiB0cnVlIH07XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcm93ID0gcm93Lm5leHQ7XG5cbiAgICAgICAgICBpZiAoaXNGaXJzdEl0ZXJhdGlvbikge1xuICAgICAgICAgICAgaXNGaXJzdEl0ZXJhdGlvbiA9IGZhbHNlOyAvLyBUT0RPIHNob3VsZCB0aGlzIGJlIHNldCBmb3IgZXZlcnkgcmV0dXJuP1xuXG4gICAgICAgICAgICBpZiAodmFsdWUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAvLyBUaGlzIGlzIHRoZSBpbml0aWFsIGNodW5rIGFuZCB0aGVyZSBpc24ndCBhbiBpbml0aWFsIHZhbHVlIHlldC5cbiAgICAgICAgICAgICAgLy8gTGV0J3Mgc2tpcCB0aGlzIG9uZS5cbiAgICAgICAgICAgICAgcmV0dXJuIHRoaXMubmV4dCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIHJldHVybiB7IHZhbHVlLCBkb25lOiBmYWxzZSB9O1xuICAgICAgICB9LFxuICAgICAgfTtcbiAgICB9LFxuICB9O1xufVxuIiwiaW1wb3J0IHsgc3RhcnRUcmFuc2l0aW9uLCB1c2VMYXlvdXRFZmZlY3QsIHVzZVN0YXRlIH0gZnJvbSAncmVhY3QnO1xuaW1wb3J0IHsgcmVhZFN0cmVhbWFibGVWYWx1ZSB9IGZyb20gJy4vcmVhZC1zdHJlYW1hYmxlLXZhbHVlJztcbmltcG9ydCB7IFN0cmVhbWFibGVWYWx1ZSB9IGZyb20gJy4vc3RyZWFtYWJsZS12YWx1ZSc7XG5pbXBvcnQgeyBpc1N0cmVhbWFibGVWYWx1ZSB9IGZyb20gJy4vaXMtc3RyZWFtYWJsZS12YWx1ZSc7XG5cbmZ1bmN0aW9uIGNoZWNrU3RyZWFtYWJsZVZhbHVlKHZhbHVlOiB1bmtub3duKTogdmFsdWUgaXMgU3RyZWFtYWJsZVZhbHVlIHtcbiAgY29uc3QgaGFzU2lnbmF0dXJlID0gaXNTdHJlYW1hYmxlVmFsdWUodmFsdWUpO1xuXG4gIGlmICghaGFzU2lnbmF0dXJlICYmIHZhbHVlICE9PSB1bmRlZmluZWQpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAnSW52YWxpZCB2YWx1ZTogdGhpcyBob29rIG9ubHkgYWNjZXB0cyB2YWx1ZXMgY3JlYXRlZCB2aWEgYGNyZWF0ZVN0cmVhbWFibGVWYWx1ZWAuJyxcbiAgICApO1xuICB9XG5cbiAgcmV0dXJuIGhhc1NpZ25hdHVyZTtcbn1cblxuLyoqXG4gKiBgdXNlU3RyZWFtYWJsZVZhbHVlYCBpcyBhIFJlYWN0IGhvb2sgdGhhdCB0YWtlcyBhIHN0cmVhbWFibGUgdmFsdWUgY3JlYXRlZCB2aWEgdGhlIGBjcmVhdGVTdHJlYW1hYmxlVmFsdWUoKS52YWx1ZWAgQVBJLFxuICogYW5kIHJldHVybnMgdGhlIGN1cnJlbnQgdmFsdWUsIGVycm9yLCBhbmQgcGVuZGluZyBzdGF0ZS5cbiAqXG4gKiBUaGlzIGlzIHVzZWZ1bCBmb3IgY29uc3VtaW5nIHN0cmVhbWFibGUgdmFsdWVzIHJlY2VpdmVkIGZyb20gYSBjb21wb25lbnQncyBwcm9wcy4gRm9yIGV4YW1wbGU6XG4gKlxuICogYGBganNcbiAqIGZ1bmN0aW9uIE15Q29tcG9uZW50KHsgc3RyZWFtYWJsZVZhbHVlIH0pIHtcbiAqICAgY29uc3QgW2RhdGEsIGVycm9yLCBwZW5kaW5nXSA9IHVzZVN0cmVhbWFibGVWYWx1ZShzdHJlYW1hYmxlVmFsdWUpO1xuICpcbiAqICAgaWYgKHBlbmRpbmcpIHJldHVybiA8ZGl2PkxvYWRpbmcuLi48L2Rpdj47XG4gKiAgIGlmIChlcnJvcikgcmV0dXJuIDxkaXY+RXJyb3I6IHtlcnJvci5tZXNzYWdlfTwvZGl2PjtcbiAqXG4gKiAgIHJldHVybiA8ZGl2PkRhdGE6IHtkYXRhfTwvZGl2PjtcbiAqIH1cbiAqIGBgYFxuICovXG5leHBvcnQgZnVuY3Rpb24gdXNlU3RyZWFtYWJsZVZhbHVlPFQgPSB1bmtub3duLCBFcnJvciA9IHVua25vd24+KFxuICBzdHJlYW1hYmxlVmFsdWU/OiBTdHJlYW1hYmxlVmFsdWU8VD4sXG4pOiBbZGF0YTogVCB8IHVuZGVmaW5lZCwgZXJyb3I6IEVycm9yIHwgdW5kZWZpbmVkLCBwZW5kaW5nOiBib29sZWFuXSB7XG4gIGNvbnN0IFtjdXJyLCBzZXRDdXJyXSA9IHVzZVN0YXRlPFQgfCB1bmRlZmluZWQ+KFxuICAgIGNoZWNrU3RyZWFtYWJsZVZhbHVlKHN0cmVhbWFibGVWYWx1ZSkgPyBzdHJlYW1hYmxlVmFsdWUuY3VyciA6IHVuZGVmaW5lZCxcbiAgKTtcbiAgY29uc3QgW2Vycm9yLCBzZXRFcnJvcl0gPSB1c2VTdGF0ZTxFcnJvciB8IHVuZGVmaW5lZD4oXG4gICAgY2hlY2tTdHJlYW1hYmxlVmFsdWUoc3RyZWFtYWJsZVZhbHVlKSA/IHN0cmVhbWFibGVWYWx1ZS5lcnJvciA6IHVuZGVmaW5lZCxcbiAgKTtcbiAgY29uc3QgW3BlbmRpbmcsIHNldFBlbmRpbmddID0gdXNlU3RhdGU8Ym9vbGVhbj4oXG4gICAgY2hlY2tTdHJlYW1hYmxlVmFsdWUoc3RyZWFtYWJsZVZhbHVlKSA/ICEhc3RyZWFtYWJsZVZhbHVlLm5leHQgOiBmYWxzZSxcbiAgKTtcblxuICB1c2VMYXlvdXRFZmZlY3QoKCkgPT4ge1xuICAgIGlmICghY2hlY2tTdHJlYW1hYmxlVmFsdWUoc3RyZWFtYWJsZVZhbHVlKSkgcmV0dXJuO1xuXG4gICAgbGV0IGNhbmNlbGxlZCA9IGZhbHNlO1xuXG4gICAgY29uc3QgaXRlcmF0b3IgPSByZWFkU3RyZWFtYWJsZVZhbHVlKHN0cmVhbWFibGVWYWx1ZSk7XG4gICAgaWYgKHN0cmVhbWFibGVWYWx1ZS5uZXh0KSB7XG4gICAgICBzdGFydFRyYW5zaXRpb24oKCkgPT4ge1xuICAgICAgICBpZiAoY2FuY2VsbGVkKSByZXR1cm47XG4gICAgICAgIHNldFBlbmRpbmcodHJ1ZSk7XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICAoYXN5bmMgKCkgPT4ge1xuICAgICAgdHJ5IHtcbiAgICAgICAgZm9yIGF3YWl0IChjb25zdCB2YWx1ZSBvZiBpdGVyYXRvcikge1xuICAgICAgICAgIGlmIChjYW5jZWxsZWQpIHJldHVybjtcbiAgICAgICAgICBzdGFydFRyYW5zaXRpb24oKCkgPT4ge1xuICAgICAgICAgICAgaWYgKGNhbmNlbGxlZCkgcmV0dXJuO1xuICAgICAgICAgICAgc2V0Q3Vycih2YWx1ZSk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgaWYgKGNhbmNlbGxlZCkgcmV0dXJuO1xuICAgICAgICBzdGFydFRyYW5zaXRpb24oKCkgPT4ge1xuICAgICAgICAgIGlmIChjYW5jZWxsZWQpIHJldHVybjtcbiAgICAgICAgICBzZXRFcnJvcihlIGFzIEVycm9yKTtcbiAgICAgICAgfSk7XG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICBpZiAoY2FuY2VsbGVkKSByZXR1cm47XG4gICAgICAgIHN0YXJ0VHJhbnNpdGlvbigoKSA9PiB7XG4gICAgICAgICAgaWYgKGNhbmNlbGxlZCkgcmV0dXJuO1xuICAgICAgICAgIHNldFBlbmRpbmcoZmFsc2UpO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9KSgpO1xuXG4gICAgcmV0dXJuICgpID0+IHtcbiAgICAgIGNhbmNlbGxlZCA9IHRydWU7XG4gICAgfTtcbiAgfSwgW3N0cmVhbWFibGVWYWx1ZV0pO1xuXG4gIHJldHVybiBbY3VyciwgZXJyb3IsIHBlbmRpbmddO1xufVxuIiwiLyogZXNsaW50LWRpc2FibGUgcmVhY3QtaG9va3MvZXhoYXVzdGl2ZS1kZXBzICovXG4ndXNlIGNsaWVudCc7XG5cbmltcG9ydCAqIGFzIFJlYWN0IGZyb20gJ3JlYWN0JztcblxuaW1wb3J0ICogYXMganNvbmRpZmZwYXRjaCBmcm9tICdqc29uZGlmZnBhdGNoJztcbmltcG9ydCB7IGlzRnVuY3Rpb24gfSBmcm9tICcuLi8uLi91dGlsL2lzLWZ1bmN0aW9uJztcbmltcG9ydCB0eXBlIHtcbiAgQUlQcm92aWRlcixcbiAgSW5mZXJBY3Rpb25zLFxuICBJbmZlckFJU3RhdGUsXG4gIEluZmVyVUlTdGF0ZSxcbiAgSW50ZXJuYWxBSVByb3ZpZGVyUHJvcHMsXG4gIFZhbHVlT3JVcGRhdGVyLFxufSBmcm9tICcuLi90eXBlcyc7XG5cbmNvbnN0IEludGVybmFsVUlTdGF0ZVByb3ZpZGVyID0gUmVhY3QuY3JlYXRlQ29udGV4dDxudWxsIHwgYW55PihudWxsKTtcbmNvbnN0IEludGVybmFsQUlTdGF0ZVByb3ZpZGVyID0gUmVhY3QuY3JlYXRlQ29udGV4dDx1bmRlZmluZWQgfCBhbnk+KHVuZGVmaW5lZCk7XG5jb25zdCBJbnRlcm5hbEFjdGlvblByb3ZpZGVyID0gUmVhY3QuY3JlYXRlQ29udGV4dDxudWxsIHwgYW55PihudWxsKTtcbmNvbnN0IEludGVybmFsU3luY1VJU3RhdGVQcm92aWRlciA9IFJlYWN0LmNyZWF0ZUNvbnRleHQ8bnVsbCB8IGFueT4obnVsbCk7XG5cbmV4cG9ydCBmdW5jdGlvbiBJbnRlcm5hbEFJUHJvdmlkZXIoe1xuICBjaGlsZHJlbixcbiAgaW5pdGlhbFVJU3RhdGUsXG4gIGluaXRpYWxBSVN0YXRlLFxuICBpbml0aWFsQUlTdGF0ZVBhdGNoLFxuICB3cmFwcGVkQWN0aW9ucyxcbiAgd3JhcHBlZFN5bmNVSVN0YXRlLFxufTogSW50ZXJuYWxBSVByb3ZpZGVyUHJvcHMpIHtcbiAgaWYgKCEoJ3VzZScgaW4gUmVhY3QpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdVbnN1cHBvcnRlZCBSZWFjdCB2ZXJzaW9uLicpO1xuICB9XG5cbiAgY29uc3QgdWlTdGF0ZSA9IFJlYWN0LnVzZVN0YXRlKGluaXRpYWxVSVN0YXRlKTtcbiAgY29uc3Qgc2V0VUlTdGF0ZSA9IHVpU3RhdGVbMV07XG5cbiAgY29uc3QgcmVzb2x2ZWRJbml0aWFsQUlTdGF0ZVBhdGNoID0gaW5pdGlhbEFJU3RhdGVQYXRjaFxuICAgID8gKFJlYWN0IGFzIGFueSkudXNlKGluaXRpYWxBSVN0YXRlUGF0Y2gpXG4gICAgOiB1bmRlZmluZWQ7XG4gIGluaXRpYWxBSVN0YXRlID0gUmVhY3QudXNlTWVtbygoKSA9PiB7XG4gICAgaWYgKHJlc29sdmVkSW5pdGlhbEFJU3RhdGVQYXRjaCkge1xuICAgICAgcmV0dXJuIGpzb25kaWZmcGF0Y2gucGF0Y2goXG4gICAgICAgIGpzb25kaWZmcGF0Y2guY2xvbmUoaW5pdGlhbEFJU3RhdGUpLFxuICAgICAgICByZXNvbHZlZEluaXRpYWxBSVN0YXRlUGF0Y2gsXG4gICAgICApO1xuICAgIH1cbiAgICByZXR1cm4gaW5pdGlhbEFJU3RhdGU7XG4gIH0sIFtpbml0aWFsQUlTdGF0ZSwgcmVzb2x2ZWRJbml0aWFsQUlTdGF0ZVBhdGNoXSk7XG5cbiAgY29uc3QgYWlTdGF0ZSA9IFJlYWN0LnVzZVN0YXRlKGluaXRpYWxBSVN0YXRlKTtcbiAgY29uc3Qgc2V0QUlTdGF0ZSA9IGFpU3RhdGVbMV07XG4gIGNvbnN0IGFpU3RhdGVSZWYgPSBSZWFjdC51c2VSZWYoYWlTdGF0ZVswXSk7XG5cbiAgUmVhY3QudXNlRWZmZWN0KCgpID0+IHtcbiAgICBhaVN0YXRlUmVmLmN1cnJlbnQgPSBhaVN0YXRlWzBdO1xuICB9LCBbYWlTdGF0ZVswXV0pO1xuXG4gIGNvbnN0IGNsaWVudFdyYXBwZWRBY3Rpb25zID0gUmVhY3QudXNlTWVtbyhcbiAgICAoKSA9PlxuICAgICAgT2JqZWN0LmZyb21FbnRyaWVzKFxuICAgICAgICBPYmplY3QuZW50cmllcyh3cmFwcGVkQWN0aW9ucykubWFwKChba2V5LCBhY3Rpb25dKSA9PiBbXG4gICAgICAgICAga2V5LFxuICAgICAgICAgIGFzeW5jICguLi5hcmdzOiBhbnkpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGFpU3RhdGVTbmFwc2hvdCA9IGFpU3RhdGVSZWYuY3VycmVudDtcbiAgICAgICAgICAgIGNvbnN0IFthaVN0YXRlRGVsdGEsIHJlc3VsdF0gPSBhd2FpdCBhY3Rpb24oXG4gICAgICAgICAgICAgIGFpU3RhdGVTbmFwc2hvdCxcbiAgICAgICAgICAgICAgLi4uYXJncyxcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICAoYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgICBjb25zdCBkZWx0YSA9IGF3YWl0IGFpU3RhdGVEZWx0YTtcbiAgICAgICAgICAgICAgaWYgKGRlbHRhICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBhaVN0YXRlWzFdKFxuICAgICAgICAgICAgICAgICAganNvbmRpZmZwYXRjaC5wYXRjaChcbiAgICAgICAgICAgICAgICAgICAganNvbmRpZmZwYXRjaC5jbG9uZShhaVN0YXRlU25hcHNob3QpLFxuICAgICAgICAgICAgICAgICAgICBkZWx0YSxcbiAgICAgICAgICAgICAgICAgICksXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSkoKTtcbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgICAgfSxcbiAgICAgICAgXSksXG4gICAgICApLFxuICAgIFt3cmFwcGVkQWN0aW9uc10sXG4gICk7XG5cbiAgY29uc3QgY2xpZW50V3JhcHBlZFN5bmNVSVN0YXRlQWN0aW9uID0gUmVhY3QudXNlTWVtbygoKSA9PiB7XG4gICAgaWYgKCF3cmFwcGVkU3luY1VJU3RhdGUpIHtcbiAgICAgIHJldHVybiAoKSA9PiB7fTtcbiAgICB9XG5cbiAgICByZXR1cm4gYXN5bmMgKCkgPT4ge1xuICAgICAgY29uc3QgYWlTdGF0ZVNuYXBzaG90ID0gYWlTdGF0ZVJlZi5jdXJyZW50O1xuICAgICAgY29uc3QgW2FpU3RhdGVEZWx0YSwgdWlTdGF0ZV0gPSBhd2FpdCB3cmFwcGVkU3luY1VJU3RhdGUhKFxuICAgICAgICBhaVN0YXRlU25hcHNob3QsXG4gICAgICApO1xuXG4gICAgICBpZiAodWlTdGF0ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHNldFVJU3RhdGUodWlTdGF0ZSk7XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IGRlbHRhID0gYXdhaXQgYWlTdGF0ZURlbHRhO1xuICAgICAgaWYgKGRlbHRhICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgY29uc3QgcGF0Y2hlZEFpU3RhdGUgPSBqc29uZGlmZnBhdGNoLnBhdGNoKFxuICAgICAgICAgIGpzb25kaWZmcGF0Y2guY2xvbmUoYWlTdGF0ZVNuYXBzaG90KSxcbiAgICAgICAgICBkZWx0YSxcbiAgICAgICAgKTtcbiAgICAgICAgc2V0QUlTdGF0ZShwYXRjaGVkQWlTdGF0ZSk7XG4gICAgICB9XG4gICAgfTtcbiAgfSwgW3dyYXBwZWRTeW5jVUlTdGF0ZV0pO1xuXG4gIHJldHVybiAoXG4gICAgPEludGVybmFsQUlTdGF0ZVByb3ZpZGVyLlByb3ZpZGVyIHZhbHVlPXthaVN0YXRlfT5cbiAgICAgIDxJbnRlcm5hbFVJU3RhdGVQcm92aWRlci5Qcm92aWRlciB2YWx1ZT17dWlTdGF0ZX0+XG4gICAgICAgIDxJbnRlcm5hbEFjdGlvblByb3ZpZGVyLlByb3ZpZGVyIHZhbHVlPXtjbGllbnRXcmFwcGVkQWN0aW9uc30+XG4gICAgICAgICAgPEludGVybmFsU3luY1VJU3RhdGVQcm92aWRlci5Qcm92aWRlclxuICAgICAgICAgICAgdmFsdWU9e2NsaWVudFdyYXBwZWRTeW5jVUlTdGF0ZUFjdGlvbn1cbiAgICAgICAgICA+XG4gICAgICAgICAgICB7Y2hpbGRyZW59XG4gICAgICAgICAgPC9JbnRlcm5hbFN5bmNVSVN0YXRlUHJvdmlkZXIuUHJvdmlkZXI+XG4gICAgICAgIDwvSW50ZXJuYWxBY3Rpb25Qcm92aWRlci5Qcm92aWRlcj5cbiAgICAgIDwvSW50ZXJuYWxVSVN0YXRlUHJvdmlkZXIuUHJvdmlkZXI+XG4gICAgPC9JbnRlcm5hbEFJU3RhdGVQcm92aWRlci5Qcm92aWRlcj5cbiAgKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHVzZVVJU3RhdGU8QUkgZXh0ZW5kcyBBSVByb3ZpZGVyID0gYW55PigpIHtcbiAgdHlwZSBUID0gSW5mZXJVSVN0YXRlPEFJLCBhbnk+O1xuXG4gIGNvbnN0IHN0YXRlID0gUmVhY3QudXNlQ29udGV4dDxcbiAgICBbVCwgKHY6IFQgfCAoKHZfOiBUKSA9PiBUKSkgPT4gdm9pZF0gfCBudWxsIHwgdW5kZWZpbmVkXG4gID4oSW50ZXJuYWxVSVN0YXRlUHJvdmlkZXIpO1xuICBpZiAoc3RhdGUgPT09IG51bGwpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ2B1c2VVSVN0YXRlYCBtdXN0IGJlIHVzZWQgaW5zaWRlIGFuIDxBST4gcHJvdmlkZXIuJyk7XG4gIH1cbiAgaWYgKCFBcnJheS5pc0FycmF5KHN0YXRlKSkge1xuICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBzdGF0ZScpO1xuICB9XG4gIGlmIChzdGF0ZVswXSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgJ2Bpbml0aWFsVUlTdGF0ZWAgbXVzdCBiZSBwcm92aWRlZCB0byBgY3JlYXRlQUlgIG9yIGA8QUk+YCcsXG4gICAgKTtcbiAgfVxuICByZXR1cm4gc3RhdGU7XG59XG5cbi8vIFRPRE86IEhvdyBkbyB3ZSBhdm9pZCBjYXVzaW5nIGEgcmUtcmVuZGVyIHdoZW4gdGhlIEFJIHN0YXRlIGNoYW5nZXMgYnV0IHlvdVxuLy8gYXJlIG9ubHkgbGlzdGVuaW5nIHRvIGEgc3BlY2lmaWMga2V5PyBXZSBuZWVkIHVzZVNFUyBwZXJoYXBzP1xuZnVuY3Rpb24gdXNlQUlTdGF0ZTxBSSBleHRlbmRzIEFJUHJvdmlkZXIgPSBhbnk+KCk6IFtcbiAgSW5mZXJBSVN0YXRlPEFJLCBhbnk+LFxuICAobmV3U3RhdGU6IFZhbHVlT3JVcGRhdGVyPEluZmVyQUlTdGF0ZTxBSSwgYW55Pj4pID0+IHZvaWQsXG5dO1xuZnVuY3Rpb24gdXNlQUlTdGF0ZTxBSSBleHRlbmRzIEFJUHJvdmlkZXIgPSBhbnk+KFxuICBrZXk6IGtleW9mIEluZmVyQUlTdGF0ZTxBSSwgYW55Pixcbik6IFtcbiAgSW5mZXJBSVN0YXRlPEFJLCBhbnk+W3R5cGVvZiBrZXldLFxuICAobmV3U3RhdGU6IFZhbHVlT3JVcGRhdGVyPEluZmVyQUlTdGF0ZTxBSSwgYW55Plt0eXBlb2Yga2V5XT4pID0+IHZvaWQsXG5dO1xuZnVuY3Rpb24gdXNlQUlTdGF0ZTxBSSBleHRlbmRzIEFJUHJvdmlkZXIgPSBhbnk+KFxuICAuLi5hcmdzOiBbXSB8IFtrZXlvZiBJbmZlckFJU3RhdGU8QUksIGFueT5dXG4pIHtcbiAgdHlwZSBUID0gSW5mZXJBSVN0YXRlPEFJLCBhbnk+O1xuXG4gIGNvbnN0IHN0YXRlID0gUmVhY3QudXNlQ29udGV4dDxcbiAgICBbVCwgKG5ld1N0YXRlOiBWYWx1ZU9yVXBkYXRlcjxUPikgPT4gdm9pZF0gfCBudWxsIHwgdW5kZWZpbmVkXG4gID4oSW50ZXJuYWxBSVN0YXRlUHJvdmlkZXIpO1xuICBpZiAoc3RhdGUgPT09IG51bGwpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ2B1c2VBSVN0YXRlYCBtdXN0IGJlIHVzZWQgaW5zaWRlIGFuIDxBST4gcHJvdmlkZXIuJyk7XG4gIH1cbiAgaWYgKCFBcnJheS5pc0FycmF5KHN0YXRlKSkge1xuICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBzdGF0ZScpO1xuICB9XG4gIGlmIChzdGF0ZVswXSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgJ2Bpbml0aWFsQUlTdGF0ZWAgbXVzdCBiZSBwcm92aWRlZCB0byBgY3JlYXRlQUlgIG9yIGA8QUk+YCcsXG4gICAgKTtcbiAgfVxuICBpZiAoYXJncy5sZW5ndGggPj0gMSAmJiB0eXBlb2Ygc3RhdGVbMF0gIT09ICdvYmplY3QnKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgJ1doZW4gdXNpbmcgYHVzZUFJU3RhdGVgIHdpdGggYSBrZXksIHRoZSBBSSBzdGF0ZSBtdXN0IGJlIGFuIG9iamVjdC4nLFxuICAgICk7XG4gIH1cblxuICBjb25zdCBrZXkgPSBhcmdzWzBdO1xuICBjb25zdCBzZXR0ZXIgPSBSZWFjdC51c2VDYWxsYmFjayhcbiAgICB0eXBlb2Yga2V5ID09PSAndW5kZWZpbmVkJ1xuICAgICAgPyBzdGF0ZVsxXVxuICAgICAgOiAobmV3U3RhdGU6IFZhbHVlT3JVcGRhdGVyPFQ+KSA9PiB7XG4gICAgICAgICAgaWYgKGlzRnVuY3Rpb24obmV3U3RhdGUpKSB7XG4gICAgICAgICAgICByZXR1cm4gc3RhdGVbMV0ocyA9PiB7XG4gICAgICAgICAgICAgIHJldHVybiB7IC4uLnMsIFtrZXldOiBuZXdTdGF0ZShzW2tleV0pIH07XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHN0YXRlWzFdKHsgLi4uc3RhdGVbMF0sIFtrZXldOiBuZXdTdGF0ZSB9KTtcbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgW2tleV0sXG4gICk7XG5cbiAgaWYgKGFyZ3MubGVuZ3RoID09PSAwKSB7XG4gICAgcmV0dXJuIHN0YXRlO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBbc3RhdGVbMF1bYXJnc1swXV0sIHNldHRlcl07XG4gIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHVzZUFjdGlvbnM8QUkgZXh0ZW5kcyBBSVByb3ZpZGVyID0gYW55PigpIHtcbiAgdHlwZSBUID0gSW5mZXJBY3Rpb25zPEFJLCBhbnk+O1xuXG4gIGNvbnN0IGFjdGlvbnMgPSBSZWFjdC51c2VDb250ZXh0PFQ+KEludGVybmFsQWN0aW9uUHJvdmlkZXIpO1xuICByZXR1cm4gYWN0aW9ucztcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHVzZVN5bmNVSVN0YXRlKCkge1xuICBjb25zdCBzeW5jVUlTdGF0ZSA9IFJlYWN0LnVzZUNvbnRleHQ8KCkgPT4gUHJvbWlzZTx2b2lkPj4oXG4gICAgSW50ZXJuYWxTeW5jVUlTdGF0ZVByb3ZpZGVyLFxuICApO1xuXG4gIGlmIChzeW5jVUlTdGF0ZSA9PT0gbnVsbCkge1xuICAgIHRocm93IG5ldyBFcnJvcignYHVzZVN5bmNVSVN0YXRlYCBtdXN0IGJlIHVzZWQgaW5zaWRlIGFuIDxBST4gcHJvdmlkZXIuJyk7XG4gIH1cblxuICByZXR1cm4gc3luY1VJU3RhdGU7XG59XG5cbmV4cG9ydCB7IHVzZUFJU3RhdGUgfTtcbiIsIi8qKlxuICogQ2hlY2tzIGlmIHRoZSBnaXZlbiB2YWx1ZSBpcyBhIGZ1bmN0aW9uLlxuICpcbiAqIEBwYXJhbSB7dW5rbm93bn0gdmFsdWUgLSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gVHJ1ZSBpZiB0aGUgdmFsdWUgaXMgYSBmdW5jdGlvbiwgZmFsc2Ugb3RoZXJ3aXNlLlxuICovXG5leHBvcnQgY29uc3QgaXNGdW5jdGlvbiA9ICh2YWx1ZTogdW5rbm93bik6IHZhbHVlIGlzIEZ1bmN0aW9uID0+XG4gIHR5cGVvZiB2YWx1ZSA9PT0gJ2Z1bmN0aW9uJztcbiJdLCJuYW1lcyI6WyJTVFJFQU1BQkxFX1ZBTFVFX1RZUEUiLCJTeW1ib2wiLCJmb3IiLCJpc1N0cmVhbWFibGVWYWx1ZSIsInZhbHVlIiwidHlwZSIsInJlYWRTdHJlYW1hYmxlVmFsdWUiLCJzdHJlYW1hYmxlVmFsdWUiLCJFcnJvciIsImFzeW5jSXRlcmF0b3IiLCJyb3ciLCJjdXJyIiwiaXNEb25lIiwiaXNGaXJzdEl0ZXJhdGlvbiIsIm5leHQiLCJkb25lIiwiZXJyb3IiLCJkaWZmIiwic3RhcnRUcmFuc2l0aW9uIiwidXNlTGF5b3V0RWZmZWN0IiwidXNlU3RhdGUiLCJjaGVja1N0cmVhbWFibGVWYWx1ZSIsImhhc1NpZ25hdHVyZSIsInVzZVN0cmVhbWFibGVWYWx1ZSIsInNldEN1cnIiLCJzZXRFcnJvciIsInBlbmRpbmciLCJzZXRQZW5kaW5nIiwiY2FuY2VsbGVkIiwiaXRlcmF0b3IiLCJlIiwiUmVhY3QiLCJqc29uZGlmZnBhdGNoIiwiaXNGdW5jdGlvbiIsImpzeCIsIkludGVybmFsVUlTdGF0ZVByb3ZpZGVyIiwiY3JlYXRlQ29udGV4dCIsIkludGVybmFsQUlTdGF0ZVByb3ZpZGVyIiwiSW50ZXJuYWxBY3Rpb25Qcm92aWRlciIsIkludGVybmFsU3luY1VJU3RhdGVQcm92aWRlciIsIkludGVybmFsQUlQcm92aWRlciIsImNoaWxkcmVuIiwiaW5pdGlhbFVJU3RhdGUiLCJpbml0aWFsQUlTdGF0ZSIsImluaXRpYWxBSVN0YXRlUGF0Y2giLCJ3cmFwcGVkQWN0aW9ucyIsIndyYXBwZWRTeW5jVUlTdGF0ZSIsInVpU3RhdGUiLCJzZXRVSVN0YXRlIiwicmVzb2x2ZWRJbml0aWFsQUlTdGF0ZVBhdGNoIiwidXNlIiwidXNlTWVtbyIsInBhdGNoIiwiY2xvbmUiLCJhaVN0YXRlIiwic2V0QUlTdGF0ZSIsImFpU3RhdGVSZWYiLCJ1c2VSZWYiLCJ1c2VFZmZlY3QiLCJjdXJyZW50IiwiY2xpZW50V3JhcHBlZEFjdGlvbnMiLCJPYmplY3QiLCJmcm9tRW50cmllcyIsImVudHJpZXMiLCJtYXAiLCJrZXkiLCJhY3Rpb24iLCJhcmdzIiwiYWlTdGF0ZVNuYXBzaG90IiwiYWlTdGF0ZURlbHRhIiwicmVzdWx0IiwiZGVsdGEiLCJjbGllbnRXcmFwcGVkU3luY1VJU3RhdGVBY3Rpb24iLCJwYXRjaGVkQWlTdGF0ZSIsIlByb3ZpZGVyIiwidXNlVUlTdGF0ZSIsInN0YXRlIiwidXNlQ29udGV4dCIsIkFycmF5IiwiaXNBcnJheSIsInVzZUFJU3RhdGUiLCJsZW5ndGgiLCJzZXR0ZXIiLCJ1c2VDYWxsYmFjayIsIm5ld1N0YXRlIiwicyIsInVzZUFjdGlvbnMiLCJhY3Rpb25zIiwidXNlU3luY1VJU3RhdGUiLCJzeW5jVUlTdGF0ZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ai/rsc/dist/rsc-shared.mjs\n");

/***/ }),

/***/ "(action-browser)/./node_modules/ai/dist/index.mjs":
/*!****************************************!*\
  !*** ./node_modules/ai/dist/index.mjs ***!
  \****************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   AISDKError: () => (/* reexport safe */ _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.AISDKError),\n/* harmony export */   AIStream: () => (/* binding */ AIStream),\n/* harmony export */   APICallError: () => (/* reexport safe */ _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.APICallError),\n/* harmony export */   AWSBedrockAnthropicMessagesStream: () => (/* binding */ AWSBedrockAnthropicMessagesStream),\n/* harmony export */   AWSBedrockAnthropicStream: () => (/* binding */ AWSBedrockAnthropicStream),\n/* harmony export */   AWSBedrockCohereStream: () => (/* binding */ AWSBedrockCohereStream),\n/* harmony export */   AWSBedrockLlama2Stream: () => (/* binding */ AWSBedrockLlama2Stream),\n/* harmony export */   AWSBedrockStream: () => (/* binding */ AWSBedrockStream),\n/* harmony export */   AnthropicStream: () => (/* binding */ AnthropicStream),\n/* harmony export */   AssistantResponse: () => (/* binding */ AssistantResponse),\n/* harmony export */   CohereStream: () => (/* binding */ CohereStream),\n/* harmony export */   DownloadError: () => (/* binding */ DownloadError),\n/* harmony export */   EmptyResponseBodyError: () => (/* reexport safe */ _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.EmptyResponseBodyError),\n/* harmony export */   GoogleGenerativeAIStream: () => (/* binding */ GoogleGenerativeAIStream),\n/* harmony export */   HuggingFaceStream: () => (/* binding */ HuggingFaceStream),\n/* harmony export */   InkeepStream: () => (/* binding */ InkeepStream),\n/* harmony export */   InvalidArgumentError: () => (/* binding */ InvalidArgumentError),\n/* harmony export */   InvalidDataContentError: () => (/* binding */ InvalidDataContentError),\n/* harmony export */   InvalidMessageRoleError: () => (/* binding */ InvalidMessageRoleError),\n/* harmony export */   InvalidModelIdError: () => (/* binding */ InvalidModelIdError),\n/* harmony export */   InvalidPromptError: () => (/* reexport safe */ _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.InvalidPromptError),\n/* harmony export */   InvalidResponseDataError: () => (/* reexport safe */ _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.InvalidResponseDataError),\n/* harmony export */   InvalidToolArgumentsError: () => (/* binding */ InvalidToolArgumentsError),\n/* harmony export */   JSONParseError: () => (/* reexport safe */ _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.JSONParseError),\n/* harmony export */   LangChainAdapter: () => (/* binding */ langchain_adapter_exports),\n/* harmony export */   LangChainStream: () => (/* binding */ LangChainStream),\n/* harmony export */   LoadAPIKeyError: () => (/* reexport safe */ _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.LoadAPIKeyError),\n/* harmony export */   MistralStream: () => (/* binding */ MistralStream),\n/* harmony export */   NoObjectGeneratedError: () => (/* binding */ NoObjectGeneratedError),\n/* harmony export */   NoSuchModelError: () => (/* binding */ NoSuchModelError),\n/* harmony export */   NoSuchProviderError: () => (/* binding */ NoSuchProviderError),\n/* harmony export */   NoSuchToolError: () => (/* binding */ NoSuchToolError),\n/* harmony export */   OpenAIStream: () => (/* binding */ OpenAIStream),\n/* harmony export */   ReplicateStream: () => (/* binding */ ReplicateStream),\n/* harmony export */   RetryError: () => (/* binding */ RetryError),\n/* harmony export */   StreamData: () => (/* binding */ StreamData2),\n/* harmony export */   StreamingTextResponse: () => (/* binding */ StreamingTextResponse),\n/* harmony export */   TypeValidationError: () => (/* reexport safe */ _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.TypeValidationError),\n/* harmony export */   UnsupportedFunctionalityError: () => (/* reexport safe */ _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.UnsupportedFunctionalityError),\n/* harmony export */   convertDataContentToBase64String: () => (/* binding */ convertDataContentToBase64String),\n/* harmony export */   convertDataContentToUint8Array: () => (/* binding */ convertDataContentToUint8Array),\n/* harmony export */   convertToCoreMessages: () => (/* binding */ convertToCoreMessages),\n/* harmony export */   convertUint8ArrayToText: () => (/* binding */ convertUint8ArrayToText),\n/* harmony export */   cosineSimilarity: () => (/* binding */ cosineSimilarity),\n/* harmony export */   createCallbacksTransformer: () => (/* binding */ createCallbacksTransformer),\n/* harmony export */   createEventStreamTransformer: () => (/* binding */ createEventStreamTransformer),\n/* harmony export */   createStreamDataTransformer: () => (/* binding */ createStreamDataTransformer),\n/* harmony export */   embed: () => (/* binding */ embed),\n/* harmony export */   embedMany: () => (/* binding */ embedMany),\n/* harmony export */   experimental_AssistantResponse: () => (/* binding */ experimental_AssistantResponse),\n/* harmony export */   experimental_StreamData: () => (/* binding */ experimental_StreamData),\n/* harmony export */   experimental_createModelRegistry: () => (/* binding */ experimental_createModelRegistry),\n/* harmony export */   experimental_createProviderRegistry: () => (/* binding */ experimental_createProviderRegistry),\n/* harmony export */   experimental_generateObject: () => (/* binding */ experimental_generateObject),\n/* harmony export */   experimental_generateText: () => (/* binding */ experimental_generateText),\n/* harmony export */   experimental_streamObject: () => (/* binding */ experimental_streamObject),\n/* harmony export */   experimental_streamText: () => (/* binding */ experimental_streamText),\n/* harmony export */   formatStreamPart: () => (/* reexport safe */ _ai_sdk_ui_utils__WEBPACK_IMPORTED_MODULE_3__.formatStreamPart),\n/* harmony export */   generateId: () => (/* binding */ generateId2),\n/* harmony export */   generateObject: () => (/* binding */ generateObject),\n/* harmony export */   generateText: () => (/* binding */ generateText),\n/* harmony export */   jsonSchema: () => (/* reexport safe */ _ai_sdk_ui_utils__WEBPACK_IMPORTED_MODULE_3__.jsonSchema),\n/* harmony export */   nanoid: () => (/* binding */ nanoid),\n/* harmony export */   parseComplexResponse: () => (/* reexport safe */ _ai_sdk_ui_utils__WEBPACK_IMPORTED_MODULE_3__.parseComplexResponse),\n/* harmony export */   parseStreamPart: () => (/* reexport safe */ _ai_sdk_ui_utils__WEBPACK_IMPORTED_MODULE_3__.parseStreamPart),\n/* harmony export */   readDataStream: () => (/* reexport safe */ _ai_sdk_ui_utils__WEBPACK_IMPORTED_MODULE_3__.readDataStream),\n/* harmony export */   readableFromAsyncIterable: () => (/* binding */ readableFromAsyncIterable),\n/* harmony export */   streamObject: () => (/* binding */ streamObject),\n/* harmony export */   streamText: () => (/* binding */ streamText),\n/* harmony export */   streamToResponse: () => (/* binding */ streamToResponse),\n/* harmony export */   tool: () => (/* binding */ tool),\n/* harmony export */   trimStartOfStreamHelper: () => (/* binding */ trimStartOfStreamHelper)\n/* harmony export */ });\n/* harmony import */ var _ai_sdk_ui_utils__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @ai-sdk/ui-utils */ \"(action-browser)/./node_modules/@ai-sdk/ui-utils/dist/index.mjs\");\n/* harmony import */ var _ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @ai-sdk/provider-utils */ \"(action-browser)/./node_modules/@ai-sdk/provider-utils/dist/index.mjs\");\n/* harmony import */ var _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @ai-sdk/provider */ \"(action-browser)/./node_modules/@ai-sdk/provider/dist/index.mjs\");\n/* harmony import */ var _opentelemetry_api__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @opentelemetry/api */ \"(action-browser)/./node_modules/@opentelemetry/api/build/esm/index.js\");\n/* harmony import */ var eventsource_parser__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! eventsource-parser */ \"(action-browser)/./node_modules/eventsource-parser/dist/index.js\");\nvar __defProp = Object.defineProperty;\nvar __export = (target, all) => {\n  for (var name12 in all)\n    __defProp(target, name12, { get: all[name12], enumerable: true });\n};\n\n// streams/index.ts\n\n\n\n// core/index.ts\n\n\n// util/retry-with-exponential-backoff.ts\n\n\n\n// util/delay.ts\nasync function delay(delayInMs) {\n  return delayInMs === void 0 ? Promise.resolve() : new Promise((resolve) => setTimeout(resolve, delayInMs));\n}\n\n// util/retry-error.ts\n\nvar name = \"AI_RetryError\";\nvar marker = `vercel.ai.error.${name}`;\nvar symbol = Symbol.for(marker);\nvar _a;\nvar RetryError = class extends _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.AISDKError {\n  constructor({\n    message,\n    reason,\n    errors\n  }) {\n    super({ name, message });\n    this[_a] = true;\n    this.reason = reason;\n    this.errors = errors;\n    this.lastError = errors[errors.length - 1];\n  }\n  static isInstance(error) {\n    return _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.AISDKError.hasMarker(error, marker);\n  }\n  /**\n   * @deprecated use `isInstance` instead\n   */\n  static isRetryError(error) {\n    return error instanceof Error && error.name === name && typeof error.reason === \"string\" && Array.isArray(error.errors);\n  }\n  /**\n   * @deprecated Do not use this method. It will be removed in the next major version.\n   */\n  toJSON() {\n    return {\n      name: this.name,\n      message: this.message,\n      reason: this.reason,\n      lastError: this.lastError,\n      errors: this.errors\n    };\n  }\n};\n_a = symbol;\n\n// util/retry-with-exponential-backoff.ts\nvar retryWithExponentialBackoff = ({\n  maxRetries = 2,\n  initialDelayInMs = 2e3,\n  backoffFactor = 2\n} = {}) => async (f) => _retryWithExponentialBackoff(f, {\n  maxRetries,\n  delayInMs: initialDelayInMs,\n  backoffFactor\n});\nasync function _retryWithExponentialBackoff(f, {\n  maxRetries,\n  delayInMs,\n  backoffFactor\n}, errors = []) {\n  try {\n    return await f();\n  } catch (error) {\n    if ((0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_1__.isAbortError)(error)) {\n      throw error;\n    }\n    if (maxRetries === 0) {\n      throw error;\n    }\n    const errorMessage = (0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_1__.getErrorMessage)(error);\n    const newErrors = [...errors, error];\n    const tryNumber = newErrors.length;\n    if (tryNumber > maxRetries) {\n      throw new RetryError({\n        message: `Failed after ${tryNumber} attempts. Last error: ${errorMessage}`,\n        reason: \"maxRetriesExceeded\",\n        errors: newErrors\n      });\n    }\n    if (error instanceof Error && _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.APICallError.isAPICallError(error) && error.isRetryable === true && tryNumber <= maxRetries) {\n      await delay(delayInMs);\n      return _retryWithExponentialBackoff(\n        f,\n        { maxRetries, delayInMs: backoffFactor * delayInMs, backoffFactor },\n        newErrors\n      );\n    }\n    if (tryNumber === 1) {\n      throw error;\n    }\n    throw new RetryError({\n      message: `Failed after ${tryNumber} attempts with non-retryable error: '${errorMessage}'`,\n      reason: \"errorNotRetryable\",\n      errors: newErrors\n    });\n  }\n}\n\n// core/telemetry/assemble-operation-name.ts\nfunction assembleOperationName({\n  operationName,\n  telemetry\n}) {\n  return {\n    \"operation.name\": `${operationName}${(telemetry == null ? void 0 : telemetry.functionId) != null ? ` ${telemetry.functionId}` : \"\"}`\n  };\n}\n\n// core/telemetry/get-base-telemetry-attributes.ts\nfunction getBaseTelemetryAttributes({\n  model,\n  settings,\n  telemetry,\n  headers\n}) {\n  var _a12;\n  return {\n    \"ai.model.provider\": model.provider,\n    \"ai.model.id\": model.modelId,\n    // settings:\n    ...Object.entries(settings).reduce((attributes, [key, value]) => {\n      attributes[`ai.settings.${key}`] = value;\n      return attributes;\n    }, {}),\n    // special telemetry information\n    \"resource.name\": telemetry == null ? void 0 : telemetry.functionId,\n    \"ai.telemetry.functionId\": telemetry == null ? void 0 : telemetry.functionId,\n    // add metadata as attributes:\n    ...Object.entries((_a12 = telemetry == null ? void 0 : telemetry.metadata) != null ? _a12 : {}).reduce(\n      (attributes, [key, value]) => {\n        attributes[`ai.telemetry.metadata.${key}`] = value;\n        return attributes;\n      },\n      {}\n    ),\n    // request headers\n    ...Object.entries(headers != null ? headers : {}).reduce((attributes, [key, value]) => {\n      if (value !== void 0) {\n        attributes[`ai.request.headers.${key}`] = value;\n      }\n      return attributes;\n    }, {})\n  };\n}\n\n// core/telemetry/get-tracer.ts\n\n\n// core/telemetry/noop-tracer.ts\nvar noopTracer = {\n  startSpan() {\n    return noopSpan;\n  },\n  startActiveSpan(name12, arg1, arg2, arg3) {\n    if (typeof arg1 === \"function\") {\n      return arg1(noopSpan);\n    }\n    if (typeof arg2 === \"function\") {\n      return arg2(noopSpan);\n    }\n    if (typeof arg3 === \"function\") {\n      return arg3(noopSpan);\n    }\n  }\n};\nvar noopSpan = {\n  spanContext() {\n    return noopSpanContext;\n  },\n  setAttribute() {\n    return this;\n  },\n  setAttributes() {\n    return this;\n  },\n  addEvent() {\n    return this;\n  },\n  addLink() {\n    return this;\n  },\n  addLinks() {\n    return this;\n  },\n  setStatus() {\n    return this;\n  },\n  updateName() {\n    return this;\n  },\n  end() {\n    return this;\n  },\n  isRecording() {\n    return false;\n  },\n  recordException() {\n    return this;\n  }\n};\nvar noopSpanContext = {\n  traceId: \"\",\n  spanId: \"\",\n  traceFlags: 0\n};\n\n// core/telemetry/get-tracer.ts\nvar testTracer = void 0;\nfunction getTracer({ isEnabled }) {\n  if (!isEnabled) {\n    return noopTracer;\n  }\n  if (testTracer) {\n    return testTracer;\n  }\n  return _opentelemetry_api__WEBPACK_IMPORTED_MODULE_2__.trace.getTracer(\"ai\");\n}\n\n// core/telemetry/record-span.ts\n\nfunction recordSpan({\n  name: name12,\n  tracer,\n  attributes,\n  fn,\n  endWhenDone = true\n}) {\n  return tracer.startActiveSpan(name12, { attributes }, async (span) => {\n    try {\n      const result = await fn(span);\n      if (endWhenDone) {\n        span.end();\n      }\n      return result;\n    } catch (error) {\n      try {\n        if (error instanceof Error) {\n          span.recordException({\n            name: error.name,\n            message: error.message,\n            stack: error.stack\n          });\n          span.setStatus({\n            code: _opentelemetry_api__WEBPACK_IMPORTED_MODULE_2__.SpanStatusCode.ERROR,\n            message: error.message\n          });\n        } else {\n          span.setStatus({ code: _opentelemetry_api__WEBPACK_IMPORTED_MODULE_2__.SpanStatusCode.ERROR });\n        }\n      } finally {\n        span.end();\n      }\n      throw error;\n    }\n  });\n}\n\n// core/telemetry/select-telemetry-attributes.ts\nfunction selectTelemetryAttributes({\n  telemetry,\n  attributes\n}) {\n  return Object.entries(attributes).reduce((attributes2, [key, value]) => {\n    if (value === void 0) {\n      return attributes2;\n    }\n    if (typeof value === \"object\" && \"input\" in value && typeof value.input === \"function\") {\n      if ((telemetry == null ? void 0 : telemetry.recordInputs) === false) {\n        return attributes2;\n      }\n      const result = value.input();\n      return result === void 0 ? attributes2 : { ...attributes2, [key]: result };\n    }\n    if (typeof value === \"object\" && \"output\" in value && typeof value.output === \"function\") {\n      if ((telemetry == null ? void 0 : telemetry.recordOutputs) === false) {\n        return attributes2;\n      }\n      const result = value.output();\n      return result === void 0 ? attributes2 : { ...attributes2, [key]: result };\n    }\n    return { ...attributes2, [key]: value };\n  }, {});\n}\n\n// core/embed/embed.ts\nasync function embed({\n  model,\n  value,\n  maxRetries,\n  abortSignal,\n  headers,\n  experimental_telemetry: telemetry\n}) {\n  var _a12;\n  const baseTelemetryAttributes = getBaseTelemetryAttributes({\n    model,\n    telemetry,\n    headers,\n    settings: { maxRetries }\n  });\n  const tracer = getTracer({ isEnabled: (_a12 = telemetry == null ? void 0 : telemetry.isEnabled) != null ? _a12 : false });\n  return recordSpan({\n    name: \"ai.embed\",\n    attributes: selectTelemetryAttributes({\n      telemetry,\n      attributes: {\n        ...assembleOperationName({ operationName: \"ai.embed\", telemetry }),\n        ...baseTelemetryAttributes,\n        \"ai.value\": { input: () => JSON.stringify(value) }\n      }\n    }),\n    tracer,\n    fn: async (span) => {\n      const retry = retryWithExponentialBackoff({ maxRetries });\n      const { embedding, usage, rawResponse } = await retry(\n        () => (\n          // nested spans to align with the embedMany telemetry data:\n          recordSpan({\n            name: \"ai.embed.doEmbed\",\n            attributes: selectTelemetryAttributes({\n              telemetry,\n              attributes: {\n                ...assembleOperationName({\n                  operationName: \"ai.embed.doEmbed\",\n                  telemetry\n                }),\n                ...baseTelemetryAttributes,\n                // specific settings that only make sense on the outer level:\n                \"ai.values\": { input: () => [JSON.stringify(value)] }\n              }\n            }),\n            tracer,\n            fn: async (doEmbedSpan) => {\n              var _a13;\n              const modelResponse = await model.doEmbed({\n                values: [value],\n                abortSignal,\n                headers\n              });\n              const embedding2 = modelResponse.embeddings[0];\n              const usage2 = (_a13 = modelResponse.usage) != null ? _a13 : { tokens: NaN };\n              doEmbedSpan.setAttributes(\n                selectTelemetryAttributes({\n                  telemetry,\n                  attributes: {\n                    \"ai.embeddings\": {\n                      output: () => modelResponse.embeddings.map(\n                        (embedding3) => JSON.stringify(embedding3)\n                      )\n                    },\n                    \"ai.usage.tokens\": usage2.tokens\n                  }\n                })\n              );\n              return {\n                embedding: embedding2,\n                usage: usage2,\n                rawResponse: modelResponse.rawResponse\n              };\n            }\n          })\n        )\n      );\n      span.setAttributes(\n        selectTelemetryAttributes({\n          telemetry,\n          attributes: {\n            \"ai.embedding\": { output: () => JSON.stringify(embedding) },\n            \"ai.usage.tokens\": usage.tokens\n          }\n        })\n      );\n      return new DefaultEmbedResult({ value, embedding, usage, rawResponse });\n    }\n  });\n}\nvar DefaultEmbedResult = class {\n  constructor(options) {\n    this.value = options.value;\n    this.embedding = options.embedding;\n    this.usage = options.usage;\n    this.rawResponse = options.rawResponse;\n  }\n};\n\n// core/util/split-array.ts\nfunction splitArray(array, chunkSize) {\n  if (chunkSize <= 0) {\n    throw new Error(\"chunkSize must be greater than 0\");\n  }\n  const result = [];\n  for (let i = 0; i < array.length; i += chunkSize) {\n    result.push(array.slice(i, i + chunkSize));\n  }\n  return result;\n}\n\n// core/embed/embed-many.ts\nasync function embedMany({\n  model,\n  values,\n  maxRetries,\n  abortSignal,\n  headers,\n  experimental_telemetry: telemetry\n}) {\n  var _a12;\n  const baseTelemetryAttributes = getBaseTelemetryAttributes({\n    model,\n    telemetry,\n    headers,\n    settings: { maxRetries }\n  });\n  const tracer = getTracer({ isEnabled: (_a12 = telemetry == null ? void 0 : telemetry.isEnabled) != null ? _a12 : false });\n  return recordSpan({\n    name: \"ai.embedMany\",\n    attributes: selectTelemetryAttributes({\n      telemetry,\n      attributes: {\n        ...assembleOperationName({ operationName: \"ai.embedMany\", telemetry }),\n        ...baseTelemetryAttributes,\n        // specific settings that only make sense on the outer level:\n        \"ai.values\": {\n          input: () => values.map((value) => JSON.stringify(value))\n        }\n      }\n    }),\n    tracer,\n    fn: async (span) => {\n      const retry = retryWithExponentialBackoff({ maxRetries });\n      const maxEmbeddingsPerCall = model.maxEmbeddingsPerCall;\n      if (maxEmbeddingsPerCall == null) {\n        const { embeddings: embeddings2, usage } = await retry(() => {\n          return recordSpan({\n            name: \"ai.embedMany.doEmbed\",\n            attributes: selectTelemetryAttributes({\n              telemetry,\n              attributes: {\n                ...assembleOperationName({\n                  operationName: \"ai.embedMany.doEmbed\",\n                  telemetry\n                }),\n                ...baseTelemetryAttributes,\n                // specific settings that only make sense on the outer level:\n                \"ai.values\": {\n                  input: () => values.map((value) => JSON.stringify(value))\n                }\n              }\n            }),\n            tracer,\n            fn: async (doEmbedSpan) => {\n              var _a13;\n              const modelResponse = await model.doEmbed({\n                values,\n                abortSignal,\n                headers\n              });\n              const embeddings3 = modelResponse.embeddings;\n              const usage2 = (_a13 = modelResponse.usage) != null ? _a13 : { tokens: NaN };\n              doEmbedSpan.setAttributes(\n                selectTelemetryAttributes({\n                  telemetry,\n                  attributes: {\n                    \"ai.embeddings\": {\n                      output: () => embeddings3.map((embedding) => JSON.stringify(embedding))\n                    },\n                    \"ai.usage.tokens\": usage2.tokens\n                  }\n                })\n              );\n              return { embeddings: embeddings3, usage: usage2 };\n            }\n          });\n        });\n        span.setAttributes(\n          selectTelemetryAttributes({\n            telemetry,\n            attributes: {\n              \"ai.embeddings\": {\n                output: () => embeddings2.map((embedding) => JSON.stringify(embedding))\n              },\n              \"ai.usage.tokens\": usage.tokens\n            }\n          })\n        );\n        return new DefaultEmbedManyResult({ values, embeddings: embeddings2, usage });\n      }\n      const valueChunks = splitArray(values, maxEmbeddingsPerCall);\n      const embeddings = [];\n      let tokens = 0;\n      for (const chunk of valueChunks) {\n        const { embeddings: responseEmbeddings, usage } = await retry(() => {\n          return recordSpan({\n            name: \"ai.embedMany.doEmbed\",\n            attributes: selectTelemetryAttributes({\n              telemetry,\n              attributes: {\n                ...assembleOperationName({\n                  operationName: \"ai.embedMany.doEmbed\",\n                  telemetry\n                }),\n                ...baseTelemetryAttributes,\n                // specific settings that only make sense on the outer level:\n                \"ai.values\": {\n                  input: () => chunk.map((value) => JSON.stringify(value))\n                }\n              }\n            }),\n            tracer,\n            fn: async (doEmbedSpan) => {\n              var _a13;\n              const modelResponse = await model.doEmbed({\n                values: chunk,\n                abortSignal,\n                headers\n              });\n              const embeddings2 = modelResponse.embeddings;\n              const usage2 = (_a13 = modelResponse.usage) != null ? _a13 : { tokens: NaN };\n              doEmbedSpan.setAttributes(\n                selectTelemetryAttributes({\n                  telemetry,\n                  attributes: {\n                    \"ai.embeddings\": {\n                      output: () => embeddings2.map((embedding) => JSON.stringify(embedding))\n                    },\n                    \"ai.usage.tokens\": usage2.tokens\n                  }\n                })\n              );\n              return { embeddings: embeddings2, usage: usage2 };\n            }\n          });\n        });\n        embeddings.push(...responseEmbeddings);\n        tokens += usage.tokens;\n      }\n      span.setAttributes(\n        selectTelemetryAttributes({\n          telemetry,\n          attributes: {\n            \"ai.embeddings\": {\n              output: () => embeddings.map((embedding) => JSON.stringify(embedding))\n            },\n            \"ai.usage.tokens\": tokens\n          }\n        })\n      );\n      return new DefaultEmbedManyResult({\n        values,\n        embeddings,\n        usage: { tokens }\n      });\n    }\n  });\n}\nvar DefaultEmbedManyResult = class {\n  constructor(options) {\n    this.values = options.values;\n    this.embeddings = options.embeddings;\n    this.usage = options.usage;\n  }\n};\n\n// core/generate-object/generate-object.ts\n\n\n\n// core/prompt/convert-to-language-model-prompt.ts\n\n\n// util/download-error.ts\n\nvar name2 = \"AI_DownloadError\";\nvar marker2 = `vercel.ai.error.${name2}`;\nvar symbol2 = Symbol.for(marker2);\nvar _a2;\nvar DownloadError = class extends _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.AISDKError {\n  constructor({\n    url,\n    statusCode,\n    statusText,\n    cause,\n    message = cause == null ? `Failed to download ${url}: ${statusCode} ${statusText}` : `Failed to download ${url}: ${cause}`\n  }) {\n    super({ name: name2, message, cause });\n    this[_a2] = true;\n    this.url = url;\n    this.statusCode = statusCode;\n    this.statusText = statusText;\n  }\n  static isInstance(error) {\n    return _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.AISDKError.hasMarker(error, marker2);\n  }\n  /**\n   * @deprecated use `isInstance` instead\n   */\n  static isDownloadError(error) {\n    return error instanceof Error && error.name === name2 && typeof error.url === \"string\" && (error.statusCode == null || typeof error.statusCode === \"number\") && (error.statusText == null || typeof error.statusText === \"string\");\n  }\n  /**\n   * @deprecated Do not use this method. It will be removed in the next major version.\n   */\n  toJSON() {\n    return {\n      name: this.name,\n      message: this.message,\n      url: this.url,\n      statusCode: this.statusCode,\n      statusText: this.statusText,\n      cause: this.cause\n    };\n  }\n};\n_a2 = symbol2;\n\n// util/download.ts\nasync function download({\n  url,\n  fetchImplementation = fetch\n}) {\n  var _a12;\n  const urlText = url.toString();\n  try {\n    const response = await fetchImplementation(urlText);\n    if (!response.ok) {\n      throw new DownloadError({\n        url: urlText,\n        statusCode: response.status,\n        statusText: response.statusText\n      });\n    }\n    return {\n      data: new Uint8Array(await response.arrayBuffer()),\n      mimeType: (_a12 = response.headers.get(\"content-type\")) != null ? _a12 : void 0\n    };\n  } catch (error) {\n    if (DownloadError.isInstance(error)) {\n      throw error;\n    }\n    throw new DownloadError({ url: urlText, cause: error });\n  }\n}\n\n// core/util/detect-image-mimetype.ts\nvar mimeTypeSignatures = [\n  { mimeType: \"image/gif\", bytes: [71, 73, 70] },\n  { mimeType: \"image/png\", bytes: [137, 80, 78, 71] },\n  { mimeType: \"image/jpeg\", bytes: [255, 216] },\n  { mimeType: \"image/webp\", bytes: [82, 73, 70, 70] }\n];\nfunction detectImageMimeType(image) {\n  for (const { bytes, mimeType } of mimeTypeSignatures) {\n    if (image.length >= bytes.length && bytes.every((byte, index) => image[index] === byte)) {\n      return mimeType;\n    }\n  }\n  return void 0;\n}\n\n// core/prompt/data-content.ts\n\n\n// core/prompt/invalid-data-content-error.ts\n\nvar name3 = \"AI_InvalidDataContentError\";\nvar marker3 = `vercel.ai.error.${name3}`;\nvar symbol3 = Symbol.for(marker3);\nvar _a3;\nvar InvalidDataContentError = class extends _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.AISDKError {\n  constructor({\n    content,\n    cause,\n    message = `Invalid data content. Expected a base64 string, Uint8Array, ArrayBuffer, or Buffer, but got ${typeof content}.`\n  }) {\n    super({ name: name3, message, cause });\n    this[_a3] = true;\n    this.content = content;\n  }\n  static isInstance(error) {\n    return _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.AISDKError.hasMarker(error, marker3);\n  }\n  /**\n   * @deprecated use `isInstance` instead\n   */\n  static isInvalidDataContentError(error) {\n    return error instanceof Error && error.name === name3 && error.content != null;\n  }\n  /**\n   * @deprecated Do not use this method. It will be removed in the next major version.\n   */\n  toJSON() {\n    return {\n      name: this.name,\n      message: this.message,\n      stack: this.stack,\n      cause: this.cause,\n      content: this.content\n    };\n  }\n};\n_a3 = symbol3;\n\n// core/prompt/data-content.ts\nfunction convertDataContentToBase64String(content) {\n  if (typeof content === \"string\") {\n    return content;\n  }\n  if (content instanceof ArrayBuffer) {\n    return (0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_1__.convertUint8ArrayToBase64)(new Uint8Array(content));\n  }\n  return (0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_1__.convertUint8ArrayToBase64)(content);\n}\nfunction convertDataContentToUint8Array(content) {\n  if (content instanceof Uint8Array) {\n    return content;\n  }\n  if (typeof content === \"string\") {\n    try {\n      return (0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_1__.convertBase64ToUint8Array)(content);\n    } catch (error) {\n      throw new InvalidDataContentError({\n        message: \"Invalid data content. Content string is not a base64-encoded media.\",\n        content,\n        cause: error\n      });\n    }\n  }\n  if (content instanceof ArrayBuffer) {\n    return new Uint8Array(content);\n  }\n  throw new InvalidDataContentError({ content });\n}\nfunction convertUint8ArrayToText(uint8Array) {\n  try {\n    return new TextDecoder().decode(uint8Array);\n  } catch (error) {\n    throw new Error(\"Error decoding Uint8Array to text\");\n  }\n}\n\n// core/prompt/invalid-message-role-error.ts\n\nvar name4 = \"AI_InvalidMessageRoleError\";\nvar marker4 = `vercel.ai.error.${name4}`;\nvar symbol4 = Symbol.for(marker4);\nvar _a4;\nvar InvalidMessageRoleError = class extends _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.AISDKError {\n  constructor({\n    role,\n    message = `Invalid message role: '${role}'. Must be one of: \"system\", \"user\", \"assistant\", \"tool\".`\n  }) {\n    super({ name: name4, message });\n    this[_a4] = true;\n    this.role = role;\n  }\n  static isInstance(error) {\n    return _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.AISDKError.hasMarker(error, marker4);\n  }\n  /**\n   * @deprecated use `isInstance` instead\n   */\n  static isInvalidMessageRoleError(error) {\n    return error instanceof Error && error.name === name4 && typeof error.role === \"string\";\n  }\n  /**\n   * @deprecated Do not use this method. It will be removed in the next major version.\n   */\n  toJSON() {\n    return {\n      name: this.name,\n      message: this.message,\n      stack: this.stack,\n      role: this.role\n    };\n  }\n};\n_a4 = symbol4;\n\n// core/prompt/convert-to-language-model-prompt.ts\nasync function convertToLanguageModelPrompt({\n  prompt,\n  modelSupportsImageUrls = true,\n  downloadImplementation = download\n}) {\n  const languageModelMessages = [];\n  if (prompt.system != null) {\n    languageModelMessages.push({ role: \"system\", content: prompt.system });\n  }\n  const downloadedImages = modelSupportsImageUrls || prompt.messages == null ? null : await downloadImages(prompt.messages, downloadImplementation);\n  const promptType = prompt.type;\n  switch (promptType) {\n    case \"prompt\": {\n      languageModelMessages.push({\n        role: \"user\",\n        content: [{ type: \"text\", text: prompt.prompt }]\n      });\n      break;\n    }\n    case \"messages\": {\n      languageModelMessages.push(\n        ...prompt.messages.map(\n          (message) => convertToLanguageModelMessage(message, downloadedImages)\n        )\n      );\n      break;\n    }\n    default: {\n      const _exhaustiveCheck = promptType;\n      throw new Error(`Unsupported prompt type: ${_exhaustiveCheck}`);\n    }\n  }\n  return languageModelMessages;\n}\nfunction convertToLanguageModelMessage(message, downloadedImages) {\n  const role = message.role;\n  switch (role) {\n    case \"system\": {\n      return {\n        role: \"system\",\n        content: message.content,\n        providerMetadata: message.experimental_providerMetadata\n      };\n    }\n    case \"user\": {\n      if (typeof message.content === \"string\") {\n        return {\n          role: \"user\",\n          content: [{ type: \"text\", text: message.content }],\n          providerMetadata: message.experimental_providerMetadata\n        };\n      }\n      return {\n        role: \"user\",\n        content: message.content.map(\n          (part) => {\n            var _a12, _b, _c;\n            switch (part.type) {\n              case \"text\": {\n                return {\n                  type: \"text\",\n                  text: part.text,\n                  providerMetadata: part.experimental_providerMetadata\n                };\n              }\n              case \"image\": {\n                if (part.image instanceof URL) {\n                  if (downloadedImages == null) {\n                    return {\n                      type: \"image\",\n                      image: part.image,\n                      mimeType: part.mimeType,\n                      providerMetadata: part.experimental_providerMetadata\n                    };\n                  } else {\n                    const downloadedImage = downloadedImages[part.image.toString()];\n                    return {\n                      type: \"image\",\n                      image: downloadedImage.data,\n                      mimeType: (_a12 = part.mimeType) != null ? _a12 : downloadedImage.mimeType,\n                      providerMetadata: part.experimental_providerMetadata\n                    };\n                  }\n                }\n                if (typeof part.image === \"string\") {\n                  try {\n                    const url = new URL(part.image);\n                    switch (url.protocol) {\n                      case \"http:\":\n                      case \"https:\": {\n                        if (downloadedImages == null) {\n                          return {\n                            type: \"image\",\n                            image: url,\n                            mimeType: part.mimeType,\n                            providerMetadata: part.experimental_providerMetadata\n                          };\n                        } else {\n                          const downloadedImage = downloadedImages[part.image];\n                          return {\n                            type: \"image\",\n                            image: downloadedImage.data,\n                            mimeType: (_b = part.mimeType) != null ? _b : downloadedImage.mimeType,\n                            providerMetadata: part.experimental_providerMetadata\n                          };\n                        }\n                      }\n                      case \"data:\": {\n                        try {\n                          const [header, base64Content] = part.image.split(\",\");\n                          const mimeType = header.split(\";\")[0].split(\":\")[1];\n                          if (mimeType == null || base64Content == null) {\n                            throw new Error(\"Invalid data URL format\");\n                          }\n                          return {\n                            type: \"image\",\n                            image: convertDataContentToUint8Array(base64Content),\n                            mimeType,\n                            providerMetadata: part.experimental_providerMetadata\n                          };\n                        } catch (error) {\n                          throw new Error(\n                            `Error processing data URL: ${(0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_1__.getErrorMessage)(\n                              message\n                            )}`\n                          );\n                        }\n                      }\n                      default: {\n                        throw new Error(\n                          `Unsupported URL protocol: ${url.protocol}`\n                        );\n                      }\n                    }\n                  } catch (_ignored) {\n                  }\n                }\n                const imageUint8 = convertDataContentToUint8Array(part.image);\n                return {\n                  type: \"image\",\n                  image: imageUint8,\n                  mimeType: (_c = part.mimeType) != null ? _c : detectImageMimeType(imageUint8),\n                  providerMetadata: part.experimental_providerMetadata\n                };\n              }\n            }\n          }\n        ),\n        providerMetadata: message.experimental_providerMetadata\n      };\n    }\n    case \"assistant\": {\n      if (typeof message.content === \"string\") {\n        return {\n          role: \"assistant\",\n          content: [{ type: \"text\", text: message.content }],\n          providerMetadata: message.experimental_providerMetadata\n        };\n      }\n      return {\n        role: \"assistant\",\n        content: message.content.filter(\n          // remove empty text parts:\n          (part) => part.type !== \"text\" || part.text !== \"\"\n        ),\n        providerMetadata: message.experimental_providerMetadata\n      };\n    }\n    case \"tool\": {\n      return {\n        role: \"tool\",\n        content: message.content.map((part) => ({\n          type: \"tool-result\",\n          toolCallId: part.toolCallId,\n          toolName: part.toolName,\n          result: part.result,\n          providerMetadata: part.experimental_providerMetadata\n        })),\n        providerMetadata: message.experimental_providerMetadata\n      };\n    }\n    default: {\n      const _exhaustiveCheck = role;\n      throw new InvalidMessageRoleError({ role: _exhaustiveCheck });\n    }\n  }\n}\nasync function downloadImages(messages, downloadImplementation) {\n  const urls = messages.filter((message) => message.role === \"user\").map((message) => message.content).filter(\n    (content) => Array.isArray(content)\n  ).flat().filter((part) => part.type === \"image\").map((part) => part.image).map(\n    (part) => (\n      // support string urls in image parts:\n      typeof part === \"string\" && (part.startsWith(\"http:\") || part.startsWith(\"https:\")) ? new URL(part) : part\n    )\n  ).filter((image) => image instanceof URL);\n  const downloadedImages = await Promise.all(\n    urls.map(async (url) => ({\n      url,\n      data: await downloadImplementation({ url })\n    }))\n  );\n  return Object.fromEntries(\n    downloadedImages.map(({ url, data }) => [url.toString(), data])\n  );\n}\n\n// core/prompt/get-validated-prompt.ts\n\nfunction getValidatedPrompt(prompt) {\n  if (prompt.prompt == null && prompt.messages == null) {\n    throw new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.InvalidPromptError({\n      prompt,\n      message: \"prompt or messages must be defined\"\n    });\n  }\n  if (prompt.prompt != null && prompt.messages != null) {\n    throw new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.InvalidPromptError({\n      prompt,\n      message: \"prompt and messages cannot be defined at the same time\"\n    });\n  }\n  if (prompt.messages != null) {\n    for (const message of prompt.messages) {\n      if (message.role === \"system\" && typeof message.content !== \"string\") {\n        throw new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.InvalidPromptError({\n          prompt,\n          message: \"system message content must be a string\"\n        });\n      }\n    }\n  }\n  return prompt.prompt != null ? {\n    type: \"prompt\",\n    prompt: prompt.prompt,\n    messages: void 0,\n    system: prompt.system\n  } : {\n    type: \"messages\",\n    prompt: void 0,\n    messages: prompt.messages,\n    // only possible case bc of checks above\n    system: prompt.system\n  };\n}\n\n// errors/invalid-argument-error.ts\n\nvar name5 = \"AI_InvalidArgumentError\";\nvar marker5 = `vercel.ai.error.${name5}`;\nvar symbol5 = Symbol.for(marker5);\nvar _a5;\nvar InvalidArgumentError = class extends _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.AISDKError {\n  constructor({\n    parameter,\n    value,\n    message\n  }) {\n    super({\n      name: name5,\n      message: `Invalid argument for parameter ${parameter}: ${message}`\n    });\n    this[_a5] = true;\n    this.parameter = parameter;\n    this.value = value;\n  }\n  static isInstance(error) {\n    return _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.AISDKError.hasMarker(error, marker5);\n  }\n  /**\n   * @deprecated use `isInstance` instead\n   */\n  static isInvalidArgumentError(error) {\n    return error instanceof Error && error.name === name5 && typeof error.parameter === \"string\" && typeof error.value === \"string\";\n  }\n  toJSON() {\n    return {\n      name: this.name,\n      message: this.message,\n      stack: this.stack,\n      parameter: this.parameter,\n      value: this.value\n    };\n  }\n};\n_a5 = symbol5;\n\n// core/prompt/prepare-call-settings.ts\nfunction prepareCallSettings({\n  maxTokens,\n  temperature,\n  topP,\n  presencePenalty,\n  frequencyPenalty,\n  stopSequences,\n  seed,\n  maxRetries\n}) {\n  if (maxTokens != null) {\n    if (!Number.isInteger(maxTokens)) {\n      throw new InvalidArgumentError({\n        parameter: \"maxTokens\",\n        value: maxTokens,\n        message: \"maxTokens must be an integer\"\n      });\n    }\n    if (maxTokens < 1) {\n      throw new InvalidArgumentError({\n        parameter: \"maxTokens\",\n        value: maxTokens,\n        message: \"maxTokens must be >= 1\"\n      });\n    }\n  }\n  if (temperature != null) {\n    if (typeof temperature !== \"number\") {\n      throw new InvalidArgumentError({\n        parameter: \"temperature\",\n        value: temperature,\n        message: \"temperature must be a number\"\n      });\n    }\n  }\n  if (topP != null) {\n    if (typeof topP !== \"number\") {\n      throw new InvalidArgumentError({\n        parameter: \"topP\",\n        value: topP,\n        message: \"topP must be a number\"\n      });\n    }\n  }\n  if (presencePenalty != null) {\n    if (typeof presencePenalty !== \"number\") {\n      throw new InvalidArgumentError({\n        parameter: \"presencePenalty\",\n        value: presencePenalty,\n        message: \"presencePenalty must be a number\"\n      });\n    }\n  }\n  if (frequencyPenalty != null) {\n    if (typeof frequencyPenalty !== \"number\") {\n      throw new InvalidArgumentError({\n        parameter: \"frequencyPenalty\",\n        value: frequencyPenalty,\n        message: \"frequencyPenalty must be a number\"\n      });\n    }\n  }\n  if (seed != null) {\n    if (!Number.isInteger(seed)) {\n      throw new InvalidArgumentError({\n        parameter: \"seed\",\n        value: seed,\n        message: \"seed must be an integer\"\n      });\n    }\n  }\n  if (maxRetries != null) {\n    if (!Number.isInteger(maxRetries)) {\n      throw new InvalidArgumentError({\n        parameter: \"maxRetries\",\n        value: maxRetries,\n        message: \"maxRetries must be an integer\"\n      });\n    }\n    if (maxRetries < 0) {\n      throw new InvalidArgumentError({\n        parameter: \"maxRetries\",\n        value: maxRetries,\n        message: \"maxRetries must be >= 0\"\n      });\n    }\n  }\n  return {\n    maxTokens,\n    temperature: temperature != null ? temperature : 0,\n    topP,\n    presencePenalty,\n    frequencyPenalty,\n    stopSequences: stopSequences != null && stopSequences.length > 0 ? stopSequences : void 0,\n    seed,\n    maxRetries: maxRetries != null ? maxRetries : 2\n  };\n}\n\n// core/types/token-usage.ts\nfunction calculateCompletionTokenUsage(usage) {\n  return {\n    promptTokens: usage.promptTokens,\n    completionTokens: usage.completionTokens,\n    totalTokens: usage.promptTokens + usage.completionTokens\n  };\n}\n\n// core/util/prepare-response-headers.ts\nfunction prepareResponseHeaders(init, {\n  contentType,\n  dataStreamVersion\n}) {\n  var _a12;\n  const headers = new Headers((_a12 = init == null ? void 0 : init.headers) != null ? _a12 : {});\n  if (!headers.has(\"Content-Type\")) {\n    headers.set(\"Content-Type\", contentType);\n  }\n  if (dataStreamVersion !== void 0) {\n    headers.set(\"X-Vercel-AI-Data-Stream\", dataStreamVersion);\n  }\n  return headers;\n}\n\n// core/generate-object/inject-json-schema-into-system.ts\nvar DEFAULT_SCHEMA_PREFIX = \"JSON schema:\";\nvar DEFAULT_SCHEMA_SUFFIX = \"You MUST answer with a JSON object that matches the JSON schema above.\";\nfunction injectJsonSchemaIntoSystem({\n  system,\n  schema,\n  schemaPrefix = DEFAULT_SCHEMA_PREFIX,\n  schemaSuffix = DEFAULT_SCHEMA_SUFFIX\n}) {\n  return [\n    system,\n    system != null ? \"\" : null,\n    // add a newline if system is not null\n    schemaPrefix,\n    JSON.stringify(schema),\n    schemaSuffix\n  ].filter((line) => line != null).join(\"\\n\");\n}\n\n// core/generate-object/no-object-generated-error.ts\n\nvar name6 = \"AI_NoObjectGeneratedError\";\nvar marker6 = `vercel.ai.error.${name6}`;\nvar symbol6 = Symbol.for(marker6);\nvar _a6;\nvar NoObjectGeneratedError = class extends _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.AISDKError {\n  // used in isInstance\n  constructor({ message = \"No object generated.\" } = {}) {\n    super({ name: name6, message });\n    this[_a6] = true;\n  }\n  static isInstance(error) {\n    return _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.AISDKError.hasMarker(error, marker6);\n  }\n  /**\n   * @deprecated Use isInstance instead.\n   */\n  static isNoObjectGeneratedError(error) {\n    return error instanceof Error && error.name === name6;\n  }\n  /**\n   * @deprecated Do not use this method. It will be removed in the next major version.\n   */\n  toJSON() {\n    return {\n      name: this.name,\n      cause: this.cause,\n      message: this.message,\n      stack: this.stack\n    };\n  }\n};\n_a6 = symbol6;\n\n// core/generate-object/generate-object.ts\nasync function generateObject({\n  model,\n  schema: inputSchema,\n  schemaName,\n  schemaDescription,\n  mode,\n  system,\n  prompt,\n  messages,\n  maxRetries,\n  abortSignal,\n  headers,\n  experimental_telemetry: telemetry,\n  ...settings\n}) {\n  var _a12;\n  const baseTelemetryAttributes = getBaseTelemetryAttributes({\n    model,\n    telemetry,\n    headers,\n    settings: { ...settings, maxRetries }\n  });\n  const schema = (0,_ai_sdk_ui_utils__WEBPACK_IMPORTED_MODULE_3__.asSchema)(inputSchema);\n  const tracer = getTracer({ isEnabled: (_a12 = telemetry == null ? void 0 : telemetry.isEnabled) != null ? _a12 : false });\n  return recordSpan({\n    name: \"ai.generateObject\",\n    attributes: selectTelemetryAttributes({\n      telemetry,\n      attributes: {\n        ...assembleOperationName({\n          operationName: \"ai.generateObject\",\n          telemetry\n        }),\n        ...baseTelemetryAttributes,\n        // specific settings that only make sense on the outer level:\n        \"ai.prompt\": {\n          input: () => JSON.stringify({ system, prompt, messages })\n        },\n        \"ai.schema\": {\n          input: () => JSON.stringify(schema.jsonSchema)\n        },\n        \"ai.schema.name\": schemaName,\n        \"ai.schema.description\": schemaDescription,\n        \"ai.settings.mode\": mode\n      }\n    }),\n    tracer,\n    fn: async (span) => {\n      const retry = retryWithExponentialBackoff({ maxRetries });\n      if (mode === \"auto\" || mode == null) {\n        mode = model.defaultObjectGenerationMode;\n      }\n      let result;\n      let finishReason;\n      let usage;\n      let warnings;\n      let rawResponse;\n      let logprobs;\n      let providerMetadata;\n      switch (mode) {\n        case \"json\": {\n          const validatedPrompt = getValidatedPrompt({\n            system: model.supportsStructuredOutputs ? system : injectJsonSchemaIntoSystem({\n              system,\n              schema: schema.jsonSchema\n            }),\n            prompt,\n            messages\n          });\n          const promptMessages = await convertToLanguageModelPrompt({\n            prompt: validatedPrompt,\n            modelSupportsImageUrls: model.supportsImageUrls\n          });\n          const inputFormat = validatedPrompt.type;\n          const generateResult = await retry(\n            () => recordSpan({\n              name: \"ai.generateObject.doGenerate\",\n              attributes: selectTelemetryAttributes({\n                telemetry,\n                attributes: {\n                  ...assembleOperationName({\n                    operationName: \"ai.generateObject.doGenerate\",\n                    telemetry\n                  }),\n                  ...baseTelemetryAttributes,\n                  \"ai.prompt.format\": {\n                    input: () => inputFormat\n                  },\n                  \"ai.prompt.messages\": {\n                    input: () => JSON.stringify(promptMessages)\n                  },\n                  \"ai.settings.mode\": mode,\n                  // standardized gen-ai llm span attributes:\n                  \"gen_ai.request.model\": model.modelId,\n                  \"gen_ai.system\": model.provider,\n                  \"gen_ai.request.max_tokens\": settings.maxTokens,\n                  \"gen_ai.request.temperature\": settings.temperature,\n                  \"gen_ai.request.top_p\": settings.topP\n                }\n              }),\n              tracer,\n              fn: async (span2) => {\n                const result2 = await model.doGenerate({\n                  mode: {\n                    type: \"object-json\",\n                    schema: schema.jsonSchema,\n                    name: schemaName,\n                    description: schemaDescription\n                  },\n                  ...prepareCallSettings(settings),\n                  inputFormat,\n                  prompt: promptMessages,\n                  abortSignal,\n                  headers\n                });\n                if (result2.text === void 0) {\n                  throw new NoObjectGeneratedError();\n                }\n                span2.setAttributes(\n                  selectTelemetryAttributes({\n                    telemetry,\n                    attributes: {\n                      \"ai.finishReason\": result2.finishReason,\n                      \"ai.usage.promptTokens\": result2.usage.promptTokens,\n                      \"ai.usage.completionTokens\": result2.usage.completionTokens,\n                      \"ai.result.object\": { output: () => result2.text },\n                      // standardized gen-ai llm span attributes:\n                      \"gen_ai.response.finish_reasons\": [result2.finishReason],\n                      \"gen_ai.usage.prompt_tokens\": result2.usage.promptTokens,\n                      \"gen_ai.usage.completion_tokens\": result2.usage.completionTokens\n                    }\n                  })\n                );\n                return { ...result2, objectText: result2.text };\n              }\n            })\n          );\n          result = generateResult.objectText;\n          finishReason = generateResult.finishReason;\n          usage = generateResult.usage;\n          warnings = generateResult.warnings;\n          rawResponse = generateResult.rawResponse;\n          logprobs = generateResult.logprobs;\n          providerMetadata = generateResult.providerMetadata;\n          break;\n        }\n        case \"tool\": {\n          const validatedPrompt = getValidatedPrompt({\n            system,\n            prompt,\n            messages\n          });\n          const promptMessages = await convertToLanguageModelPrompt({\n            prompt: validatedPrompt,\n            modelSupportsImageUrls: model.supportsImageUrls\n          });\n          const inputFormat = validatedPrompt.type;\n          const generateResult = await retry(\n            () => recordSpan({\n              name: \"ai.generateObject.doGenerate\",\n              attributes: selectTelemetryAttributes({\n                telemetry,\n                attributes: {\n                  ...assembleOperationName({\n                    operationName: \"ai.generateObject.doGenerate\",\n                    telemetry\n                  }),\n                  ...baseTelemetryAttributes,\n                  \"ai.prompt.format\": {\n                    input: () => inputFormat\n                  },\n                  \"ai.prompt.messages\": {\n                    input: () => JSON.stringify(promptMessages)\n                  },\n                  \"ai.settings.mode\": mode,\n                  // standardized gen-ai llm span attributes:\n                  \"gen_ai.request.model\": model.modelId,\n                  \"gen_ai.system\": model.provider,\n                  \"gen_ai.request.max_tokens\": settings.maxTokens,\n                  \"gen_ai.request.temperature\": settings.temperature,\n                  \"gen_ai.request.top_p\": settings.topP\n                }\n              }),\n              tracer,\n              fn: async (span2) => {\n                var _a13, _b;\n                const result2 = await model.doGenerate({\n                  mode: {\n                    type: \"object-tool\",\n                    tool: {\n                      type: \"function\",\n                      name: schemaName != null ? schemaName : \"json\",\n                      description: schemaDescription != null ? schemaDescription : \"Respond with a JSON object.\",\n                      parameters: schema.jsonSchema\n                    }\n                  },\n                  ...prepareCallSettings(settings),\n                  inputFormat,\n                  prompt: promptMessages,\n                  abortSignal,\n                  headers\n                });\n                const objectText = (_b = (_a13 = result2.toolCalls) == null ? void 0 : _a13[0]) == null ? void 0 : _b.args;\n                if (objectText === void 0) {\n                  throw new NoObjectGeneratedError();\n                }\n                span2.setAttributes(\n                  selectTelemetryAttributes({\n                    telemetry,\n                    attributes: {\n                      \"ai.finishReason\": result2.finishReason,\n                      \"ai.usage.promptTokens\": result2.usage.promptTokens,\n                      \"ai.usage.completionTokens\": result2.usage.completionTokens,\n                      \"ai.result.object\": { output: () => objectText },\n                      // standardized gen-ai llm span attributes:\n                      \"gen_ai.response.finish_reasons\": [result2.finishReason],\n                      \"gen_ai.usage.prompt_tokens\": result2.usage.promptTokens,\n                      \"gen_ai.usage.completion_tokens\": result2.usage.completionTokens\n                    }\n                  })\n                );\n                return { ...result2, objectText };\n              }\n            })\n          );\n          result = generateResult.objectText;\n          finishReason = generateResult.finishReason;\n          usage = generateResult.usage;\n          warnings = generateResult.warnings;\n          rawResponse = generateResult.rawResponse;\n          logprobs = generateResult.logprobs;\n          providerMetadata = generateResult.providerMetadata;\n          break;\n        }\n        case void 0: {\n          throw new Error(\n            \"Model does not have a default object generation mode.\"\n          );\n        }\n        default: {\n          const _exhaustiveCheck = mode;\n          throw new Error(`Unsupported mode: ${_exhaustiveCheck}`);\n        }\n      }\n      const parseResult = (0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_1__.safeParseJSON)({ text: result, schema });\n      if (!parseResult.success) {\n        throw parseResult.error;\n      }\n      span.setAttributes(\n        selectTelemetryAttributes({\n          telemetry,\n          attributes: {\n            \"ai.finishReason\": finishReason,\n            \"ai.usage.promptTokens\": usage.promptTokens,\n            \"ai.usage.completionTokens\": usage.completionTokens,\n            \"ai.result.object\": {\n              output: () => JSON.stringify(parseResult.value)\n            }\n          }\n        })\n      );\n      return new DefaultGenerateObjectResult({\n        object: parseResult.value,\n        finishReason,\n        usage: calculateCompletionTokenUsage(usage),\n        warnings,\n        rawResponse,\n        logprobs,\n        providerMetadata\n      });\n    }\n  });\n}\nvar DefaultGenerateObjectResult = class {\n  constructor(options) {\n    this.object = options.object;\n    this.finishReason = options.finishReason;\n    this.usage = options.usage;\n    this.warnings = options.warnings;\n    this.rawResponse = options.rawResponse;\n    this.logprobs = options.logprobs;\n    this.experimental_providerMetadata = options.providerMetadata;\n  }\n  toJsonResponse(init) {\n    var _a12;\n    return new Response(JSON.stringify(this.object), {\n      status: (_a12 = init == null ? void 0 : init.status) != null ? _a12 : 200,\n      headers: prepareResponseHeaders(init, {\n        contentType: \"application/json; charset=utf-8\"\n      })\n    });\n  }\n};\nvar experimental_generateObject = generateObject;\n\n// core/generate-object/stream-object.ts\n\n\n\n// util/create-resolvable-promise.ts\nfunction createResolvablePromise() {\n  let resolve;\n  let reject;\n  const promise = new Promise((res, rej) => {\n    resolve = res;\n    reject = rej;\n  });\n  return {\n    promise,\n    resolve,\n    reject\n  };\n}\n\n// util/delayed-promise.ts\nvar DelayedPromise = class {\n  constructor() {\n    this.status = { type: \"pending\" };\n    this._resolve = void 0;\n    this._reject = void 0;\n  }\n  get value() {\n    if (this.promise) {\n      return this.promise;\n    }\n    this.promise = new Promise((resolve, reject) => {\n      if (this.status.type === \"resolved\") {\n        resolve(this.status.value);\n      } else if (this.status.type === \"rejected\") {\n        reject(this.status.error);\n      }\n      this._resolve = resolve;\n      this._reject = reject;\n    });\n    return this.promise;\n  }\n  resolve(value) {\n    var _a12;\n    this.status = { type: \"resolved\", value };\n    if (this.promise) {\n      (_a12 = this._resolve) == null ? void 0 : _a12.call(this, value);\n    }\n  }\n  reject(error) {\n    var _a12;\n    this.status = { type: \"rejected\", error };\n    if (this.promise) {\n      (_a12 = this._reject) == null ? void 0 : _a12.call(this, error);\n    }\n  }\n};\n\n// core/util/async-iterable-stream.ts\nfunction createAsyncIterableStream(source, transformer) {\n  const transformedStream = source.pipeThrough(\n    new TransformStream(transformer)\n  );\n  transformedStream[Symbol.asyncIterator] = () => {\n    const reader = transformedStream.getReader();\n    return {\n      async next() {\n        const { done, value } = await reader.read();\n        return done ? { done: true, value: void 0 } : { done: false, value };\n      }\n    };\n  };\n  return transformedStream;\n}\n\n// core/generate-object/stream-object.ts\nasync function streamObject({\n  model,\n  schema: inputSchema,\n  schemaName,\n  schemaDescription,\n  mode,\n  system,\n  prompt,\n  messages,\n  maxRetries,\n  abortSignal,\n  headers,\n  experimental_telemetry: telemetry,\n  onFinish,\n  ...settings\n}) {\n  var _a12;\n  const baseTelemetryAttributes = getBaseTelemetryAttributes({\n    model,\n    telemetry,\n    headers,\n    settings: { ...settings, maxRetries }\n  });\n  const tracer = getTracer({ isEnabled: (_a12 = telemetry == null ? void 0 : telemetry.isEnabled) != null ? _a12 : false });\n  const retry = retryWithExponentialBackoff({ maxRetries });\n  const schema = (0,_ai_sdk_ui_utils__WEBPACK_IMPORTED_MODULE_3__.asSchema)(inputSchema);\n  return recordSpan({\n    name: \"ai.streamObject\",\n    attributes: selectTelemetryAttributes({\n      telemetry,\n      attributes: {\n        ...assembleOperationName({\n          operationName: \"ai.streamObject\",\n          telemetry\n        }),\n        ...baseTelemetryAttributes,\n        // specific settings that only make sense on the outer level:\n        \"ai.prompt\": {\n          input: () => JSON.stringify({ system, prompt, messages })\n        },\n        \"ai.schema\": { input: () => JSON.stringify(schema.jsonSchema) },\n        \"ai.schema.name\": schemaName,\n        \"ai.schema.description\": schemaDescription,\n        \"ai.settings.mode\": mode\n      }\n    }),\n    tracer,\n    endWhenDone: false,\n    fn: async (rootSpan) => {\n      if (mode === \"auto\" || mode == null) {\n        mode = model.defaultObjectGenerationMode;\n      }\n      let callOptions;\n      let transformer;\n      switch (mode) {\n        case \"json\": {\n          const validatedPrompt = getValidatedPrompt({\n            system: model.supportsStructuredOutputs ? system : injectJsonSchemaIntoSystem({\n              system,\n              schema: schema.jsonSchema\n            }),\n            prompt,\n            messages\n          });\n          callOptions = {\n            mode: {\n              type: \"object-json\",\n              schema: schema.jsonSchema,\n              name: schemaName,\n              description: schemaDescription\n            },\n            ...prepareCallSettings(settings),\n            inputFormat: validatedPrompt.type,\n            prompt: await convertToLanguageModelPrompt({\n              prompt: validatedPrompt,\n              modelSupportsImageUrls: model.supportsImageUrls\n            }),\n            abortSignal,\n            headers\n          };\n          transformer = {\n            transform: (chunk, controller) => {\n              switch (chunk.type) {\n                case \"text-delta\":\n                  controller.enqueue(chunk.textDelta);\n                  break;\n                case \"finish\":\n                case \"error\":\n                  controller.enqueue(chunk);\n                  break;\n              }\n            }\n          };\n          break;\n        }\n        case \"tool\": {\n          const validatedPrompt = getValidatedPrompt({\n            system,\n            prompt,\n            messages\n          });\n          callOptions = {\n            mode: {\n              type: \"object-tool\",\n              tool: {\n                type: \"function\",\n                name: schemaName != null ? schemaName : \"json\",\n                description: schemaDescription != null ? schemaDescription : \"Respond with a JSON object.\",\n                parameters: schema.jsonSchema\n              }\n            },\n            ...prepareCallSettings(settings),\n            inputFormat: validatedPrompt.type,\n            prompt: await convertToLanguageModelPrompt({\n              prompt: validatedPrompt,\n              modelSupportsImageUrls: model.supportsImageUrls\n            }),\n            abortSignal,\n            headers\n          };\n          transformer = {\n            transform(chunk, controller) {\n              switch (chunk.type) {\n                case \"tool-call-delta\":\n                  controller.enqueue(chunk.argsTextDelta);\n                  break;\n                case \"finish\":\n                case \"error\":\n                  controller.enqueue(chunk);\n                  break;\n              }\n            }\n          };\n          break;\n        }\n        case void 0: {\n          throw new Error(\n            \"Model does not have a default object generation mode.\"\n          );\n        }\n        default: {\n          const _exhaustiveCheck = mode;\n          throw new Error(`Unsupported mode: ${_exhaustiveCheck}`);\n        }\n      }\n      const {\n        result: { stream, warnings, rawResponse },\n        doStreamSpan\n      } = await retry(\n        () => recordSpan({\n          name: \"ai.streamObject.doStream\",\n          attributes: selectTelemetryAttributes({\n            telemetry,\n            attributes: {\n              ...assembleOperationName({\n                operationName: \"ai.streamObject.doStream\",\n                telemetry\n              }),\n              ...baseTelemetryAttributes,\n              \"ai.prompt.format\": {\n                input: () => callOptions.inputFormat\n              },\n              \"ai.prompt.messages\": {\n                input: () => JSON.stringify(callOptions.prompt)\n              },\n              \"ai.settings.mode\": mode,\n              // standardized gen-ai llm span attributes:\n              \"gen_ai.request.model\": model.modelId,\n              \"gen_ai.system\": model.provider,\n              \"gen_ai.request.max_tokens\": settings.maxTokens,\n              \"gen_ai.request.temperature\": settings.temperature,\n              \"gen_ai.request.top_p\": settings.topP\n            }\n          }),\n          tracer,\n          endWhenDone: false,\n          fn: async (doStreamSpan2) => ({\n            result: await model.doStream(callOptions),\n            doStreamSpan: doStreamSpan2\n          })\n        })\n      );\n      return new DefaultStreamObjectResult({\n        stream: stream.pipeThrough(new TransformStream(transformer)),\n        warnings,\n        rawResponse,\n        schema,\n        onFinish,\n        rootSpan,\n        doStreamSpan,\n        telemetry\n      });\n    }\n  });\n}\nvar DefaultStreamObjectResult = class {\n  constructor({\n    stream,\n    warnings,\n    rawResponse,\n    schema,\n    onFinish,\n    rootSpan,\n    doStreamSpan,\n    telemetry\n  }) {\n    this.warnings = warnings;\n    this.rawResponse = rawResponse;\n    this.objectPromise = new DelayedPromise();\n    const { resolve: resolveUsage, promise: usagePromise } = createResolvablePromise();\n    this.usage = usagePromise;\n    const {\n      resolve: resolveProviderMetadata,\n      promise: providerMetadataPromise\n    } = createResolvablePromise();\n    this.experimental_providerMetadata = providerMetadataPromise;\n    let usage;\n    let finishReason;\n    let providerMetadata;\n    let object;\n    let error;\n    let accumulatedText = \"\";\n    let delta = \"\";\n    let latestObject = void 0;\n    let firstChunk = true;\n    const self = this;\n    this.originalStream = stream.pipeThrough(\n      new TransformStream({\n        async transform(chunk, controller) {\n          if (firstChunk) {\n            firstChunk = false;\n            doStreamSpan.addEvent(\"ai.stream.firstChunk\");\n          }\n          if (typeof chunk === \"string\") {\n            accumulatedText += chunk;\n            delta += chunk;\n            const currentObject = (0,_ai_sdk_ui_utils__WEBPACK_IMPORTED_MODULE_3__.parsePartialJson)(\n              accumulatedText\n            );\n            if (!(0,_ai_sdk_ui_utils__WEBPACK_IMPORTED_MODULE_3__.isDeepEqualData)(latestObject, currentObject)) {\n              latestObject = currentObject;\n              controller.enqueue({\n                type: \"object\",\n                object: currentObject\n              });\n              controller.enqueue({\n                type: \"text-delta\",\n                textDelta: delta\n              });\n              delta = \"\";\n            }\n            return;\n          }\n          switch (chunk.type) {\n            case \"finish\": {\n              if (delta !== \"\") {\n                controller.enqueue({\n                  type: \"text-delta\",\n                  textDelta: delta\n                });\n              }\n              finishReason = chunk.finishReason;\n              usage = calculateCompletionTokenUsage(chunk.usage);\n              providerMetadata = chunk.providerMetadata;\n              controller.enqueue({ ...chunk, usage });\n              resolveUsage(usage);\n              resolveProviderMetadata(providerMetadata);\n              const validationResult = (0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_1__.safeValidateTypes)({\n                value: latestObject,\n                schema\n              });\n              if (validationResult.success) {\n                object = validationResult.value;\n                self.objectPromise.resolve(object);\n              } else {\n                error = validationResult.error;\n                self.objectPromise.reject(error);\n              }\n              break;\n            }\n            default: {\n              controller.enqueue(chunk);\n              break;\n            }\n          }\n        },\n        // invoke onFinish callback and resolve toolResults promise when the stream is about to close:\n        async flush(controller) {\n          try {\n            const finalUsage = usage != null ? usage : {\n              promptTokens: NaN,\n              completionTokens: NaN,\n              totalTokens: NaN\n            };\n            doStreamSpan.setAttributes(\n              selectTelemetryAttributes({\n                telemetry,\n                attributes: {\n                  \"ai.finishReason\": finishReason,\n                  \"ai.usage.promptTokens\": finalUsage.promptTokens,\n                  \"ai.usage.completionTokens\": finalUsage.completionTokens,\n                  \"ai.result.object\": {\n                    output: () => JSON.stringify(object)\n                  },\n                  // standardized gen-ai llm span attributes:\n                  \"gen_ai.usage.prompt_tokens\": finalUsage.promptTokens,\n                  \"gen_ai.usage.completion_tokens\": finalUsage.completionTokens,\n                  \"gen_ai.response.finish_reasons\": [finishReason]\n                }\n              })\n            );\n            doStreamSpan.end();\n            rootSpan.setAttributes(\n              selectTelemetryAttributes({\n                telemetry,\n                attributes: {\n                  \"ai.usage.promptTokens\": finalUsage.promptTokens,\n                  \"ai.usage.completionTokens\": finalUsage.completionTokens,\n                  \"ai.result.object\": {\n                    output: () => JSON.stringify(object)\n                  }\n                }\n              })\n            );\n            await (onFinish == null ? void 0 : onFinish({\n              usage: finalUsage,\n              object,\n              error,\n              rawResponse,\n              warnings,\n              experimental_providerMetadata: providerMetadata\n            }));\n          } catch (error2) {\n            controller.error(error2);\n          } finally {\n            rootSpan.end();\n          }\n        }\n      })\n    );\n  }\n  get object() {\n    return this.objectPromise.value;\n  }\n  get partialObjectStream() {\n    return createAsyncIterableStream(this.originalStream, {\n      transform(chunk, controller) {\n        switch (chunk.type) {\n          case \"object\":\n            controller.enqueue(chunk.object);\n            break;\n          case \"text-delta\":\n          case \"finish\":\n            break;\n          case \"error\":\n            controller.error(chunk.error);\n            break;\n          default: {\n            const _exhaustiveCheck = chunk;\n            throw new Error(`Unsupported chunk type: ${_exhaustiveCheck}`);\n          }\n        }\n      }\n    });\n  }\n  get textStream() {\n    return createAsyncIterableStream(this.originalStream, {\n      transform(chunk, controller) {\n        switch (chunk.type) {\n          case \"text-delta\":\n            controller.enqueue(chunk.textDelta);\n            break;\n          case \"object\":\n          case \"finish\":\n            break;\n          case \"error\":\n            controller.error(chunk.error);\n            break;\n          default: {\n            const _exhaustiveCheck = chunk;\n            throw new Error(`Unsupported chunk type: ${_exhaustiveCheck}`);\n          }\n        }\n      }\n    });\n  }\n  get fullStream() {\n    return createAsyncIterableStream(this.originalStream, {\n      transform(chunk, controller) {\n        controller.enqueue(chunk);\n      }\n    });\n  }\n  pipeTextStreamToResponse(response, init) {\n    var _a12;\n    response.writeHead((_a12 = init == null ? void 0 : init.status) != null ? _a12 : 200, {\n      \"Content-Type\": \"text/plain; charset=utf-8\",\n      ...init == null ? void 0 : init.headers\n    });\n    const reader = this.textStream.pipeThrough(new TextEncoderStream()).getReader();\n    const read = async () => {\n      try {\n        while (true) {\n          const { done, value } = await reader.read();\n          if (done)\n            break;\n          response.write(value);\n        }\n      } catch (error) {\n        throw error;\n      } finally {\n        response.end();\n      }\n    };\n    read();\n  }\n  toTextStreamResponse(init) {\n    var _a12;\n    return new Response(this.textStream.pipeThrough(new TextEncoderStream()), {\n      status: (_a12 = init == null ? void 0 : init.status) != null ? _a12 : 200,\n      headers: prepareResponseHeaders(init, {\n        contentType: \"text/plain; charset=utf-8\"\n      })\n    });\n  }\n};\nvar experimental_streamObject = streamObject;\n\n// core/prompt/prepare-tools-and-tool-choice.ts\n\n\n// core/util/is-non-empty-object.ts\nfunction isNonEmptyObject(object) {\n  return object != null && Object.keys(object).length > 0;\n}\n\n// core/prompt/prepare-tools-and-tool-choice.ts\nfunction prepareToolsAndToolChoice({\n  tools,\n  toolChoice\n}) {\n  if (!isNonEmptyObject(tools)) {\n    return {\n      tools: void 0,\n      toolChoice: void 0\n    };\n  }\n  return {\n    tools: Object.entries(tools).map(([name12, tool2]) => ({\n      type: \"function\",\n      name: name12,\n      description: tool2.description,\n      parameters: (0,_ai_sdk_ui_utils__WEBPACK_IMPORTED_MODULE_3__.asSchema)(tool2.parameters).jsonSchema\n    })),\n    toolChoice: toolChoice == null ? { type: \"auto\" } : typeof toolChoice === \"string\" ? { type: toolChoice } : { type: \"tool\", toolName: toolChoice.toolName }\n  };\n}\n\n// core/generate-text/tool-call.ts\n\n\n\n// errors/invalid-tool-arguments-error.ts\n\nvar name7 = \"AI_InvalidToolArgumentsError\";\nvar marker7 = `vercel.ai.error.${name7}`;\nvar symbol7 = Symbol.for(marker7);\nvar _a7;\nvar InvalidToolArgumentsError = class extends _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.AISDKError {\n  constructor({\n    toolArgs,\n    toolName,\n    cause,\n    message = `Invalid arguments for tool ${toolName}: ${(0,_ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.getErrorMessage)(\n      cause\n    )}`\n  }) {\n    super({ name: name7, message, cause });\n    this[_a7] = true;\n    this.toolArgs = toolArgs;\n    this.toolName = toolName;\n  }\n  static isInstance(error) {\n    return _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.AISDKError.hasMarker(error, marker7);\n  }\n  /**\n   * @deprecated use `isInstance` instead\n   */\n  static isInvalidToolArgumentsError(error) {\n    return error instanceof Error && error.name === name7 && typeof error.toolName === \"string\" && typeof error.toolArgs === \"string\";\n  }\n  /**\n   * @deprecated Do not use this method. It will be removed in the next major version.\n   */\n  toJSON() {\n    return {\n      name: this.name,\n      message: this.message,\n      cause: this.cause,\n      stack: this.stack,\n      toolName: this.toolName,\n      toolArgs: this.toolArgs\n    };\n  }\n};\n_a7 = symbol7;\n\n// errors/no-such-tool-error.ts\n\nvar name8 = \"AI_NoSuchToolError\";\nvar marker8 = `vercel.ai.error.${name8}`;\nvar symbol8 = Symbol.for(marker8);\nvar _a8;\nvar NoSuchToolError = class extends _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.AISDKError {\n  constructor({\n    toolName,\n    availableTools = void 0,\n    message = `Model tried to call unavailable tool '${toolName}'. ${availableTools === void 0 ? \"No tools are available.\" : `Available tools: ${availableTools.join(\", \")}.`}`\n  }) {\n    super({ name: name8, message });\n    this[_a8] = true;\n    this.toolName = toolName;\n    this.availableTools = availableTools;\n  }\n  static isInstance(error) {\n    return _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.AISDKError.hasMarker(error, marker8);\n  }\n  /**\n   * @deprecated use `isInstance` instead\n   */\n  static isNoSuchToolError(error) {\n    return error instanceof Error && error.name === name8 && \"toolName\" in error && error.toolName != void 0 && typeof error.name === \"string\";\n  }\n  /**\n   * @deprecated Do not use this method. It will be removed in the next major version.\n   */\n  toJSON() {\n    return {\n      name: this.name,\n      message: this.message,\n      stack: this.stack,\n      toolName: this.toolName,\n      availableTools: this.availableTools\n    };\n  }\n};\n_a8 = symbol8;\n\n// core/generate-text/tool-call.ts\nfunction parseToolCall({\n  toolCall,\n  tools\n}) {\n  const toolName = toolCall.toolName;\n  if (tools == null) {\n    throw new NoSuchToolError({ toolName: toolCall.toolName });\n  }\n  const tool2 = tools[toolName];\n  if (tool2 == null) {\n    throw new NoSuchToolError({\n      toolName: toolCall.toolName,\n      availableTools: Object.keys(tools)\n    });\n  }\n  const parseResult = (0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_1__.safeParseJSON)({\n    text: toolCall.args,\n    schema: (0,_ai_sdk_ui_utils__WEBPACK_IMPORTED_MODULE_3__.asSchema)(tool2.parameters)\n  });\n  if (parseResult.success === false) {\n    throw new InvalidToolArgumentsError({\n      toolName,\n      toolArgs: toolCall.args,\n      cause: parseResult.error\n    });\n  }\n  return {\n    type: \"tool-call\",\n    toolCallId: toolCall.toolCallId,\n    toolName,\n    args: parseResult.value\n  };\n}\n\n// core/generate-text/generate-text.ts\nasync function generateText({\n  model,\n  tools,\n  toolChoice,\n  system,\n  prompt,\n  messages,\n  maxRetries,\n  abortSignal,\n  headers,\n  maxAutomaticRoundtrips = 0,\n  maxToolRoundtrips = maxAutomaticRoundtrips,\n  experimental_telemetry: telemetry,\n  ...settings\n}) {\n  var _a12;\n  const baseTelemetryAttributes = getBaseTelemetryAttributes({\n    model,\n    telemetry,\n    headers,\n    settings: { ...settings, maxRetries }\n  });\n  const tracer = getTracer({ isEnabled: (_a12 = telemetry == null ? void 0 : telemetry.isEnabled) != null ? _a12 : false });\n  return recordSpan({\n    name: \"ai.generateText\",\n    attributes: selectTelemetryAttributes({\n      telemetry,\n      attributes: {\n        ...assembleOperationName({\n          operationName: \"ai.generateText\",\n          telemetry\n        }),\n        ...baseTelemetryAttributes,\n        // specific settings that only make sense on the outer level:\n        \"ai.prompt\": {\n          input: () => JSON.stringify({ system, prompt, messages })\n        },\n        \"ai.settings.maxToolRoundtrips\": maxToolRoundtrips\n      }\n    }),\n    tracer,\n    fn: async (span) => {\n      var _a13, _b, _c, _d;\n      const retry = retryWithExponentialBackoff({ maxRetries });\n      const validatedPrompt = getValidatedPrompt({\n        system,\n        prompt,\n        messages\n      });\n      const mode = {\n        type: \"regular\",\n        ...prepareToolsAndToolChoice({ tools, toolChoice })\n      };\n      const callSettings = prepareCallSettings(settings);\n      const promptMessages = await convertToLanguageModelPrompt({\n        prompt: validatedPrompt,\n        modelSupportsImageUrls: model.supportsImageUrls\n      });\n      let currentModelResponse;\n      let currentToolCalls = [];\n      let currentToolResults = [];\n      let roundtripCount = 0;\n      const responseMessages = [];\n      const roundtrips = [];\n      const usage = {\n        completionTokens: 0,\n        promptTokens: 0,\n        totalTokens: 0\n      };\n      do {\n        const currentInputFormat = roundtripCount === 0 ? validatedPrompt.type : \"messages\";\n        currentModelResponse = await retry(\n          () => recordSpan({\n            name: \"ai.generateText.doGenerate\",\n            attributes: selectTelemetryAttributes({\n              telemetry,\n              attributes: {\n                ...assembleOperationName({\n                  operationName: \"ai.generateText.doGenerate\",\n                  telemetry\n                }),\n                ...baseTelemetryAttributes,\n                \"ai.prompt.format\": { input: () => currentInputFormat },\n                \"ai.prompt.messages\": {\n                  input: () => JSON.stringify(promptMessages)\n                },\n                // standardized gen-ai llm span attributes:\n                \"gen_ai.request.model\": model.modelId,\n                \"gen_ai.system\": model.provider,\n                \"gen_ai.request.max_tokens\": settings.maxTokens,\n                \"gen_ai.request.temperature\": settings.temperature,\n                \"gen_ai.request.top_p\": settings.topP\n              }\n            }),\n            tracer,\n            fn: async (span2) => {\n              const result = await model.doGenerate({\n                mode,\n                ...callSettings,\n                inputFormat: currentInputFormat,\n                prompt: promptMessages,\n                abortSignal,\n                headers\n              });\n              span2.setAttributes(\n                selectTelemetryAttributes({\n                  telemetry,\n                  attributes: {\n                    \"ai.finishReason\": result.finishReason,\n                    \"ai.usage.promptTokens\": result.usage.promptTokens,\n                    \"ai.usage.completionTokens\": result.usage.completionTokens,\n                    \"ai.result.text\": {\n                      output: () => result.text\n                    },\n                    \"ai.result.toolCalls\": {\n                      output: () => JSON.stringify(result.toolCalls)\n                    },\n                    // standardized gen-ai llm span attributes:\n                    \"gen_ai.response.finish_reasons\": [result.finishReason],\n                    \"gen_ai.usage.prompt_tokens\": result.usage.promptTokens,\n                    \"gen_ai.usage.completion_tokens\": result.usage.completionTokens\n                  }\n                })\n              );\n              return result;\n            }\n          })\n        );\n        currentToolCalls = ((_a13 = currentModelResponse.toolCalls) != null ? _a13 : []).map(\n          (modelToolCall) => parseToolCall({ toolCall: modelToolCall, tools })\n        );\n        currentToolResults = tools == null ? [] : await executeTools({\n          toolCalls: currentToolCalls,\n          tools,\n          tracer,\n          telemetry\n        });\n        const currentUsage = calculateCompletionTokenUsage(\n          currentModelResponse.usage\n        );\n        usage.completionTokens += currentUsage.completionTokens;\n        usage.promptTokens += currentUsage.promptTokens;\n        usage.totalTokens += currentUsage.totalTokens;\n        roundtrips.push({\n          text: (_b = currentModelResponse.text) != null ? _b : \"\",\n          toolCalls: currentToolCalls,\n          toolResults: currentToolResults,\n          finishReason: currentModelResponse.finishReason,\n          usage: currentUsage,\n          warnings: currentModelResponse.warnings,\n          logprobs: currentModelResponse.logprobs\n        });\n        const newResponseMessages = toResponseMessages({\n          text: (_c = currentModelResponse.text) != null ? _c : \"\",\n          toolCalls: currentToolCalls,\n          toolResults: currentToolResults\n        });\n        responseMessages.push(...newResponseMessages);\n        promptMessages.push(\n          ...newResponseMessages.map(\n            (message) => convertToLanguageModelMessage(message, null)\n          )\n        );\n      } while (\n        // there are tool calls:\n        currentToolCalls.length > 0 && // all current tool calls have results:\n        currentToolResults.length === currentToolCalls.length && // the number of roundtrips is less than the maximum:\n        roundtripCount++ < maxToolRoundtrips\n      );\n      span.setAttributes(\n        selectTelemetryAttributes({\n          telemetry,\n          attributes: {\n            \"ai.finishReason\": currentModelResponse.finishReason,\n            \"ai.usage.promptTokens\": currentModelResponse.usage.promptTokens,\n            \"ai.usage.completionTokens\": currentModelResponse.usage.completionTokens,\n            \"ai.result.text\": {\n              output: () => currentModelResponse.text\n            },\n            \"ai.result.toolCalls\": {\n              output: () => JSON.stringify(currentModelResponse.toolCalls)\n            }\n          }\n        })\n      );\n      return new DefaultGenerateTextResult({\n        // Always return a string so that the caller doesn't have to check for undefined.\n        // If they need to check if the model did not return any text,\n        // they can check the length of the string:\n        text: (_d = currentModelResponse.text) != null ? _d : \"\",\n        toolCalls: currentToolCalls,\n        toolResults: currentToolResults,\n        finishReason: currentModelResponse.finishReason,\n        usage,\n        warnings: currentModelResponse.warnings,\n        rawResponse: currentModelResponse.rawResponse,\n        logprobs: currentModelResponse.logprobs,\n        responseMessages,\n        roundtrips,\n        providerMetadata: currentModelResponse.providerMetadata\n      });\n    }\n  });\n}\nasync function executeTools({\n  toolCalls,\n  tools,\n  tracer,\n  telemetry\n}) {\n  const toolResults = await Promise.all(\n    toolCalls.map(async (toolCall) => {\n      const tool2 = tools[toolCall.toolName];\n      if ((tool2 == null ? void 0 : tool2.execute) == null) {\n        return void 0;\n      }\n      const result = await recordSpan({\n        name: \"ai.toolCall\",\n        attributes: selectTelemetryAttributes({\n          telemetry,\n          attributes: {\n            ...assembleOperationName({\n              operationName: \"ai.toolCall\",\n              telemetry\n            }),\n            \"ai.toolCall.name\": toolCall.toolName,\n            \"ai.toolCall.id\": toolCall.toolCallId,\n            \"ai.toolCall.args\": {\n              output: () => JSON.stringify(toolCall.args)\n            }\n          }\n        }),\n        tracer,\n        fn: async (span) => {\n          const result2 = await tool2.execute(toolCall.args);\n          try {\n            span.setAttributes(\n              selectTelemetryAttributes({\n                telemetry,\n                attributes: {\n                  \"ai.toolCall.result\": {\n                    output: () => JSON.stringify(result2)\n                  }\n                }\n              })\n            );\n          } catch (ignored) {\n          }\n          return result2;\n        }\n      });\n      return {\n        toolCallId: toolCall.toolCallId,\n        toolName: toolCall.toolName,\n        args: toolCall.args,\n        result\n      };\n    })\n  );\n  return toolResults.filter(\n    (result) => result != null\n  );\n}\nvar DefaultGenerateTextResult = class {\n  constructor(options) {\n    this.text = options.text;\n    this.toolCalls = options.toolCalls;\n    this.toolResults = options.toolResults;\n    this.finishReason = options.finishReason;\n    this.usage = options.usage;\n    this.warnings = options.warnings;\n    this.rawResponse = options.rawResponse;\n    this.logprobs = options.logprobs;\n    this.responseMessages = options.responseMessages;\n    this.roundtrips = options.roundtrips;\n    this.experimental_providerMetadata = options.providerMetadata;\n  }\n};\nfunction toResponseMessages({\n  text,\n  toolCalls,\n  toolResults\n}) {\n  const responseMessages = [];\n  responseMessages.push({\n    role: \"assistant\",\n    content: [{ type: \"text\", text }, ...toolCalls]\n  });\n  if (toolResults.length > 0) {\n    responseMessages.push({\n      role: \"tool\",\n      content: toolResults.map((result) => ({\n        type: \"tool-result\",\n        toolCallId: result.toolCallId,\n        toolName: result.toolName,\n        result: result.result\n      }))\n    });\n  }\n  return responseMessages;\n}\nvar experimental_generateText = generateText;\n\n// core/util/merge-streams.ts\nfunction mergeStreams(stream1, stream2) {\n  const reader1 = stream1.getReader();\n  const reader2 = stream2.getReader();\n  let lastRead1 = void 0;\n  let lastRead2 = void 0;\n  let stream1Done = false;\n  let stream2Done = false;\n  async function readStream1(controller) {\n    try {\n      if (lastRead1 == null) {\n        lastRead1 = reader1.read();\n      }\n      const result = await lastRead1;\n      lastRead1 = void 0;\n      if (!result.done) {\n        controller.enqueue(result.value);\n      } else {\n        controller.close();\n      }\n    } catch (error) {\n      controller.error(error);\n    }\n  }\n  async function readStream2(controller) {\n    try {\n      if (lastRead2 == null) {\n        lastRead2 = reader2.read();\n      }\n      const result = await lastRead2;\n      lastRead2 = void 0;\n      if (!result.done) {\n        controller.enqueue(result.value);\n      } else {\n        controller.close();\n      }\n    } catch (error) {\n      controller.error(error);\n    }\n  }\n  return new ReadableStream({\n    async pull(controller) {\n      try {\n        if (stream1Done) {\n          await readStream2(controller);\n          return;\n        }\n        if (stream2Done) {\n          await readStream1(controller);\n          return;\n        }\n        if (lastRead1 == null) {\n          lastRead1 = reader1.read();\n        }\n        if (lastRead2 == null) {\n          lastRead2 = reader2.read();\n        }\n        const { result, reader } = await Promise.race([\n          lastRead1.then((result2) => ({ result: result2, reader: reader1 })),\n          lastRead2.then((result2) => ({ result: result2, reader: reader2 }))\n        ]);\n        if (!result.done) {\n          controller.enqueue(result.value);\n        }\n        if (reader === reader1) {\n          lastRead1 = void 0;\n          if (result.done) {\n            await readStream2(controller);\n            stream1Done = true;\n          }\n        } else {\n          lastRead2 = void 0;\n          if (result.done) {\n            stream2Done = true;\n            await readStream1(controller);\n          }\n        }\n      } catch (error) {\n        controller.error(error);\n      }\n    },\n    cancel() {\n      reader1.cancel();\n      reader2.cancel();\n    }\n  });\n}\n\n// core/generate-text/run-tools-transformation.ts\n\nfunction runToolsTransformation({\n  tools,\n  generatorStream,\n  toolCallStreaming,\n  tracer,\n  telemetry\n}) {\n  let canClose = false;\n  const outstandingToolCalls = /* @__PURE__ */ new Set();\n  let toolResultsStreamController = null;\n  const toolResultsStream = new ReadableStream({\n    start(controller) {\n      toolResultsStreamController = controller;\n    }\n  });\n  const activeToolCalls = {};\n  const forwardStream = new TransformStream({\n    transform(chunk, controller) {\n      const chunkType = chunk.type;\n      switch (chunkType) {\n        case \"text-delta\":\n        case \"error\": {\n          controller.enqueue(chunk);\n          break;\n        }\n        case \"tool-call-delta\": {\n          if (toolCallStreaming) {\n            if (!activeToolCalls[chunk.toolCallId]) {\n              controller.enqueue({\n                type: \"tool-call-streaming-start\",\n                toolCallId: chunk.toolCallId,\n                toolName: chunk.toolName\n              });\n              activeToolCalls[chunk.toolCallId] = true;\n            }\n            controller.enqueue({\n              type: \"tool-call-delta\",\n              toolCallId: chunk.toolCallId,\n              toolName: chunk.toolName,\n              argsTextDelta: chunk.argsTextDelta\n            });\n          }\n          break;\n        }\n        case \"tool-call\": {\n          const toolName = chunk.toolName;\n          if (tools == null) {\n            toolResultsStreamController.enqueue({\n              type: \"error\",\n              error: new NoSuchToolError({ toolName: chunk.toolName })\n            });\n            break;\n          }\n          const tool2 = tools[toolName];\n          if (tool2 == null) {\n            toolResultsStreamController.enqueue({\n              type: \"error\",\n              error: new NoSuchToolError({\n                toolName: chunk.toolName,\n                availableTools: Object.keys(tools)\n              })\n            });\n            break;\n          }\n          try {\n            const toolCall = parseToolCall({\n              toolCall: chunk,\n              tools\n            });\n            controller.enqueue(toolCall);\n            if (tool2.execute != null) {\n              const toolExecutionId = (0,_ai_sdk_ui_utils__WEBPACK_IMPORTED_MODULE_3__.generateId)();\n              outstandingToolCalls.add(toolExecutionId);\n              recordSpan({\n                name: \"ai.toolCall\",\n                attributes: selectTelemetryAttributes({\n                  telemetry,\n                  attributes: {\n                    ...assembleOperationName({\n                      operationName: \"ai.toolCall\",\n                      telemetry\n                    }),\n                    \"ai.toolCall.name\": toolCall.toolName,\n                    \"ai.toolCall.id\": toolCall.toolCallId,\n                    \"ai.toolCall.args\": {\n                      output: () => JSON.stringify(toolCall.args)\n                    }\n                  }\n                }),\n                tracer,\n                fn: async (span) => tool2.execute(toolCall.args).then(\n                  (result) => {\n                    toolResultsStreamController.enqueue({\n                      ...toolCall,\n                      type: \"tool-result\",\n                      result\n                    });\n                    outstandingToolCalls.delete(toolExecutionId);\n                    if (canClose && outstandingToolCalls.size === 0) {\n                      toolResultsStreamController.close();\n                    }\n                    try {\n                      span.setAttributes(\n                        selectTelemetryAttributes({\n                          telemetry,\n                          attributes: {\n                            \"ai.toolCall.result\": {\n                              output: () => JSON.stringify(result)\n                            }\n                          }\n                        })\n                      );\n                    } catch (ignored) {\n                    }\n                  },\n                  (error) => {\n                    toolResultsStreamController.enqueue({\n                      type: \"error\",\n                      error\n                    });\n                    outstandingToolCalls.delete(toolExecutionId);\n                    if (canClose && outstandingToolCalls.size === 0) {\n                      toolResultsStreamController.close();\n                    }\n                  }\n                )\n              });\n            }\n          } catch (error) {\n            toolResultsStreamController.enqueue({\n              type: \"error\",\n              error\n            });\n          }\n          break;\n        }\n        case \"finish\": {\n          controller.enqueue({\n            type: \"finish\",\n            finishReason: chunk.finishReason,\n            logprobs: chunk.logprobs,\n            usage: calculateCompletionTokenUsage(chunk.usage),\n            experimental_providerMetadata: chunk.providerMetadata\n          });\n          break;\n        }\n        default: {\n          const _exhaustiveCheck = chunkType;\n          throw new Error(`Unhandled chunk type: ${_exhaustiveCheck}`);\n        }\n      }\n    },\n    flush() {\n      canClose = true;\n      if (outstandingToolCalls.size === 0) {\n        toolResultsStreamController.close();\n      }\n    }\n  });\n  return new ReadableStream({\n    async start(controller) {\n      return Promise.all([\n        generatorStream.pipeThrough(forwardStream).pipeTo(\n          new WritableStream({\n            write(chunk) {\n              controller.enqueue(chunk);\n            },\n            close() {\n            }\n          })\n        ),\n        toolResultsStream.pipeTo(\n          new WritableStream({\n            write(chunk) {\n              controller.enqueue(chunk);\n            },\n            close() {\n              controller.close();\n            }\n          })\n        )\n      ]);\n    }\n  });\n}\n\n// core/generate-text/stream-text.ts\nasync function streamText({\n  model,\n  tools,\n  toolChoice,\n  system,\n  prompt,\n  messages,\n  maxRetries,\n  abortSignal,\n  headers,\n  experimental_telemetry: telemetry,\n  experimental_toolCallStreaming: toolCallStreaming = false,\n  onChunk,\n  onFinish,\n  ...settings\n}) {\n  var _a12;\n  const baseTelemetryAttributes = getBaseTelemetryAttributes({\n    model,\n    telemetry,\n    headers,\n    settings: { ...settings, maxRetries }\n  });\n  const tracer = getTracer({ isEnabled: (_a12 = telemetry == null ? void 0 : telemetry.isEnabled) != null ? _a12 : false });\n  return recordSpan({\n    name: \"ai.streamText\",\n    attributes: selectTelemetryAttributes({\n      telemetry,\n      attributes: {\n        ...assembleOperationName({ operationName: \"ai.streamText\", telemetry }),\n        ...baseTelemetryAttributes,\n        // specific settings that only make sense on the outer level:\n        \"ai.prompt\": {\n          input: () => JSON.stringify({ system, prompt, messages })\n        }\n      }\n    }),\n    tracer,\n    endWhenDone: false,\n    fn: async (rootSpan) => {\n      const retry = retryWithExponentialBackoff({ maxRetries });\n      const validatedPrompt = getValidatedPrompt({ system, prompt, messages });\n      const promptMessages = await convertToLanguageModelPrompt({\n        prompt: validatedPrompt,\n        modelSupportsImageUrls: model.supportsImageUrls\n      });\n      const {\n        result: { stream, warnings, rawResponse },\n        doStreamSpan\n      } = await retry(\n        () => recordSpan({\n          name: \"ai.streamText.doStream\",\n          attributes: selectTelemetryAttributes({\n            telemetry,\n            attributes: {\n              ...assembleOperationName({\n                operationName: \"ai.streamText.doStream\",\n                telemetry\n              }),\n              ...baseTelemetryAttributes,\n              \"ai.prompt.format\": {\n                input: () => validatedPrompt.type\n              },\n              \"ai.prompt.messages\": {\n                input: () => JSON.stringify(promptMessages)\n              },\n              // standardized gen-ai llm span attributes:\n              \"gen_ai.request.model\": model.modelId,\n              \"gen_ai.system\": model.provider,\n              \"gen_ai.request.max_tokens\": settings.maxTokens,\n              \"gen_ai.request.temperature\": settings.temperature,\n              \"gen_ai.request.top_p\": settings.topP\n            }\n          }),\n          tracer,\n          endWhenDone: false,\n          fn: async (doStreamSpan2) => {\n            return {\n              result: await model.doStream({\n                mode: {\n                  type: \"regular\",\n                  ...prepareToolsAndToolChoice({ tools, toolChoice })\n                },\n                ...prepareCallSettings(settings),\n                inputFormat: validatedPrompt.type,\n                prompt: promptMessages,\n                abortSignal,\n                headers\n              }),\n              doStreamSpan: doStreamSpan2\n            };\n          }\n        })\n      );\n      return new DefaultStreamTextResult({\n        stream: runToolsTransformation({\n          tools,\n          generatorStream: stream,\n          toolCallStreaming,\n          tracer,\n          telemetry\n        }),\n        warnings,\n        rawResponse,\n        onChunk,\n        onFinish,\n        rootSpan,\n        doStreamSpan,\n        telemetry\n      });\n    }\n  });\n}\nvar DefaultStreamTextResult = class {\n  constructor({\n    stream,\n    warnings,\n    rawResponse,\n    onChunk,\n    onFinish,\n    rootSpan,\n    doStreamSpan,\n    telemetry\n  }) {\n    this.warnings = warnings;\n    this.rawResponse = rawResponse;\n    const { resolve: resolveUsage, promise: usagePromise } = createResolvablePromise();\n    this.usage = usagePromise;\n    const { resolve: resolveFinishReason, promise: finishReasonPromise } = createResolvablePromise();\n    this.finishReason = finishReasonPromise;\n    const { resolve: resolveText, promise: textPromise } = createResolvablePromise();\n    this.text = textPromise;\n    const { resolve: resolveToolCalls, promise: toolCallsPromise } = createResolvablePromise();\n    this.toolCalls = toolCallsPromise;\n    const { resolve: resolveToolResults, promise: toolResultsPromise } = createResolvablePromise();\n    this.toolResults = toolResultsPromise;\n    const {\n      resolve: resolveProviderMetadata,\n      promise: providerMetadataPromise\n    } = createResolvablePromise();\n    this.experimental_providerMetadata = providerMetadataPromise;\n    let finishReason;\n    let usage;\n    let providerMetadata;\n    let text = \"\";\n    const toolCalls = [];\n    const toolResults = [];\n    let firstChunk = true;\n    this.originalStream = stream.pipeThrough(\n      new TransformStream({\n        async transform(chunk, controller) {\n          if (firstChunk) {\n            firstChunk = false;\n            doStreamSpan.addEvent(\"ai.stream.firstChunk\");\n          }\n          if (chunk.type === \"text-delta\" && chunk.textDelta.length === 0) {\n            return;\n          }\n          controller.enqueue(chunk);\n          const chunkType = chunk.type;\n          switch (chunkType) {\n            case \"text-delta\":\n              text += chunk.textDelta;\n              await (onChunk == null ? void 0 : onChunk({ chunk }));\n              break;\n            case \"tool-call\":\n              toolCalls.push(chunk);\n              await (onChunk == null ? void 0 : onChunk({ chunk }));\n              break;\n            case \"tool-result\":\n              toolResults.push(chunk);\n              await (onChunk == null ? void 0 : onChunk({ chunk }));\n              break;\n            case \"finish\":\n              usage = chunk.usage;\n              finishReason = chunk.finishReason;\n              providerMetadata = chunk.experimental_providerMetadata;\n              resolveUsage(usage);\n              resolveFinishReason(finishReason);\n              resolveText(text);\n              resolveToolCalls(toolCalls);\n              resolveProviderMetadata(providerMetadata);\n              break;\n            case \"tool-call-streaming-start\":\n            case \"tool-call-delta\": {\n              await (onChunk == null ? void 0 : onChunk({ chunk }));\n              break;\n            }\n            case \"error\":\n              break;\n            default: {\n              const exhaustiveCheck = chunkType;\n              throw new Error(`Unknown chunk type: ${exhaustiveCheck}`);\n            }\n          }\n        },\n        // invoke onFinish callback and resolve toolResults promise when the stream is about to close:\n        async flush(controller) {\n          try {\n            const finalUsage = usage != null ? usage : {\n              promptTokens: NaN,\n              completionTokens: NaN,\n              totalTokens: NaN\n            };\n            const finalFinishReason = finishReason != null ? finishReason : \"unknown\";\n            const telemetryToolCalls = toolCalls.length > 0 ? JSON.stringify(toolCalls) : void 0;\n            doStreamSpan.setAttributes(\n              selectTelemetryAttributes({\n                telemetry,\n                attributes: {\n                  \"ai.finishReason\": finalFinishReason,\n                  \"ai.usage.promptTokens\": finalUsage.promptTokens,\n                  \"ai.usage.completionTokens\": finalUsage.completionTokens,\n                  \"ai.result.text\": { output: () => text },\n                  \"ai.result.toolCalls\": { output: () => telemetryToolCalls },\n                  // standardized gen-ai llm span attributes:\n                  \"gen_ai.response.finish_reasons\": [finalFinishReason],\n                  \"gen_ai.usage.prompt_tokens\": finalUsage.promptTokens,\n                  \"gen_ai.usage.completion_tokens\": finalUsage.completionTokens\n                }\n              })\n            );\n            doStreamSpan.end();\n            rootSpan.setAttributes(\n              selectTelemetryAttributes({\n                telemetry,\n                attributes: {\n                  \"ai.finishReason\": finalFinishReason,\n                  \"ai.usage.promptTokens\": finalUsage.promptTokens,\n                  \"ai.usage.completionTokens\": finalUsage.completionTokens,\n                  \"ai.result.text\": { output: () => text },\n                  \"ai.result.toolCalls\": { output: () => telemetryToolCalls }\n                }\n              })\n            );\n            resolveToolResults(toolResults);\n            await (onFinish == null ? void 0 : onFinish({\n              finishReason: finalFinishReason,\n              usage: finalUsage,\n              text,\n              toolCalls,\n              // The tool results are inferred as a never[] type, because they are\n              // optional and the execute method with an inferred result type is\n              // optional as well. Therefore we need to cast the toolResults to any.\n              // The type exposed to the users will be correctly inferred.\n              toolResults,\n              rawResponse,\n              warnings,\n              experimental_providerMetadata: providerMetadata\n            }));\n          } catch (error) {\n            controller.error(error);\n          } finally {\n            rootSpan.end();\n          }\n        }\n      })\n    );\n  }\n  /**\n  Split out a new stream from the original stream.\n  The original stream is replaced to allow for further splitting,\n  since we do not know how many times the stream will be split.\n  \n  Note: this leads to buffering the stream content on the server.\n  However, the LLM results are expected to be small enough to not cause issues.\n     */\n  teeStream() {\n    const [stream1, stream2] = this.originalStream.tee();\n    this.originalStream = stream2;\n    return stream1;\n  }\n  get textStream() {\n    return createAsyncIterableStream(this.teeStream(), {\n      transform(chunk, controller) {\n        if (chunk.type === \"text-delta\") {\n          controller.enqueue(chunk.textDelta);\n        } else if (chunk.type === \"error\") {\n          controller.error(chunk.error);\n        }\n      }\n    });\n  }\n  get fullStream() {\n    return createAsyncIterableStream(this.teeStream(), {\n      transform(chunk, controller) {\n        controller.enqueue(chunk);\n      }\n    });\n  }\n  toAIStream(callbacks = {}) {\n    return this.toDataStream({ callbacks });\n  }\n  toDataStream({\n    callbacks = {},\n    getErrorMessage: getErrorMessage4 = () => \"\"\n    // mask error messages for safety by default\n  } = {}) {\n    let aggregatedResponse = \"\";\n    const callbackTransformer = new TransformStream({\n      async start() {\n        if (callbacks.onStart)\n          await callbacks.onStart();\n      },\n      async transform(chunk, controller) {\n        controller.enqueue(chunk);\n        if (chunk.type === \"text-delta\") {\n          const textDelta = chunk.textDelta;\n          aggregatedResponse += textDelta;\n          if (callbacks.onToken)\n            await callbacks.onToken(textDelta);\n          if (callbacks.onText)\n            await callbacks.onText(textDelta);\n        }\n      },\n      async flush() {\n        if (callbacks.onCompletion)\n          await callbacks.onCompletion(aggregatedResponse);\n        if (callbacks.onFinal)\n          await callbacks.onFinal(aggregatedResponse);\n      }\n    });\n    const streamPartsTransformer = new TransformStream({\n      transform: async (chunk, controller) => {\n        const chunkType = chunk.type;\n        switch (chunkType) {\n          case \"text-delta\":\n            controller.enqueue((0,_ai_sdk_ui_utils__WEBPACK_IMPORTED_MODULE_3__.formatStreamPart)(\"text\", chunk.textDelta));\n            break;\n          case \"tool-call-streaming-start\":\n            controller.enqueue(\n              (0,_ai_sdk_ui_utils__WEBPACK_IMPORTED_MODULE_3__.formatStreamPart)(\"tool_call_streaming_start\", {\n                toolCallId: chunk.toolCallId,\n                toolName: chunk.toolName\n              })\n            );\n            break;\n          case \"tool-call-delta\":\n            controller.enqueue(\n              (0,_ai_sdk_ui_utils__WEBPACK_IMPORTED_MODULE_3__.formatStreamPart)(\"tool_call_delta\", {\n                toolCallId: chunk.toolCallId,\n                argsTextDelta: chunk.argsTextDelta\n              })\n            );\n            break;\n          case \"tool-call\":\n            controller.enqueue(\n              (0,_ai_sdk_ui_utils__WEBPACK_IMPORTED_MODULE_3__.formatStreamPart)(\"tool_call\", {\n                toolCallId: chunk.toolCallId,\n                toolName: chunk.toolName,\n                args: chunk.args\n              })\n            );\n            break;\n          case \"tool-result\":\n            controller.enqueue(\n              (0,_ai_sdk_ui_utils__WEBPACK_IMPORTED_MODULE_3__.formatStreamPart)(\"tool_result\", {\n                toolCallId: chunk.toolCallId,\n                result: chunk.result\n              })\n            );\n            break;\n          case \"error\":\n            controller.enqueue(\n              (0,_ai_sdk_ui_utils__WEBPACK_IMPORTED_MODULE_3__.formatStreamPart)(\"error\", getErrorMessage4(chunk.error))\n            );\n            break;\n          case \"finish\":\n            controller.enqueue(\n              (0,_ai_sdk_ui_utils__WEBPACK_IMPORTED_MODULE_3__.formatStreamPart)(\"finish_message\", {\n                finishReason: chunk.finishReason,\n                usage: {\n                  promptTokens: chunk.usage.promptTokens,\n                  completionTokens: chunk.usage.completionTokens\n                }\n              })\n            );\n            break;\n          default: {\n            const exhaustiveCheck = chunkType;\n            throw new Error(`Unknown chunk type: ${exhaustiveCheck}`);\n          }\n        }\n      }\n    });\n    return this.fullStream.pipeThrough(callbackTransformer).pipeThrough(streamPartsTransformer).pipeThrough(new TextEncoderStream());\n  }\n  pipeAIStreamToResponse(response, init) {\n    return this.pipeDataStreamToResponse(response, init);\n  }\n  pipeDataStreamToResponse(response, init) {\n    var _a12;\n    response.writeHead((_a12 = init == null ? void 0 : init.status) != null ? _a12 : 200, {\n      \"Content-Type\": \"text/plain; charset=utf-8\",\n      ...init == null ? void 0 : init.headers\n    });\n    const reader = this.toDataStream().getReader();\n    const read = async () => {\n      try {\n        while (true) {\n          const { done, value } = await reader.read();\n          if (done)\n            break;\n          response.write(value);\n        }\n      } catch (error) {\n        throw error;\n      } finally {\n        response.end();\n      }\n    };\n    read();\n  }\n  pipeTextStreamToResponse(response, init) {\n    var _a12;\n    response.writeHead((_a12 = init == null ? void 0 : init.status) != null ? _a12 : 200, {\n      \"Content-Type\": \"text/plain; charset=utf-8\",\n      ...init == null ? void 0 : init.headers\n    });\n    const reader = this.textStream.pipeThrough(new TextEncoderStream()).getReader();\n    const read = async () => {\n      try {\n        while (true) {\n          const { done, value } = await reader.read();\n          if (done)\n            break;\n          response.write(value);\n        }\n      } catch (error) {\n        throw error;\n      } finally {\n        response.end();\n      }\n    };\n    read();\n  }\n  toAIStreamResponse(options) {\n    return this.toDataStreamResponse(options);\n  }\n  toDataStreamResponse(options) {\n    var _a12;\n    const init = options == null ? void 0 : \"init\" in options ? options.init : {\n      headers: \"headers\" in options ? options.headers : void 0,\n      status: \"status\" in options ? options.status : void 0,\n      statusText: \"statusText\" in options ? options.statusText : void 0\n    };\n    const data = options == null ? void 0 : \"data\" in options ? options.data : void 0;\n    const getErrorMessage4 = options == null ? void 0 : \"getErrorMessage\" in options ? options.getErrorMessage : void 0;\n    const stream = data ? mergeStreams(data.stream, this.toDataStream({ getErrorMessage: getErrorMessage4 })) : this.toDataStream({ getErrorMessage: getErrorMessage4 });\n    return new Response(stream, {\n      status: (_a12 = init == null ? void 0 : init.status) != null ? _a12 : 200,\n      statusText: init == null ? void 0 : init.statusText,\n      headers: prepareResponseHeaders(init, {\n        contentType: \"text/plain; charset=utf-8\",\n        dataStreamVersion: \"v1\"\n      })\n    });\n  }\n  toTextStreamResponse(init) {\n    var _a12;\n    return new Response(this.textStream.pipeThrough(new TextEncoderStream()), {\n      status: (_a12 = init == null ? void 0 : init.status) != null ? _a12 : 200,\n      headers: prepareResponseHeaders(init, {\n        contentType: \"text/plain; charset=utf-8\"\n      })\n    });\n  }\n};\nvar experimental_streamText = streamText;\n\n// core/prompt/attachments-to-parts.ts\nfunction attachmentsToParts(attachments) {\n  var _a12, _b, _c;\n  const parts = [];\n  for (const attachment of attachments) {\n    let url;\n    try {\n      url = new URL(attachment.url);\n    } catch (error) {\n      throw new Error(`Invalid URL: ${attachment.url}`);\n    }\n    switch (url.protocol) {\n      case \"http:\":\n      case \"https:\": {\n        if ((_a12 = attachment.contentType) == null ? void 0 : _a12.startsWith(\"image/\")) {\n          parts.push({ type: \"image\", image: url });\n        }\n        break;\n      }\n      case \"data:\": {\n        let header;\n        let base64Content;\n        let mimeType;\n        try {\n          [header, base64Content] = attachment.url.split(\",\");\n          mimeType = header.split(\";\")[0].split(\":\")[1];\n        } catch (error) {\n          throw new Error(`Error processing data URL: ${attachment.url}`);\n        }\n        if (mimeType == null || base64Content == null) {\n          throw new Error(`Invalid data URL format: ${attachment.url}`);\n        }\n        if ((_b = attachment.contentType) == null ? void 0 : _b.startsWith(\"image/\")) {\n          parts.push({\n            type: \"image\",\n            image: convertDataContentToUint8Array(base64Content)\n          });\n        } else if ((_c = attachment.contentType) == null ? void 0 : _c.startsWith(\"text/\")) {\n          parts.push({\n            type: \"text\",\n            text: convertUint8ArrayToText(\n              convertDataContentToUint8Array(base64Content)\n            )\n          });\n        }\n        break;\n      }\n      default: {\n        throw new Error(`Unsupported URL protocol: ${url.protocol}`);\n      }\n    }\n  }\n  return parts;\n}\n\n// core/prompt/convert-to-core-messages.ts\nfunction convertToCoreMessages(messages) {\n  const coreMessages = [];\n  for (const {\n    role,\n    content,\n    toolInvocations,\n    experimental_attachments\n  } of messages) {\n    switch (role) {\n      case \"system\": {\n        coreMessages.push({\n          role: \"system\",\n          content\n        });\n        break;\n      }\n      case \"user\": {\n        coreMessages.push({\n          role: \"user\",\n          content: experimental_attachments ? [\n            { type: \"text\", text: content },\n            ...attachmentsToParts(experimental_attachments)\n          ] : content\n        });\n        break;\n      }\n      case \"assistant\": {\n        if (toolInvocations == null) {\n          coreMessages.push({ role: \"assistant\", content });\n          break;\n        }\n        coreMessages.push({\n          role: \"assistant\",\n          content: [\n            { type: \"text\", text: content },\n            ...toolInvocations.map(({ toolCallId, toolName, args }) => ({\n              type: \"tool-call\",\n              toolCallId,\n              toolName,\n              args\n            }))\n          ]\n        });\n        coreMessages.push({\n          role: \"tool\",\n          content: toolInvocations.map(\n            ({ toolCallId, toolName, args, result }) => ({\n              type: \"tool-result\",\n              toolCallId,\n              toolName,\n              args,\n              result\n            })\n          )\n        });\n        break;\n      }\n      default: {\n        const _exhaustiveCheck = role;\n        throw new Error(`Unhandled role: ${_exhaustiveCheck}`);\n      }\n    }\n  }\n  return coreMessages;\n}\n\n// core/registry/invalid-model-id-error.ts\n\nvar name9 = \"AI_InvalidModelIdError\";\nvar marker9 = `vercel.ai.error.${name9}`;\nvar symbol9 = Symbol.for(marker9);\nvar _a9;\nvar InvalidModelIdError = class extends _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.AISDKError {\n  constructor({\n    id,\n    message = `Invalid model id: ${id}`\n  }) {\n    super({ name: name9, message });\n    this[_a9] = true;\n    this.id = id;\n  }\n  static isInstance(error) {\n    return _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.AISDKError.hasMarker(error, marker9);\n  }\n  /**\n   * @deprecated use `isInstance` instead\n   */\n  static isInvalidModelIdError(error) {\n    return error instanceof Error && error.name === name9 && typeof error.id === \"string\";\n  }\n  /**\n   * @deprecated Do not use this method. It will be removed in the next major version.\n   */\n  toJSON() {\n    return {\n      name: this.name,\n      message: this.message,\n      stack: this.stack,\n      id: this.id\n    };\n  }\n};\n_a9 = symbol9;\n\n// core/registry/no-such-model-error.ts\n\nvar name10 = \"AI_NoSuchModelError\";\nvar marker10 = `vercel.ai.error.${name10}`;\nvar symbol10 = Symbol.for(marker10);\nvar _a10;\nvar NoSuchModelError = class extends _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.AISDKError {\n  constructor({\n    modelId,\n    modelType,\n    message = `No such ${modelType}: ${modelId}`\n  }) {\n    super({ name: name10, message });\n    this[_a10] = true;\n    this.modelId = modelId;\n    this.modelType = modelType;\n  }\n  static isInstance(error) {\n    return _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.AISDKError.hasMarker(error, marker10);\n  }\n  /**\n   * @deprecated use `isInstance` instead\n   */\n  static isNoSuchModelError(error) {\n    return error instanceof Error && error.name === name10 && typeof error.modelId === \"string\" && typeof error.modelType === \"string\";\n  }\n  /**\n   * @deprecated Do not use this method. It will be removed in the next major version.\n   */\n  toJSON() {\n    return {\n      name: this.name,\n      message: this.message,\n      stack: this.stack,\n      modelId: this.modelId,\n      modelType: this.modelType\n    };\n  }\n};\n_a10 = symbol10;\n\n// core/registry/no-such-provider-error.ts\n\nvar name11 = \"AI_NoSuchProviderError\";\nvar marker11 = `vercel.ai.error.${name11}`;\nvar symbol11 = Symbol.for(marker11);\nvar _a11;\nvar NoSuchProviderError = class extends _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.AISDKError {\n  constructor({\n    providerId,\n    availableProviders,\n    message = `No such provider: ${providerId} (available providers: ${availableProviders.join()})`\n  }) {\n    super({ name: name11, message });\n    this[_a11] = true;\n    this.providerId = providerId;\n    this.availableProviders = availableProviders;\n  }\n  static isInstance(error) {\n    return _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.AISDKError.hasMarker(error, marker11);\n  }\n  /**\n   * @deprecated use `isInstance` instead\n   */\n  static isNoSuchProviderError(error) {\n    return error instanceof Error && error.name === name11 && typeof error.providerId === \"string\" && Array.isArray(error.availableProviders);\n  }\n  /**\n   * @deprecated Do not use this method. It will be removed in the next major version.\n   */\n  toJSON() {\n    return {\n      name: this.name,\n      message: this.message,\n      stack: this.stack,\n      providerId: this.providerId,\n      availableProviders: this.availableProviders\n    };\n  }\n};\n_a11 = symbol11;\n\n// core/registry/provider-registry.ts\nfunction experimental_createProviderRegistry(providers) {\n  const registry = new DefaultProviderRegistry();\n  for (const [id, provider] of Object.entries(providers)) {\n    registry.registerProvider({ id, provider });\n  }\n  return registry;\n}\nvar experimental_createModelRegistry = experimental_createProviderRegistry;\nvar DefaultProviderRegistry = class {\n  constructor() {\n    this.providers = {};\n  }\n  registerProvider({\n    id,\n    provider\n  }) {\n    this.providers[id] = provider;\n  }\n  getProvider(id) {\n    const provider = this.providers[id];\n    if (provider == null) {\n      throw new NoSuchProviderError({\n        providerId: id,\n        availableProviders: Object.keys(this.providers)\n      });\n    }\n    return provider;\n  }\n  splitId(id) {\n    const index = id.indexOf(\":\");\n    if (index === -1) {\n      throw new InvalidModelIdError({ id });\n    }\n    return [id.slice(0, index), id.slice(index + 1)];\n  }\n  languageModel(id) {\n    var _a12, _b;\n    const [providerId, modelId] = this.splitId(id);\n    const model = (_b = (_a12 = this.getProvider(providerId)).languageModel) == null ? void 0 : _b.call(_a12, modelId);\n    if (model == null) {\n      throw new NoSuchModelError({ modelId: id, modelType: \"languageModel\" });\n    }\n    return model;\n  }\n  textEmbeddingModel(id) {\n    var _a12, _b, _c;\n    const [providerId, modelId] = this.splitId(id);\n    const provider = this.getProvider(providerId);\n    const model = (_c = (_a12 = provider.textEmbeddingModel) == null ? void 0 : _a12.call(provider, modelId)) != null ? _c : (_b = provider.textEmbedding) == null ? void 0 : _b.call(provider, modelId);\n    if (model == null) {\n      throw new NoSuchModelError({\n        modelId: id,\n        modelType: \"textEmbeddingModel\"\n      });\n    }\n    return model;\n  }\n  /**\n   * @deprecated Use `textEmbeddingModel` instead.\n   */\n  textEmbedding(id) {\n    return this.textEmbeddingModel(id);\n  }\n};\n\n// core/tool/tool.ts\nfunction tool(tool2) {\n  return tool2;\n}\n\n// core/util/cosine-similarity.ts\nfunction cosineSimilarity(vector1, vector2) {\n  if (vector1.length !== vector2.length) {\n    throw new Error(\n      `Vectors must have the same length (vector1: ${vector1.length} elements, vector2: ${vector2.length} elements)`\n    );\n  }\n  return dotProduct(vector1, vector2) / (magnitude(vector1) * magnitude(vector2));\n}\nfunction dotProduct(vector1, vector2) {\n  return vector1.reduce(\n    (accumulator, value, index) => accumulator + value * vector2[index],\n    0\n  );\n}\nfunction magnitude(vector) {\n  return Math.sqrt(dotProduct(vector, vector));\n}\n\n// errors/index.ts\n\n\n// streams/ai-stream.ts\n\nfunction createEventStreamTransformer(customParser) {\n  const textDecoder = new TextDecoder();\n  let eventSourceParser;\n  return new TransformStream({\n    async start(controller) {\n      eventSourceParser = (0,eventsource_parser__WEBPACK_IMPORTED_MODULE_4__.createParser)(\n        (event) => {\n          if (\"data\" in event && event.type === \"event\" && event.data === \"[DONE]\" || // Replicate doesn't send [DONE] but does send a 'done' event\n          // @see https://replicate.com/docs/streaming\n          event.event === \"done\") {\n            controller.terminate();\n            return;\n          }\n          if (\"data\" in event) {\n            const parsedMessage = customParser ? customParser(event.data, {\n              event: event.event\n            }) : event.data;\n            if (parsedMessage)\n              controller.enqueue(parsedMessage);\n          }\n        }\n      );\n    },\n    transform(chunk) {\n      eventSourceParser.feed(textDecoder.decode(chunk));\n    }\n  });\n}\nfunction createCallbacksTransformer(cb) {\n  const textEncoder = new TextEncoder();\n  let aggregatedResponse = \"\";\n  const callbacks = cb || {};\n  return new TransformStream({\n    async start() {\n      if (callbacks.onStart)\n        await callbacks.onStart();\n    },\n    async transform(message, controller) {\n      const content = typeof message === \"string\" ? message : message.content;\n      controller.enqueue(textEncoder.encode(content));\n      aggregatedResponse += content;\n      if (callbacks.onToken)\n        await callbacks.onToken(content);\n      if (callbacks.onText && typeof message === \"string\") {\n        await callbacks.onText(message);\n      }\n    },\n    async flush() {\n      const isOpenAICallbacks = isOfTypeOpenAIStreamCallbacks(callbacks);\n      if (callbacks.onCompletion) {\n        await callbacks.onCompletion(aggregatedResponse);\n      }\n      if (callbacks.onFinal && !isOpenAICallbacks) {\n        await callbacks.onFinal(aggregatedResponse);\n      }\n    }\n  });\n}\nfunction isOfTypeOpenAIStreamCallbacks(callbacks) {\n  return \"experimental_onFunctionCall\" in callbacks;\n}\nfunction trimStartOfStreamHelper() {\n  let isStreamStart = true;\n  return (text) => {\n    if (isStreamStart) {\n      text = text.trimStart();\n      if (text)\n        isStreamStart = false;\n    }\n    return text;\n  };\n}\nfunction AIStream(response, customParser, callbacks) {\n  if (!response.ok) {\n    if (response.body) {\n      const reader = response.body.getReader();\n      return new ReadableStream({\n        async start(controller) {\n          const { done, value } = await reader.read();\n          if (!done) {\n            const errorText = new TextDecoder().decode(value);\n            controller.error(new Error(`Response error: ${errorText}`));\n          }\n        }\n      });\n    } else {\n      return new ReadableStream({\n        start(controller) {\n          controller.error(new Error(\"Response error: No response body\"));\n        }\n      });\n    }\n  }\n  const responseBodyStream = response.body || createEmptyReadableStream();\n  return responseBodyStream.pipeThrough(createEventStreamTransformer(customParser)).pipeThrough(createCallbacksTransformer(callbacks));\n}\nfunction createEmptyReadableStream() {\n  return new ReadableStream({\n    start(controller) {\n      controller.close();\n    }\n  });\n}\nfunction readableFromAsyncIterable(iterable) {\n  let it = iterable[Symbol.asyncIterator]();\n  return new ReadableStream({\n    async pull(controller) {\n      const { done, value } = await it.next();\n      if (done)\n        controller.close();\n      else\n        controller.enqueue(value);\n    },\n    async cancel(reason) {\n      var _a12;\n      await ((_a12 = it.return) == null ? void 0 : _a12.call(it, reason));\n    }\n  });\n}\n\n// streams/stream-data.ts\n\n\n// util/constants.ts\nvar HANGING_STREAM_WARNING_TIME_MS = 15 * 1e3;\n\n// streams/stream-data.ts\nvar StreamData2 = class {\n  constructor() {\n    this.encoder = new TextEncoder();\n    this.controller = null;\n    this.isClosed = false;\n    this.warningTimeout = null;\n    const self = this;\n    this.stream = new ReadableStream({\n      start: async (controller) => {\n        self.controller = controller;\n        if (true) {\n          self.warningTimeout = setTimeout(() => {\n            console.warn(\n              \"The data stream is hanging. Did you forget to close it with `data.close()`?\"\n            );\n          }, HANGING_STREAM_WARNING_TIME_MS);\n        }\n      },\n      pull: (controller) => {\n      },\n      cancel: (reason) => {\n        this.isClosed = true;\n      }\n    });\n  }\n  async close() {\n    if (this.isClosed) {\n      throw new Error(\"Data Stream has already been closed.\");\n    }\n    if (!this.controller) {\n      throw new Error(\"Stream controller is not initialized.\");\n    }\n    this.controller.close();\n    this.isClosed = true;\n    if (this.warningTimeout) {\n      clearTimeout(this.warningTimeout);\n    }\n  }\n  append(value) {\n    if (this.isClosed) {\n      throw new Error(\"Data Stream has already been closed.\");\n    }\n    if (!this.controller) {\n      throw new Error(\"Stream controller is not initialized.\");\n    }\n    this.controller.enqueue(\n      this.encoder.encode((0,_ai_sdk_ui_utils__WEBPACK_IMPORTED_MODULE_3__.formatStreamPart)(\"data\", [value]))\n    );\n  }\n  appendMessageAnnotation(value) {\n    if (this.isClosed) {\n      throw new Error(\"Data Stream has already been closed.\");\n    }\n    if (!this.controller) {\n      throw new Error(\"Stream controller is not initialized.\");\n    }\n    this.controller.enqueue(\n      this.encoder.encode((0,_ai_sdk_ui_utils__WEBPACK_IMPORTED_MODULE_3__.formatStreamPart)(\"message_annotations\", [value]))\n    );\n  }\n};\nfunction createStreamDataTransformer() {\n  const encoder = new TextEncoder();\n  const decoder = new TextDecoder();\n  return new TransformStream({\n    transform: async (chunk, controller) => {\n      const message = decoder.decode(chunk);\n      controller.enqueue(encoder.encode((0,_ai_sdk_ui_utils__WEBPACK_IMPORTED_MODULE_3__.formatStreamPart)(\"text\", message)));\n    }\n  });\n}\nvar experimental_StreamData = class extends StreamData2 {\n};\n\n// streams/anthropic-stream.ts\nfunction parseAnthropicStream() {\n  let previous = \"\";\n  return (data) => {\n    const json = JSON.parse(data);\n    if (\"error\" in json) {\n      throw new Error(`${json.error.type}: ${json.error.message}`);\n    }\n    if (!(\"completion\" in json)) {\n      return;\n    }\n    const text = json.completion;\n    if (!previous || text.length > previous.length && text.startsWith(previous)) {\n      const delta = text.slice(previous.length);\n      previous = text;\n      return delta;\n    }\n    return text;\n  };\n}\nasync function* streamable(stream) {\n  for await (const chunk of stream) {\n    if (\"completion\" in chunk) {\n      const text = chunk.completion;\n      if (text)\n        yield text;\n    } else if (\"delta\" in chunk) {\n      const { delta } = chunk;\n      if (\"text\" in delta) {\n        const text = delta.text;\n        if (text)\n          yield text;\n      }\n    }\n  }\n}\nfunction AnthropicStream(res, cb) {\n  if (Symbol.asyncIterator in res) {\n    return readableFromAsyncIterable(streamable(res)).pipeThrough(createCallbacksTransformer(cb)).pipeThrough(createStreamDataTransformer());\n  } else {\n    return AIStream(res, parseAnthropicStream(), cb).pipeThrough(\n      createStreamDataTransformer()\n    );\n  }\n}\n\n// streams/assistant-response.ts\n\nfunction AssistantResponse({ threadId, messageId }, process2) {\n  const stream = new ReadableStream({\n    async start(controller) {\n      var _a12;\n      const textEncoder = new TextEncoder();\n      const sendMessage = (message) => {\n        controller.enqueue(\n          textEncoder.encode((0,_ai_sdk_ui_utils__WEBPACK_IMPORTED_MODULE_3__.formatStreamPart)(\"assistant_message\", message))\n        );\n      };\n      const sendDataMessage = (message) => {\n        controller.enqueue(\n          textEncoder.encode((0,_ai_sdk_ui_utils__WEBPACK_IMPORTED_MODULE_3__.formatStreamPart)(\"data_message\", message))\n        );\n      };\n      const sendError = (errorMessage) => {\n        controller.enqueue(\n          textEncoder.encode((0,_ai_sdk_ui_utils__WEBPACK_IMPORTED_MODULE_3__.formatStreamPart)(\"error\", errorMessage))\n        );\n      };\n      const forwardStream = async (stream2) => {\n        var _a13, _b;\n        let result = void 0;\n        for await (const value of stream2) {\n          switch (value.event) {\n            case \"thread.message.created\": {\n              controller.enqueue(\n                textEncoder.encode(\n                  (0,_ai_sdk_ui_utils__WEBPACK_IMPORTED_MODULE_3__.formatStreamPart)(\"assistant_message\", {\n                    id: value.data.id,\n                    role: \"assistant\",\n                    content: [{ type: \"text\", text: { value: \"\" } }]\n                  })\n                )\n              );\n              break;\n            }\n            case \"thread.message.delta\": {\n              const content = (_a13 = value.data.delta.content) == null ? void 0 : _a13[0];\n              if ((content == null ? void 0 : content.type) === \"text\" && ((_b = content.text) == null ? void 0 : _b.value) != null) {\n                controller.enqueue(\n                  textEncoder.encode(\n                    (0,_ai_sdk_ui_utils__WEBPACK_IMPORTED_MODULE_3__.formatStreamPart)(\"text\", content.text.value)\n                  )\n                );\n              }\n              break;\n            }\n            case \"thread.run.completed\":\n            case \"thread.run.requires_action\": {\n              result = value.data;\n              break;\n            }\n          }\n        }\n        return result;\n      };\n      controller.enqueue(\n        textEncoder.encode(\n          (0,_ai_sdk_ui_utils__WEBPACK_IMPORTED_MODULE_3__.formatStreamPart)(\"assistant_control_data\", {\n            threadId,\n            messageId\n          })\n        )\n      );\n      try {\n        await process2({\n          threadId,\n          messageId,\n          sendMessage,\n          sendDataMessage,\n          forwardStream\n        });\n      } catch (error) {\n        sendError((_a12 = error.message) != null ? _a12 : `${error}`);\n      } finally {\n        controller.close();\n      }\n    },\n    pull(controller) {\n    },\n    cancel() {\n    }\n  });\n  return new Response(stream, {\n    status: 200,\n    headers: {\n      \"Content-Type\": \"text/plain; charset=utf-8\"\n    }\n  });\n}\nvar experimental_AssistantResponse = AssistantResponse;\n\n// streams/aws-bedrock-stream.ts\nasync function* asDeltaIterable(response, extractTextDeltaFromChunk) {\n  var _a12, _b;\n  const decoder = new TextDecoder();\n  for await (const chunk of (_a12 = response.body) != null ? _a12 : []) {\n    const bytes = (_b = chunk.chunk) == null ? void 0 : _b.bytes;\n    if (bytes != null) {\n      const chunkText = decoder.decode(bytes);\n      const chunkJSON = JSON.parse(chunkText);\n      const delta = extractTextDeltaFromChunk(chunkJSON);\n      if (delta != null) {\n        yield delta;\n      }\n    }\n  }\n}\nfunction AWSBedrockAnthropicMessagesStream(response, callbacks) {\n  return AWSBedrockStream(response, callbacks, (chunk) => {\n    var _a12;\n    return (_a12 = chunk.delta) == null ? void 0 : _a12.text;\n  });\n}\nfunction AWSBedrockAnthropicStream(response, callbacks) {\n  return AWSBedrockStream(response, callbacks, (chunk) => chunk.completion);\n}\nfunction AWSBedrockCohereStream(response, callbacks) {\n  return AWSBedrockStream(response, callbacks, (chunk) => chunk == null ? void 0 : chunk.text);\n}\nfunction AWSBedrockLlama2Stream(response, callbacks) {\n  return AWSBedrockStream(response, callbacks, (chunk) => chunk.generation);\n}\nfunction AWSBedrockStream(response, callbacks, extractTextDeltaFromChunk) {\n  return readableFromAsyncIterable(\n    asDeltaIterable(response, extractTextDeltaFromChunk)\n  ).pipeThrough(createCallbacksTransformer(callbacks)).pipeThrough(createStreamDataTransformer());\n}\n\n// streams/cohere-stream.ts\nvar utf8Decoder = new TextDecoder(\"utf-8\");\nasync function processLines(lines, controller) {\n  for (const line of lines) {\n    const { text, is_finished } = JSON.parse(line);\n    if (!is_finished) {\n      controller.enqueue(text);\n    }\n  }\n}\nasync function readAndProcessLines(reader, controller) {\n  let segment = \"\";\n  while (true) {\n    const { value: chunk, done } = await reader.read();\n    if (done) {\n      break;\n    }\n    segment += utf8Decoder.decode(chunk, { stream: true });\n    const linesArray = segment.split(/\\r\\n|\\n|\\r/g);\n    segment = linesArray.pop() || \"\";\n    await processLines(linesArray, controller);\n  }\n  if (segment) {\n    const linesArray = [segment];\n    await processLines(linesArray, controller);\n  }\n  controller.close();\n}\nfunction createParser2(res) {\n  var _a12;\n  const reader = (_a12 = res.body) == null ? void 0 : _a12.getReader();\n  return new ReadableStream({\n    async start(controller) {\n      if (!reader) {\n        controller.close();\n        return;\n      }\n      await readAndProcessLines(reader, controller);\n    }\n  });\n}\nasync function* streamable2(stream) {\n  for await (const chunk of stream) {\n    if (chunk.eventType === \"text-generation\") {\n      const text = chunk.text;\n      if (text)\n        yield text;\n    }\n  }\n}\nfunction CohereStream(reader, callbacks) {\n  if (Symbol.asyncIterator in reader) {\n    return readableFromAsyncIterable(streamable2(reader)).pipeThrough(createCallbacksTransformer(callbacks)).pipeThrough(createStreamDataTransformer());\n  } else {\n    return createParser2(reader).pipeThrough(createCallbacksTransformer(callbacks)).pipeThrough(createStreamDataTransformer());\n  }\n}\n\n// streams/google-generative-ai-stream.ts\nasync function* streamable3(response) {\n  var _a12, _b, _c;\n  for await (const chunk of response.stream) {\n    const parts = (_c = (_b = (_a12 = chunk.candidates) == null ? void 0 : _a12[0]) == null ? void 0 : _b.content) == null ? void 0 : _c.parts;\n    if (parts === void 0) {\n      continue;\n    }\n    const firstPart = parts[0];\n    if (typeof firstPart.text === \"string\") {\n      yield firstPart.text;\n    }\n  }\n}\nfunction GoogleGenerativeAIStream(response, cb) {\n  return readableFromAsyncIterable(streamable3(response)).pipeThrough(createCallbacksTransformer(cb)).pipeThrough(createStreamDataTransformer());\n}\n\n// streams/huggingface-stream.ts\nfunction createParser3(res) {\n  const trimStartOfStream = trimStartOfStreamHelper();\n  return new ReadableStream({\n    async pull(controller) {\n      var _a12, _b;\n      const { value, done } = await res.next();\n      if (done) {\n        controller.close();\n        return;\n      }\n      const text = trimStartOfStream((_b = (_a12 = value.token) == null ? void 0 : _a12.text) != null ? _b : \"\");\n      if (!text)\n        return;\n      if (value.generated_text != null && value.generated_text.length > 0) {\n        return;\n      }\n      if (text === \"</s>\" || text === \"<|endoftext|>\" || text === \"<|end|>\") {\n        return;\n      }\n      controller.enqueue(text);\n    }\n  });\n}\nfunction HuggingFaceStream(res, callbacks) {\n  return createParser3(res).pipeThrough(createCallbacksTransformer(callbacks)).pipeThrough(createStreamDataTransformer());\n}\n\n// streams/inkeep-stream.ts\nfunction InkeepStream(res, callbacks) {\n  if (!res.body) {\n    throw new Error(\"Response body is null\");\n  }\n  let chat_session_id = \"\";\n  let records_cited;\n  const inkeepEventParser = (data, options) => {\n    var _a12, _b;\n    const { event } = options;\n    if (event === \"records_cited\") {\n      records_cited = JSON.parse(data);\n      (_a12 = callbacks == null ? void 0 : callbacks.onRecordsCited) == null ? void 0 : _a12.call(callbacks, records_cited);\n    }\n    if (event === \"message_chunk\") {\n      const inkeepMessageChunk = JSON.parse(data);\n      chat_session_id = (_b = inkeepMessageChunk.chat_session_id) != null ? _b : chat_session_id;\n      return inkeepMessageChunk.content_chunk;\n    }\n    return;\n  };\n  let { onRecordsCited, ...passThroughCallbacks } = callbacks || {};\n  passThroughCallbacks = {\n    ...passThroughCallbacks,\n    onFinal: (completion) => {\n      var _a12;\n      const inkeepOnFinalMetadata = {\n        chat_session_id,\n        records_cited\n      };\n      (_a12 = callbacks == null ? void 0 : callbacks.onFinal) == null ? void 0 : _a12.call(callbacks, completion, inkeepOnFinalMetadata);\n    }\n  };\n  return AIStream(res, inkeepEventParser, passThroughCallbacks).pipeThrough(\n    createStreamDataTransformer()\n  );\n}\n\n// streams/langchain-adapter.ts\nvar langchain_adapter_exports = {};\n__export(langchain_adapter_exports, {\n  toAIStream: () => toAIStream,\n  toDataStream: () => toDataStream,\n  toDataStreamResponse: () => toDataStreamResponse\n});\nfunction toAIStream(stream, callbacks) {\n  return toDataStream(stream, callbacks);\n}\nfunction toDataStream(stream, callbacks) {\n  return stream.pipeThrough(\n    new TransformStream({\n      transform: async (value, controller) => {\n        var _a12;\n        if (typeof value === \"string\") {\n          controller.enqueue(value);\n          return;\n        }\n        if (\"event\" in value) {\n          if (value.event === \"on_chat_model_stream\") {\n            forwardAIMessageChunk(\n              (_a12 = value.data) == null ? void 0 : _a12.chunk,\n              controller\n            );\n          }\n          return;\n        }\n        forwardAIMessageChunk(value, controller);\n      }\n    })\n  ).pipeThrough(createCallbacksTransformer(callbacks)).pipeThrough(createStreamDataTransformer());\n}\nfunction toDataStreamResponse(stream, options) {\n  var _a12;\n  const dataStream = toDataStream(stream, options == null ? void 0 : options.callbacks);\n  const data = options == null ? void 0 : options.data;\n  const init = options == null ? void 0 : options.init;\n  const responseStream = data ? mergeStreams(data.stream, dataStream) : dataStream;\n  return new Response(responseStream, {\n    status: (_a12 = init == null ? void 0 : init.status) != null ? _a12 : 200,\n    statusText: init == null ? void 0 : init.statusText,\n    headers: prepareResponseHeaders(init, {\n      contentType: \"text/plain; charset=utf-8\",\n      dataStreamVersion: \"v1\"\n    })\n  });\n}\nfunction forwardAIMessageChunk(chunk, controller) {\n  if (typeof chunk.content === \"string\") {\n    controller.enqueue(chunk.content);\n  } else {\n    const content = chunk.content;\n    for (const item of content) {\n      if (item.type === \"text\") {\n        controller.enqueue(item.text);\n      }\n    }\n  }\n}\n\n// streams/langchain-stream.ts\nfunction LangChainStream(callbacks) {\n  const stream = new TransformStream();\n  const writer = stream.writable.getWriter();\n  const runs = /* @__PURE__ */ new Set();\n  const handleError = async (e, runId) => {\n    runs.delete(runId);\n    await writer.ready;\n    await writer.abort(e);\n  };\n  const handleStart = async (runId) => {\n    runs.add(runId);\n  };\n  const handleEnd = async (runId) => {\n    runs.delete(runId);\n    if (runs.size === 0) {\n      await writer.ready;\n      await writer.close();\n    }\n  };\n  return {\n    stream: stream.readable.pipeThrough(createCallbacksTransformer(callbacks)).pipeThrough(createStreamDataTransformer()),\n    writer,\n    handlers: {\n      handleLLMNewToken: async (token) => {\n        await writer.ready;\n        await writer.write(token);\n      },\n      handleLLMStart: async (_llm, _prompts, runId) => {\n        handleStart(runId);\n      },\n      handleLLMEnd: async (_output, runId) => {\n        await handleEnd(runId);\n      },\n      handleLLMError: async (e, runId) => {\n        await handleError(e, runId);\n      },\n      handleChainStart: async (_chain, _inputs, runId) => {\n        handleStart(runId);\n      },\n      handleChainEnd: async (_outputs, runId) => {\n        await handleEnd(runId);\n      },\n      handleChainError: async (e, runId) => {\n        await handleError(e, runId);\n      },\n      handleToolStart: async (_tool, _input, runId) => {\n        handleStart(runId);\n      },\n      handleToolEnd: async (_output, runId) => {\n        await handleEnd(runId);\n      },\n      handleToolError: async (e, runId) => {\n        await handleError(e, runId);\n      }\n    }\n  };\n}\n\n// streams/mistral-stream.ts\nasync function* streamable4(stream) {\n  var _a12, _b;\n  for await (const chunk of stream) {\n    const content = (_b = (_a12 = chunk.choices[0]) == null ? void 0 : _a12.delta) == null ? void 0 : _b.content;\n    if (content === void 0 || content === \"\") {\n      continue;\n    }\n    yield content;\n  }\n}\nfunction MistralStream(response, callbacks) {\n  const stream = readableFromAsyncIterable(streamable4(response));\n  return stream.pipeThrough(createCallbacksTransformer(callbacks)).pipeThrough(createStreamDataTransformer());\n}\n\n// streams/openai-stream.ts\n\nfunction parseOpenAIStream() {\n  const extract = chunkToText();\n  return (data) => extract(JSON.parse(data));\n}\nasync function* streamable5(stream) {\n  const extract = chunkToText();\n  for await (let chunk of stream) {\n    if (\"promptFilterResults\" in chunk) {\n      chunk = {\n        id: chunk.id,\n        created: chunk.created.getDate(),\n        object: chunk.object,\n        // not exposed by Azure API\n        model: chunk.model,\n        // not exposed by Azure API\n        choices: chunk.choices.map((choice) => {\n          var _a12, _b, _c, _d, _e, _f, _g;\n          return {\n            delta: {\n              content: (_a12 = choice.delta) == null ? void 0 : _a12.content,\n              function_call: (_b = choice.delta) == null ? void 0 : _b.functionCall,\n              role: (_c = choice.delta) == null ? void 0 : _c.role,\n              tool_calls: ((_e = (_d = choice.delta) == null ? void 0 : _d.toolCalls) == null ? void 0 : _e.length) ? (_g = (_f = choice.delta) == null ? void 0 : _f.toolCalls) == null ? void 0 : _g.map((toolCall, index) => ({\n                index,\n                id: toolCall.id,\n                function: toolCall.function,\n                type: toolCall.type\n              })) : void 0\n            },\n            finish_reason: choice.finishReason,\n            index: choice.index\n          };\n        })\n      };\n    }\n    const text = extract(chunk);\n    if (text)\n      yield text;\n  }\n}\nfunction chunkToText() {\n  const trimStartOfStream = trimStartOfStreamHelper();\n  let isFunctionStreamingIn;\n  return (json) => {\n    var _a12, _b, _c, _d, _e, _f, _g, _h, _i, _j, _k, _l, _m, _n, _o, _p, _q, _r;\n    if (isChatCompletionChunk(json)) {\n      const delta = (_a12 = json.choices[0]) == null ? void 0 : _a12.delta;\n      if ((_b = delta.function_call) == null ? void 0 : _b.name) {\n        isFunctionStreamingIn = true;\n        return {\n          isText: false,\n          content: `{\"function_call\": {\"name\": \"${delta.function_call.name}\", \"arguments\": \"`\n        };\n      } else if ((_e = (_d = (_c = delta.tool_calls) == null ? void 0 : _c[0]) == null ? void 0 : _d.function) == null ? void 0 : _e.name) {\n        isFunctionStreamingIn = true;\n        const toolCall = delta.tool_calls[0];\n        if (toolCall.index === 0) {\n          return {\n            isText: false,\n            content: `{\"tool_calls\":[ {\"id\": \"${toolCall.id}\", \"type\": \"function\", \"function\": {\"name\": \"${(_f = toolCall.function) == null ? void 0 : _f.name}\", \"arguments\": \"`\n          };\n        } else {\n          return {\n            isText: false,\n            content: `\"}}, {\"id\": \"${toolCall.id}\", \"type\": \"function\", \"function\": {\"name\": \"${(_g = toolCall.function) == null ? void 0 : _g.name}\", \"arguments\": \"`\n          };\n        }\n      } else if ((_h = delta.function_call) == null ? void 0 : _h.arguments) {\n        return {\n          isText: false,\n          content: cleanupArguments((_i = delta.function_call) == null ? void 0 : _i.arguments)\n        };\n      } else if ((_l = (_k = (_j = delta.tool_calls) == null ? void 0 : _j[0]) == null ? void 0 : _k.function) == null ? void 0 : _l.arguments) {\n        return {\n          isText: false,\n          content: cleanupArguments((_o = (_n = (_m = delta.tool_calls) == null ? void 0 : _m[0]) == null ? void 0 : _n.function) == null ? void 0 : _o.arguments)\n        };\n      } else if (isFunctionStreamingIn && (((_p = json.choices[0]) == null ? void 0 : _p.finish_reason) === \"function_call\" || ((_q = json.choices[0]) == null ? void 0 : _q.finish_reason) === \"stop\")) {\n        isFunctionStreamingIn = false;\n        return {\n          isText: false,\n          content: '\"}}'\n        };\n      } else if (isFunctionStreamingIn && ((_r = json.choices[0]) == null ? void 0 : _r.finish_reason) === \"tool_calls\") {\n        isFunctionStreamingIn = false;\n        return {\n          isText: false,\n          content: '\"}}]}'\n        };\n      }\n    }\n    const text = trimStartOfStream(\n      isChatCompletionChunk(json) && json.choices[0].delta.content ? json.choices[0].delta.content : isCompletion(json) ? json.choices[0].text : \"\"\n    );\n    return text;\n  };\n  function cleanupArguments(argumentChunk) {\n    let escapedPartialJson = argumentChunk.replace(/\\\\/g, \"\\\\\\\\\").replace(/\\//g, \"\\\\/\").replace(/\"/g, '\\\\\"').replace(/\\n/g, \"\\\\n\").replace(/\\r/g, \"\\\\r\").replace(/\\t/g, \"\\\\t\").replace(/\\f/g, \"\\\\f\");\n    return `${escapedPartialJson}`;\n  }\n}\nvar __internal__OpenAIFnMessagesSymbol = Symbol(\n  \"internal_openai_fn_messages\"\n);\nfunction isChatCompletionChunk(data) {\n  return \"choices\" in data && data.choices && data.choices[0] && \"delta\" in data.choices[0];\n}\nfunction isCompletion(data) {\n  return \"choices\" in data && data.choices && data.choices[0] && \"text\" in data.choices[0];\n}\nfunction OpenAIStream(res, callbacks) {\n  const cb = callbacks;\n  let stream;\n  if (Symbol.asyncIterator in res) {\n    stream = readableFromAsyncIterable(streamable5(res)).pipeThrough(\n      createCallbacksTransformer(\n        (cb == null ? void 0 : cb.experimental_onFunctionCall) || (cb == null ? void 0 : cb.experimental_onToolCall) ? {\n          ...cb,\n          onFinal: void 0\n        } : {\n          ...cb\n        }\n      )\n    );\n  } else {\n    stream = AIStream(\n      res,\n      parseOpenAIStream(),\n      (cb == null ? void 0 : cb.experimental_onFunctionCall) || (cb == null ? void 0 : cb.experimental_onToolCall) ? {\n        ...cb,\n        onFinal: void 0\n      } : {\n        ...cb\n      }\n    );\n  }\n  if (cb && (cb.experimental_onFunctionCall || cb.experimental_onToolCall)) {\n    const functionCallTransformer = createFunctionCallTransformer(cb);\n    return stream.pipeThrough(functionCallTransformer);\n  } else {\n    return stream.pipeThrough(createStreamDataTransformer());\n  }\n}\nfunction createFunctionCallTransformer(callbacks) {\n  const textEncoder = new TextEncoder();\n  let isFirstChunk = true;\n  let aggregatedResponse = \"\";\n  let aggregatedFinalCompletionResponse = \"\";\n  let isFunctionStreamingIn = false;\n  let functionCallMessages = callbacks[__internal__OpenAIFnMessagesSymbol] || [];\n  const decode = (0,_ai_sdk_ui_utils__WEBPACK_IMPORTED_MODULE_3__.createChunkDecoder)();\n  return new TransformStream({\n    async transform(chunk, controller) {\n      const message = decode(chunk);\n      aggregatedFinalCompletionResponse += message;\n      const shouldHandleAsFunction = isFirstChunk && (message.startsWith('{\"function_call\":') || message.startsWith('{\"tool_calls\":'));\n      if (shouldHandleAsFunction) {\n        isFunctionStreamingIn = true;\n        aggregatedResponse += message;\n        isFirstChunk = false;\n        return;\n      }\n      if (!isFunctionStreamingIn) {\n        controller.enqueue(\n          textEncoder.encode((0,_ai_sdk_ui_utils__WEBPACK_IMPORTED_MODULE_3__.formatStreamPart)(\"text\", message))\n        );\n        return;\n      } else {\n        aggregatedResponse += message;\n      }\n    },\n    async flush(controller) {\n      try {\n        if (!isFirstChunk && isFunctionStreamingIn && (callbacks.experimental_onFunctionCall || callbacks.experimental_onToolCall)) {\n          isFunctionStreamingIn = false;\n          const payload = JSON.parse(aggregatedResponse);\n          let newFunctionCallMessages = [\n            ...functionCallMessages\n          ];\n          let functionResponse = void 0;\n          if (callbacks.experimental_onFunctionCall) {\n            if (payload.function_call === void 0) {\n              console.warn(\n                \"experimental_onFunctionCall should not be defined when using tools\"\n              );\n            }\n            const argumentsPayload = JSON.parse(\n              payload.function_call.arguments\n            );\n            functionResponse = await callbacks.experimental_onFunctionCall(\n              {\n                name: payload.function_call.name,\n                arguments: argumentsPayload\n              },\n              (result) => {\n                newFunctionCallMessages = [\n                  ...functionCallMessages,\n                  {\n                    role: \"assistant\",\n                    content: \"\",\n                    function_call: payload.function_call\n                  },\n                  {\n                    role: \"function\",\n                    name: payload.function_call.name,\n                    content: JSON.stringify(result)\n                  }\n                ];\n                return newFunctionCallMessages;\n              }\n            );\n          }\n          if (callbacks.experimental_onToolCall) {\n            const toolCalls = {\n              tools: []\n            };\n            for (const tool2 of payload.tool_calls) {\n              toolCalls.tools.push({\n                id: tool2.id,\n                type: \"function\",\n                func: {\n                  name: tool2.function.name,\n                  arguments: JSON.parse(tool2.function.arguments)\n                }\n              });\n            }\n            let responseIndex = 0;\n            try {\n              functionResponse = await callbacks.experimental_onToolCall(\n                toolCalls,\n                (result) => {\n                  if (result) {\n                    const { tool_call_id, function_name, tool_call_result } = result;\n                    newFunctionCallMessages = [\n                      ...newFunctionCallMessages,\n                      // Only append the assistant message if it's the first response\n                      ...responseIndex === 0 ? [\n                        {\n                          role: \"assistant\",\n                          content: \"\",\n                          tool_calls: payload.tool_calls.map(\n                            (tc) => ({\n                              id: tc.id,\n                              type: \"function\",\n                              function: {\n                                name: tc.function.name,\n                                // we send the arguments an object to the user, but as the API expects a string, we need to stringify it\n                                arguments: JSON.stringify(\n                                  tc.function.arguments\n                                )\n                              }\n                            })\n                          )\n                        }\n                      ] : [],\n                      // Append the function call result message\n                      {\n                        role: \"tool\",\n                        tool_call_id,\n                        name: function_name,\n                        content: JSON.stringify(tool_call_result)\n                      }\n                    ];\n                    responseIndex++;\n                  }\n                  return newFunctionCallMessages;\n                }\n              );\n            } catch (e) {\n              console.error(\"Error calling experimental_onToolCall:\", e);\n            }\n          }\n          if (!functionResponse) {\n            controller.enqueue(\n              textEncoder.encode(\n                (0,_ai_sdk_ui_utils__WEBPACK_IMPORTED_MODULE_3__.formatStreamPart)(\n                  payload.function_call ? \"function_call\" : \"tool_calls\",\n                  // parse to prevent double-encoding:\n                  JSON.parse(aggregatedResponse)\n                )\n              )\n            );\n            return;\n          } else if (typeof functionResponse === \"string\") {\n            controller.enqueue(\n              textEncoder.encode((0,_ai_sdk_ui_utils__WEBPACK_IMPORTED_MODULE_3__.formatStreamPart)(\"text\", functionResponse))\n            );\n            aggregatedFinalCompletionResponse = functionResponse;\n            return;\n          }\n          const filteredCallbacks = {\n            ...callbacks,\n            onStart: void 0\n          };\n          callbacks.onFinal = void 0;\n          const openAIStream = OpenAIStream(functionResponse, {\n            ...filteredCallbacks,\n            [__internal__OpenAIFnMessagesSymbol]: newFunctionCallMessages\n          });\n          const reader = openAIStream.getReader();\n          while (true) {\n            const { done, value } = await reader.read();\n            if (done) {\n              break;\n            }\n            controller.enqueue(value);\n          }\n        }\n      } finally {\n        if (callbacks.onFinal && aggregatedFinalCompletionResponse) {\n          await callbacks.onFinal(aggregatedFinalCompletionResponse);\n        }\n      }\n    }\n  });\n}\n\n// streams/replicate-stream.ts\nasync function ReplicateStream(res, cb, options) {\n  var _a12;\n  const url = (_a12 = res.urls) == null ? void 0 : _a12.stream;\n  if (!url) {\n    if (res.error)\n      throw new Error(res.error);\n    else\n      throw new Error(\"Missing stream URL in Replicate response\");\n  }\n  const eventStream = await fetch(url, {\n    method: \"GET\",\n    headers: {\n      Accept: \"text/event-stream\",\n      ...options == null ? void 0 : options.headers\n    }\n  });\n  return AIStream(eventStream, void 0, cb).pipeThrough(\n    createStreamDataTransformer()\n  );\n}\n\n// streams/stream-to-response.ts\nfunction streamToResponse(res, response, init, data) {\n  var _a12;\n  response.writeHead((_a12 = init == null ? void 0 : init.status) != null ? _a12 : 200, {\n    \"Content-Type\": \"text/plain; charset=utf-8\",\n    ...init == null ? void 0 : init.headers\n  });\n  let processedStream = res;\n  if (data) {\n    processedStream = mergeStreams(data.stream, res);\n  }\n  const reader = processedStream.getReader();\n  function read() {\n    reader.read().then(({ done, value }) => {\n      if (done) {\n        response.end();\n        return;\n      }\n      response.write(value);\n      read();\n    });\n  }\n  read();\n}\n\n// streams/streaming-text-response.ts\nvar StreamingTextResponse = class extends Response {\n  constructor(res, init, data) {\n    let processedStream = res;\n    if (data) {\n      processedStream = mergeStreams(data.stream, res);\n    }\n    super(processedStream, {\n      ...init,\n      status: 200,\n      headers: prepareResponseHeaders(init, {\n        contentType: \"text/plain; charset=utf-8\"\n      })\n    });\n  }\n};\n\n// streams/index.ts\nvar generateId2 = _ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_1__.generateId;\nvar nanoid = _ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_1__.generateId;\n\n//# sourceMappingURL=index.mjs.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9haS9kaXN0L2luZGV4Lm1qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQyxvQ0FBb0M7QUFDcEU7O0FBRUE7QUFNMEI7QUFDNEM7O0FBRXRFO0FBQzhDOztBQUU5QztBQUNnRDtBQUN1Qjs7QUFFdkU7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDOEM7QUFDOUM7QUFDQSxnQ0FBZ0MsS0FBSztBQUNyQztBQUNBO0FBQ0EsK0JBQStCLHdEQUFVO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNILFlBQVksZUFBZTtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLHdEQUFVO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRSxJQUFJO0FBQ047QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQSxJQUFJO0FBQ0osUUFBUSxvRUFBWTtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLHVFQUFlO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDLFdBQVcsd0JBQXdCLGFBQWE7QUFDakY7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLGtDQUFrQywwREFBWTtBQUM5QztBQUNBO0FBQ0E7QUFDQSxVQUFVLGlFQUFpRTtBQUMzRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQixXQUFXLHNDQUFz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QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQSwrRkFBK0Y7QUFDL0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUM2RDtBQUM3RDtBQUNBLGlDQUFpQyxNQUFNO0FBQ3ZDO0FBQ0E7QUFDQSwyQ0FBMkMsd0RBQVc7QUFDdEQ7QUFD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Q0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDO0FBQ2hDO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUkwQjtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2YsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNB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Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUM7QUFDakM7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLGFBQWE7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDO0FBQ2xDLE9BQU87QUFDUCxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBLGtCQUFrQiw4REFBYztBQUNoQyxhQUFhLDhEQUFjO0FBMEV6QjtBQUNGIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vYXNrX2RvYy8uL25vZGVfbW9kdWxlcy9haS9kaXN0L2luZGV4Lm1qcz9mNGY1Il0sInNvdXJjZXNDb250ZW50IjpbInZhciBfX2RlZlByb3AgPSBPYmplY3QuZGVmaW5lUHJvcGVydHk7XG52YXIgX19leHBvcnQgPSAodGFyZ2V0LCBhbGwpID0+IHtcbiAgZm9yICh2YXIgbmFtZTEyIGluIGFsbClcbiAgICBfX2RlZlByb3AodGFyZ2V0LCBuYW1lMTIsIHsgZ2V0OiBhbGxbbmFtZTEyXSwgZW51bWVyYWJsZTogdHJ1ZSB9KTtcbn07XG5cbi8vIHN0cmVhbXMvaW5kZXgudHNcbmltcG9ydCB7XG4gIGZvcm1hdFN0cmVhbVBhcnQsXG4gIHBhcnNlU3RyZWFtUGFydCxcbiAgcmVhZERhdGFTdHJlYW0sXG4gIHBhcnNlQ29tcGxleFJlc3BvbnNlXG59IGZyb20gXCJAYWktc2RrL3VpLXV0aWxzXCI7XG5pbXBvcnQgeyBnZW5lcmF0ZUlkIGFzIGdlbmVyYXRlSWRJbXBsIH0gZnJvbSBcIkBhaS1zZGsvcHJvdmlkZXItdXRpbHNcIjtcblxuLy8gY29yZS9pbmRleC50c1xuaW1wb3J0IHsganNvblNjaGVtYSB9IGZyb20gXCJAYWktc2RrL3VpLXV0aWxzXCI7XG5cbi8vIHV0aWwvcmV0cnktd2l0aC1leHBvbmVudGlhbC1iYWNrb2ZmLnRzXG5pbXBvcnQgeyBBUElDYWxsRXJyb3IgfSBmcm9tIFwiQGFpLXNkay9wcm92aWRlclwiO1xuaW1wb3J0IHsgZ2V0RXJyb3JNZXNzYWdlLCBpc0Fib3J0RXJyb3IgfSBmcm9tIFwiQGFpLXNkay9wcm92aWRlci11dGlsc1wiO1xuXG4vLyB1dGlsL2RlbGF5LnRzXG5hc3luYyBmdW5jdGlvbiBkZWxheShkZWxheUluTXMpIHtcbiAgcmV0dXJuIGRlbGF5SW5NcyA9PT0gdm9pZCAwID8gUHJvbWlzZS5yZXNvbHZlKCkgOiBuZXcgUHJvbWlzZSgocmVzb2x2ZSkgPT4gc2V0VGltZW91dChyZXNvbHZlLCBkZWxheUluTXMpKTtcbn1cblxuLy8gdXRpbC9yZXRyeS1lcnJvci50c1xuaW1wb3J0IHsgQUlTREtFcnJvciB9IGZyb20gXCJAYWktc2RrL3Byb3ZpZGVyXCI7XG52YXIgbmFtZSA9IFwiQUlfUmV0cnlFcnJvclwiO1xudmFyIG1hcmtlciA9IGB2ZXJjZWwuYWkuZXJyb3IuJHtuYW1lfWA7XG52YXIgc3ltYm9sID0gU3ltYm9sLmZvcihtYXJrZXIpO1xudmFyIF9hO1xudmFyIFJldHJ5RXJyb3IgPSBjbGFzcyBleHRlbmRzIEFJU0RLRXJyb3Ige1xuICBjb25zdHJ1Y3Rvcih7XG4gICAgbWVzc2FnZSxcbiAgICByZWFzb24sXG4gICAgZXJyb3JzXG4gIH0pIHtcbiAgICBzdXBlcih7IG5hbWUsIG1lc3NhZ2UgfSk7XG4gICAgdGhpc1tfYV0gPSB0cnVlO1xuICAgIHRoaXMucmVhc29uID0gcmVhc29uO1xuICAgIHRoaXMuZXJyb3JzID0gZXJyb3JzO1xuICAgIHRoaXMubGFzdEVycm9yID0gZXJyb3JzW2Vycm9ycy5sZW5ndGggLSAxXTtcbiAgfVxuICBzdGF0aWMgaXNJbnN0YW5jZShlcnJvcikge1xuICAgIHJldHVybiBBSVNES0Vycm9yLmhhc01hcmtlcihlcnJvciwgbWFya2VyKTtcbiAgfVxuICAvKipcbiAgICogQGRlcHJlY2F0ZWQgdXNlIGBpc0luc3RhbmNlYCBpbnN0ZWFkXG4gICAqL1xuICBzdGF0aWMgaXNSZXRyeUVycm9yKGVycm9yKSB7XG4gICAgcmV0dXJuIGVycm9yIGluc3RhbmNlb2YgRXJyb3IgJiYgZXJyb3IubmFtZSA9PT0gbmFtZSAmJiB0eXBlb2YgZXJyb3IucmVhc29uID09PSBcInN0cmluZ1wiICYmIEFycmF5LmlzQXJyYXkoZXJyb3IuZXJyb3JzKTtcbiAgfVxuICAvKipcbiAgICogQGRlcHJlY2F0ZWQgRG8gbm90IHVzZSB0aGlzIG1ldGhvZC4gSXQgd2lsbCBiZSByZW1vdmVkIGluIHRoZSBuZXh0IG1ham9yIHZlcnNpb24uXG4gICAqL1xuICB0b0pTT04oKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIG5hbWU6IHRoaXMubmFtZSxcbiAgICAgIG1lc3NhZ2U6IHRoaXMubWVzc2FnZSxcbiAgICAgIHJlYXNvbjogdGhpcy5yZWFzb24sXG4gICAgICBsYXN0RXJyb3I6IHRoaXMubGFzdEVycm9yLFxuICAgICAgZXJyb3JzOiB0aGlzLmVycm9yc1xuICAgIH07XG4gIH1cbn07XG5fYSA9IHN5bWJvbDtcblxuLy8gdXRpbC9yZXRyeS13aXRoLWV4cG9uZW50aWFsLWJhY2tvZmYudHNcbnZhciByZXRyeVdpdGhFeHBvbmVudGlhbEJhY2tvZmYgPSAoe1xuICBtYXhSZXRyaWVzID0gMixcbiAgaW5pdGlhbERlbGF5SW5NcyA9IDJlMyxcbiAgYmFja29mZkZhY3RvciA9IDJcbn0gPSB7fSkgPT4gYXN5bmMgKGYpID0+IF9yZXRyeVdpdGhFeHBvbmVudGlhbEJhY2tvZmYoZiwge1xuICBtYXhSZXRyaWVzLFxuICBkZWxheUluTXM6IGluaXRpYWxEZWxheUluTXMsXG4gIGJhY2tvZmZGYWN0b3Jcbn0pO1xuYXN5bmMgZnVuY3Rpb24gX3JldHJ5V2l0aEV4cG9uZW50aWFsQmFja29mZihmLCB7XG4gIG1heFJldHJpZXMsXG4gIGRlbGF5SW5NcyxcbiAgYmFja29mZkZhY3RvclxufSwgZXJyb3JzID0gW10pIHtcbiAgdHJ5IHtcbiAgICByZXR1cm4gYXdhaXQgZigpO1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIGlmIChpc0Fib3J0RXJyb3IoZXJyb3IpKSB7XG4gICAgICB0aHJvdyBlcnJvcjtcbiAgICB9XG4gICAgaWYgKG1heFJldHJpZXMgPT09IDApIHtcbiAgICAgIHRocm93IGVycm9yO1xuICAgIH1cbiAgICBjb25zdCBlcnJvck1lc3NhZ2UgPSBnZXRFcnJvck1lc3NhZ2UoZXJyb3IpO1xuICAgIGNvbnN0IG5ld0Vycm9ycyA9IFsuLi5lcnJvcnMsIGVycm9yXTtcbiAgICBjb25zdCB0cnlOdW1iZXIgPSBuZXdFcnJvcnMubGVuZ3RoO1xuICAgIGlmICh0cnlOdW1iZXIgPiBtYXhSZXRyaWVzKSB7XG4gICAgICB0aHJvdyBuZXcgUmV0cnlFcnJvcih7XG4gICAgICAgIG1lc3NhZ2U6IGBGYWlsZWQgYWZ0ZXIgJHt0cnlOdW1iZXJ9IGF0dGVtcHRzLiBMYXN0IGVycm9yOiAke2Vycm9yTWVzc2FnZX1gLFxuICAgICAgICByZWFzb246IFwibWF4UmV0cmllc0V4Y2VlZGVkXCIsXG4gICAgICAgIGVycm9yczogbmV3RXJyb3JzXG4gICAgICB9KTtcbiAgICB9XG4gICAgaWYgKGVycm9yIGluc3RhbmNlb2YgRXJyb3IgJiYgQVBJQ2FsbEVycm9yLmlzQVBJQ2FsbEVycm9yKGVycm9yKSAmJiBlcnJvci5pc1JldHJ5YWJsZSA9PT0gdHJ1ZSAmJiB0cnlOdW1iZXIgPD0gbWF4UmV0cmllcykge1xuICAgICAgYXdhaXQgZGVsYXkoZGVsYXlJbk1zKTtcbiAgICAgIHJldHVybiBfcmV0cnlXaXRoRXhwb25lbnRpYWxCYWNrb2ZmKFxuICAgICAgICBmLFxuICAgICAgICB7IG1heFJldHJpZXMsIGRlbGF5SW5NczogYmFja29mZkZhY3RvciAqIGRlbGF5SW5NcywgYmFja29mZkZhY3RvciB9LFxuICAgICAgICBuZXdFcnJvcnNcbiAgICAgICk7XG4gICAgfVxuICAgIGlmICh0cnlOdW1iZXIgPT09IDEpIHtcbiAgICAgIHRocm93IGVycm9yO1xuICAgIH1cbiAgICB0aHJvdyBuZXcgUmV0cnlFcnJvcih7XG4gICAgICBtZXNzYWdlOiBgRmFpbGVkIGFmdGVyICR7dHJ5TnVtYmVyfSBhdHRlbXB0cyB3aXRoIG5vbi1yZXRyeWFibGUgZXJyb3I6ICcke2Vycm9yTWVzc2FnZX0nYCxcbiAgICAgIHJlYXNvbjogXCJlcnJvck5vdFJldHJ5YWJsZVwiLFxuICAgICAgZXJyb3JzOiBuZXdFcnJvcnNcbiAgICB9KTtcbiAgfVxufVxuXG4vLyBjb3JlL3RlbGVtZXRyeS9hc3NlbWJsZS1vcGVyYXRpb24tbmFtZS50c1xuZnVuY3Rpb24gYXNzZW1ibGVPcGVyYXRpb25OYW1lKHtcbiAgb3BlcmF0aW9uTmFtZSxcbiAgdGVsZW1ldHJ5XG59KSB7XG4gIHJldHVybiB7XG4gICAgXCJvcGVyYXRpb24ubmFtZVwiOiBgJHtvcGVyYXRpb25OYW1lfSR7KHRlbGVtZXRyeSA9PSBudWxsID8gdm9pZCAwIDogdGVsZW1ldHJ5LmZ1bmN0aW9uSWQpICE9IG51bGwgPyBgICR7dGVsZW1ldHJ5LmZ1bmN0aW9uSWR9YCA6IFwiXCJ9YFxuICB9O1xufVxuXG4vLyBjb3JlL3RlbGVtZXRyeS9nZXQtYmFzZS10ZWxlbWV0cnktYXR0cmlidXRlcy50c1xuZnVuY3Rpb24gZ2V0QmFzZVRlbGVtZXRyeUF0dHJpYnV0ZXMoe1xuICBtb2RlbCxcbiAgc2V0dGluZ3MsXG4gIHRlbGVtZXRyeSxcbiAgaGVhZGVyc1xufSkge1xuICB2YXIgX2ExMjtcbiAgcmV0dXJuIHtcbiAgICBcImFpLm1vZGVsLnByb3ZpZGVyXCI6IG1vZGVsLnByb3ZpZGVyLFxuICAgIFwiYWkubW9kZWwuaWRcIjogbW9kZWwubW9kZWxJZCxcbiAgICAvLyBzZXR0aW5nczpcbiAgICAuLi5PYmplY3QuZW50cmllcyhzZXR0aW5ncykucmVkdWNlKChhdHRyaWJ1dGVzLCBba2V5LCB2YWx1ZV0pID0+IHtcbiAgICAgIGF0dHJpYnV0ZXNbYGFpLnNldHRpbmdzLiR7a2V5fWBdID0gdmFsdWU7XG4gICAgICByZXR1cm4gYXR0cmlidXRlcztcbiAgICB9LCB7fSksXG4gICAgLy8gc3BlY2lhbCB0ZWxlbWV0cnkgaW5mb3JtYXRpb25cbiAgICBcInJlc291cmNlLm5hbWVcIjogdGVsZW1ldHJ5ID09IG51bGwgPyB2b2lkIDAgOiB0ZWxlbWV0cnkuZnVuY3Rpb25JZCxcbiAgICBcImFpLnRlbGVtZXRyeS5mdW5jdGlvbklkXCI6IHRlbGVtZXRyeSA9PSBudWxsID8gdm9pZCAwIDogdGVsZW1ldHJ5LmZ1bmN0aW9uSWQsXG4gICAgLy8gYWRkIG1ldGFkYXRhIGFzIGF0dHJpYnV0ZXM6XG4gICAgLi4uT2JqZWN0LmVudHJpZXMoKF9hMTIgPSB0ZWxlbWV0cnkgPT0gbnVsbCA/IHZvaWQgMCA6IHRlbGVtZXRyeS5tZXRhZGF0YSkgIT0gbnVsbCA/IF9hMTIgOiB7fSkucmVkdWNlKFxuICAgICAgKGF0dHJpYnV0ZXMsIFtrZXksIHZhbHVlXSkgPT4ge1xuICAgICAgICBhdHRyaWJ1dGVzW2BhaS50ZWxlbWV0cnkubWV0YWRhdGEuJHtrZXl9YF0gPSB2YWx1ZTtcbiAgICAgICAgcmV0dXJuIGF0dHJpYnV0ZXM7XG4gICAgICB9LFxuICAgICAge31cbiAgICApLFxuICAgIC8vIHJlcXVlc3QgaGVhZGVyc1xuICAgIC4uLk9iamVjdC5lbnRyaWVzKGhlYWRlcnMgIT0gbnVsbCA/IGhlYWRlcnMgOiB7fSkucmVkdWNlKChhdHRyaWJ1dGVzLCBba2V5LCB2YWx1ZV0pID0+IHtcbiAgICAgIGlmICh2YWx1ZSAhPT0gdm9pZCAwKSB7XG4gICAgICAgIGF0dHJpYnV0ZXNbYGFpLnJlcXVlc3QuaGVhZGVycy4ke2tleX1gXSA9IHZhbHVlO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGF0dHJpYnV0ZXM7XG4gICAgfSwge30pXG4gIH07XG59XG5cbi8vIGNvcmUvdGVsZW1ldHJ5L2dldC10cmFjZXIudHNcbmltcG9ydCB7IHRyYWNlIH0gZnJvbSBcIkBvcGVudGVsZW1ldHJ5L2FwaVwiO1xuXG4vLyBjb3JlL3RlbGVtZXRyeS9ub29wLXRyYWNlci50c1xudmFyIG5vb3BUcmFjZXIgPSB7XG4gIHN0YXJ0U3BhbigpIHtcbiAgICByZXR1cm4gbm9vcFNwYW47XG4gIH0sXG4gIHN0YXJ0QWN0aXZlU3BhbihuYW1lMTIsIGFyZzEsIGFyZzIsIGFyZzMpIHtcbiAgICBpZiAodHlwZW9mIGFyZzEgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgcmV0dXJuIGFyZzEobm9vcFNwYW4pO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIGFyZzIgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgcmV0dXJuIGFyZzIobm9vcFNwYW4pO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIGFyZzMgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgcmV0dXJuIGFyZzMobm9vcFNwYW4pO1xuICAgIH1cbiAgfVxufTtcbnZhciBub29wU3BhbiA9IHtcbiAgc3BhbkNvbnRleHQoKSB7XG4gICAgcmV0dXJuIG5vb3BTcGFuQ29udGV4dDtcbiAgfSxcbiAgc2V0QXR0cmlidXRlKCkge1xuICAgIHJldHVybiB0aGlzO1xuICB9LFxuICBzZXRBdHRyaWJ1dGVzKCkge1xuICAgIHJldHVybiB0aGlzO1xuICB9LFxuICBhZGRFdmVudCgpIHtcbiAgICByZXR1cm4gdGhpcztcbiAgfSxcbiAgYWRkTGluaygpIHtcbiAgICByZXR1cm4gdGhpcztcbiAgfSxcbiAgYWRkTGlua3MoKSB7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH0sXG4gIHNldFN0YXR1cygpIHtcbiAgICByZXR1cm4gdGhpcztcbiAgfSxcbiAgdXBkYXRlTmFtZSgpIHtcbiAgICByZXR1cm4gdGhpcztcbiAgfSxcbiAgZW5kKCkge1xuICAgIHJldHVybiB0aGlzO1xuICB9LFxuICBpc1JlY29yZGluZygpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH0sXG4gIHJlY29yZEV4Y2VwdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxufTtcbnZhciBub29wU3BhbkNvbnRleHQgPSB7XG4gIHRyYWNlSWQ6IFwiXCIsXG4gIHNwYW5JZDogXCJcIixcbiAgdHJhY2VGbGFnczogMFxufTtcblxuLy8gY29yZS90ZWxlbWV0cnkvZ2V0LXRyYWNlci50c1xudmFyIHRlc3RUcmFjZXIgPSB2b2lkIDA7XG5mdW5jdGlvbiBnZXRUcmFjZXIoeyBpc0VuYWJsZWQgfSkge1xuICBpZiAoIWlzRW5hYmxlZCkge1xuICAgIHJldHVybiBub29wVHJhY2VyO1xuICB9XG4gIGlmICh0ZXN0VHJhY2VyKSB7XG4gICAgcmV0dXJuIHRlc3RUcmFjZXI7XG4gIH1cbiAgcmV0dXJuIHRyYWNlLmdldFRyYWNlcihcImFpXCIpO1xufVxuXG4vLyBjb3JlL3RlbGVtZXRyeS9yZWNvcmQtc3Bhbi50c1xuaW1wb3J0IHsgU3BhblN0YXR1c0NvZGUgfSBmcm9tIFwiQG9wZW50ZWxlbWV0cnkvYXBpXCI7XG5mdW5jdGlvbiByZWNvcmRTcGFuKHtcbiAgbmFtZTogbmFtZTEyLFxuICB0cmFjZXIsXG4gIGF0dHJpYnV0ZXMsXG4gIGZuLFxuICBlbmRXaGVuRG9uZSA9IHRydWVcbn0pIHtcbiAgcmV0dXJuIHRyYWNlci5zdGFydEFjdGl2ZVNwYW4obmFtZTEyLCB7IGF0dHJpYnV0ZXMgfSwgYXN5bmMgKHNwYW4pID0+IHtcbiAgICB0cnkge1xuICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgZm4oc3Bhbik7XG4gICAgICBpZiAoZW5kV2hlbkRvbmUpIHtcbiAgICAgICAgc3Bhbi5lbmQoKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGlmIChlcnJvciBpbnN0YW5jZW9mIEVycm9yKSB7XG4gICAgICAgICAgc3Bhbi5yZWNvcmRFeGNlcHRpb24oe1xuICAgICAgICAgICAgbmFtZTogZXJyb3IubmFtZSxcbiAgICAgICAgICAgIG1lc3NhZ2U6IGVycm9yLm1lc3NhZ2UsXG4gICAgICAgICAgICBzdGFjazogZXJyb3Iuc3RhY2tcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBzcGFuLnNldFN0YXR1cyh7XG4gICAgICAgICAgICBjb2RlOiBTcGFuU3RhdHVzQ29kZS5FUlJPUixcbiAgICAgICAgICAgIG1lc3NhZ2U6IGVycm9yLm1lc3NhZ2VcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBzcGFuLnNldFN0YXR1cyh7IGNvZGU6IFNwYW5TdGF0dXNDb2RlLkVSUk9SIH0pO1xuICAgICAgICB9XG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICBzcGFuLmVuZCgpO1xuICAgICAgfVxuICAgICAgdGhyb3cgZXJyb3I7XG4gICAgfVxuICB9KTtcbn1cblxuLy8gY29yZS90ZWxlbWV0cnkvc2VsZWN0LXRlbGVtZXRyeS1hdHRyaWJ1dGVzLnRzXG5mdW5jdGlvbiBzZWxlY3RUZWxlbWV0cnlBdHRyaWJ1dGVzKHtcbiAgdGVsZW1ldHJ5LFxuICBhdHRyaWJ1dGVzXG59KSB7XG4gIHJldHVybiBPYmplY3QuZW50cmllcyhhdHRyaWJ1dGVzKS5yZWR1Y2UoKGF0dHJpYnV0ZXMyLCBba2V5LCB2YWx1ZV0pID0+IHtcbiAgICBpZiAodmFsdWUgPT09IHZvaWQgMCkge1xuICAgICAgcmV0dXJuIGF0dHJpYnV0ZXMyO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIHZhbHVlID09PSBcIm9iamVjdFwiICYmIFwiaW5wdXRcIiBpbiB2YWx1ZSAmJiB0eXBlb2YgdmFsdWUuaW5wdXQgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgaWYgKCh0ZWxlbWV0cnkgPT0gbnVsbCA/IHZvaWQgMCA6IHRlbGVtZXRyeS5yZWNvcmRJbnB1dHMpID09PSBmYWxzZSkge1xuICAgICAgICByZXR1cm4gYXR0cmlidXRlczI7XG4gICAgICB9XG4gICAgICBjb25zdCByZXN1bHQgPSB2YWx1ZS5pbnB1dCgpO1xuICAgICAgcmV0dXJuIHJlc3VsdCA9PT0gdm9pZCAwID8gYXR0cmlidXRlczIgOiB7IC4uLmF0dHJpYnV0ZXMyLCBba2V5XTogcmVzdWx0IH07XG4gICAgfVxuICAgIGlmICh0eXBlb2YgdmFsdWUgPT09IFwib2JqZWN0XCIgJiYgXCJvdXRwdXRcIiBpbiB2YWx1ZSAmJiB0eXBlb2YgdmFsdWUub3V0cHV0ID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgIGlmICgodGVsZW1ldHJ5ID09IG51bGwgPyB2b2lkIDAgOiB0ZWxlbWV0cnkucmVjb3JkT3V0cHV0cykgPT09IGZhbHNlKSB7XG4gICAgICAgIHJldHVybiBhdHRyaWJ1dGVzMjtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHJlc3VsdCA9IHZhbHVlLm91dHB1dCgpO1xuICAgICAgcmV0dXJuIHJlc3VsdCA9PT0gdm9pZCAwID8gYXR0cmlidXRlczIgOiB7IC4uLmF0dHJpYnV0ZXMyLCBba2V5XTogcmVzdWx0IH07XG4gICAgfVxuICAgIHJldHVybiB7IC4uLmF0dHJpYnV0ZXMyLCBba2V5XTogdmFsdWUgfTtcbiAgfSwge30pO1xufVxuXG4vLyBjb3JlL2VtYmVkL2VtYmVkLnRzXG5hc3luYyBmdW5jdGlvbiBlbWJlZCh7XG4gIG1vZGVsLFxuICB2YWx1ZSxcbiAgbWF4UmV0cmllcyxcbiAgYWJvcnRTaWduYWwsXG4gIGhlYWRlcnMsXG4gIGV4cGVyaW1lbnRhbF90ZWxlbWV0cnk6IHRlbGVtZXRyeVxufSkge1xuICB2YXIgX2ExMjtcbiAgY29uc3QgYmFzZVRlbGVtZXRyeUF0dHJpYnV0ZXMgPSBnZXRCYXNlVGVsZW1ldHJ5QXR0cmlidXRlcyh7XG4gICAgbW9kZWwsXG4gICAgdGVsZW1ldHJ5LFxuICAgIGhlYWRlcnMsXG4gICAgc2V0dGluZ3M6IHsgbWF4UmV0cmllcyB9XG4gIH0pO1xuICBjb25zdCB0cmFjZXIgPSBnZXRUcmFjZXIoeyBpc0VuYWJsZWQ6IChfYTEyID0gdGVsZW1ldHJ5ID09IG51bGwgPyB2b2lkIDAgOiB0ZWxlbWV0cnkuaXNFbmFibGVkKSAhPSBudWxsID8gX2ExMiA6IGZhbHNlIH0pO1xuICByZXR1cm4gcmVjb3JkU3Bhbih7XG4gICAgbmFtZTogXCJhaS5lbWJlZFwiLFxuICAgIGF0dHJpYnV0ZXM6IHNlbGVjdFRlbGVtZXRyeUF0dHJpYnV0ZXMoe1xuICAgICAgdGVsZW1ldHJ5LFxuICAgICAgYXR0cmlidXRlczoge1xuICAgICAgICAuLi5hc3NlbWJsZU9wZXJhdGlvbk5hbWUoeyBvcGVyYXRpb25OYW1lOiBcImFpLmVtYmVkXCIsIHRlbGVtZXRyeSB9KSxcbiAgICAgICAgLi4uYmFzZVRlbGVtZXRyeUF0dHJpYnV0ZXMsXG4gICAgICAgIFwiYWkudmFsdWVcIjogeyBpbnB1dDogKCkgPT4gSlNPTi5zdHJpbmdpZnkodmFsdWUpIH1cbiAgICAgIH1cbiAgICB9KSxcbiAgICB0cmFjZXIsXG4gICAgZm46IGFzeW5jIChzcGFuKSA9PiB7XG4gICAgICBjb25zdCByZXRyeSA9IHJldHJ5V2l0aEV4cG9uZW50aWFsQmFja29mZih7IG1heFJldHJpZXMgfSk7XG4gICAgICBjb25zdCB7IGVtYmVkZGluZywgdXNhZ2UsIHJhd1Jlc3BvbnNlIH0gPSBhd2FpdCByZXRyeShcbiAgICAgICAgKCkgPT4gKFxuICAgICAgICAgIC8vIG5lc3RlZCBzcGFucyB0byBhbGlnbiB3aXRoIHRoZSBlbWJlZE1hbnkgdGVsZW1ldHJ5IGRhdGE6XG4gICAgICAgICAgcmVjb3JkU3Bhbih7XG4gICAgICAgICAgICBuYW1lOiBcImFpLmVtYmVkLmRvRW1iZWRcIixcbiAgICAgICAgICAgIGF0dHJpYnV0ZXM6IHNlbGVjdFRlbGVtZXRyeUF0dHJpYnV0ZXMoe1xuICAgICAgICAgICAgICB0ZWxlbWV0cnksXG4gICAgICAgICAgICAgIGF0dHJpYnV0ZXM6IHtcbiAgICAgICAgICAgICAgICAuLi5hc3NlbWJsZU9wZXJhdGlvbk5hbWUoe1xuICAgICAgICAgICAgICAgICAgb3BlcmF0aW9uTmFtZTogXCJhaS5lbWJlZC5kb0VtYmVkXCIsXG4gICAgICAgICAgICAgICAgICB0ZWxlbWV0cnlcbiAgICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgICAgICAuLi5iYXNlVGVsZW1ldHJ5QXR0cmlidXRlcyxcbiAgICAgICAgICAgICAgICAvLyBzcGVjaWZpYyBzZXR0aW5ncyB0aGF0IG9ubHkgbWFrZSBzZW5zZSBvbiB0aGUgb3V0ZXIgbGV2ZWw6XG4gICAgICAgICAgICAgICAgXCJhaS52YWx1ZXNcIjogeyBpbnB1dDogKCkgPT4gW0pTT04uc3RyaW5naWZ5KHZhbHVlKV0gfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KSxcbiAgICAgICAgICAgIHRyYWNlcixcbiAgICAgICAgICAgIGZuOiBhc3luYyAoZG9FbWJlZFNwYW4pID0+IHtcbiAgICAgICAgICAgICAgdmFyIF9hMTM7XG4gICAgICAgICAgICAgIGNvbnN0IG1vZGVsUmVzcG9uc2UgPSBhd2FpdCBtb2RlbC5kb0VtYmVkKHtcbiAgICAgICAgICAgICAgICB2YWx1ZXM6IFt2YWx1ZV0sXG4gICAgICAgICAgICAgICAgYWJvcnRTaWduYWwsXG4gICAgICAgICAgICAgICAgaGVhZGVyc1xuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgY29uc3QgZW1iZWRkaW5nMiA9IG1vZGVsUmVzcG9uc2UuZW1iZWRkaW5nc1swXTtcbiAgICAgICAgICAgICAgY29uc3QgdXNhZ2UyID0gKF9hMTMgPSBtb2RlbFJlc3BvbnNlLnVzYWdlKSAhPSBudWxsID8gX2ExMyA6IHsgdG9rZW5zOiBOYU4gfTtcbiAgICAgICAgICAgICAgZG9FbWJlZFNwYW4uc2V0QXR0cmlidXRlcyhcbiAgICAgICAgICAgICAgICBzZWxlY3RUZWxlbWV0cnlBdHRyaWJ1dGVzKHtcbiAgICAgICAgICAgICAgICAgIHRlbGVtZXRyeSxcbiAgICAgICAgICAgICAgICAgIGF0dHJpYnV0ZXM6IHtcbiAgICAgICAgICAgICAgICAgICAgXCJhaS5lbWJlZGRpbmdzXCI6IHtcbiAgICAgICAgICAgICAgICAgICAgICBvdXRwdXQ6ICgpID0+IG1vZGVsUmVzcG9uc2UuZW1iZWRkaW5ncy5tYXAoXG4gICAgICAgICAgICAgICAgICAgICAgICAoZW1iZWRkaW5nMykgPT4gSlNPTi5zdHJpbmdpZnkoZW1iZWRkaW5nMylcbiAgICAgICAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIFwiYWkudXNhZ2UudG9rZW5zXCI6IHVzYWdlMi50b2tlbnNcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIGVtYmVkZGluZzogZW1iZWRkaW5nMixcbiAgICAgICAgICAgICAgICB1c2FnZTogdXNhZ2UyLFxuICAgICAgICAgICAgICAgIHJhd1Jlc3BvbnNlOiBtb2RlbFJlc3BvbnNlLnJhd1Jlc3BvbnNlXG4gICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSlcbiAgICAgICAgKVxuICAgICAgKTtcbiAgICAgIHNwYW4uc2V0QXR0cmlidXRlcyhcbiAgICAgICAgc2VsZWN0VGVsZW1ldHJ5QXR0cmlidXRlcyh7XG4gICAgICAgICAgdGVsZW1ldHJ5LFxuICAgICAgICAgIGF0dHJpYnV0ZXM6IHtcbiAgICAgICAgICAgIFwiYWkuZW1iZWRkaW5nXCI6IHsgb3V0cHV0OiAoKSA9PiBKU09OLnN0cmluZ2lmeShlbWJlZGRpbmcpIH0sXG4gICAgICAgICAgICBcImFpLnVzYWdlLnRva2Vuc1wiOiB1c2FnZS50b2tlbnNcbiAgICAgICAgICB9XG4gICAgICAgIH0pXG4gICAgICApO1xuICAgICAgcmV0dXJuIG5ldyBEZWZhdWx0RW1iZWRSZXN1bHQoeyB2YWx1ZSwgZW1iZWRkaW5nLCB1c2FnZSwgcmF3UmVzcG9uc2UgfSk7XG4gICAgfVxuICB9KTtcbn1cbnZhciBEZWZhdWx0RW1iZWRSZXN1bHQgPSBjbGFzcyB7XG4gIGNvbnN0cnVjdG9yKG9wdGlvbnMpIHtcbiAgICB0aGlzLnZhbHVlID0gb3B0aW9ucy52YWx1ZTtcbiAgICB0aGlzLmVtYmVkZGluZyA9IG9wdGlvbnMuZW1iZWRkaW5nO1xuICAgIHRoaXMudXNhZ2UgPSBvcHRpb25zLnVzYWdlO1xuICAgIHRoaXMucmF3UmVzcG9uc2UgPSBvcHRpb25zLnJhd1Jlc3BvbnNlO1xuICB9XG59O1xuXG4vLyBjb3JlL3V0aWwvc3BsaXQtYXJyYXkudHNcbmZ1bmN0aW9uIHNwbGl0QXJyYXkoYXJyYXksIGNodW5rU2l6ZSkge1xuICBpZiAoY2h1bmtTaXplIDw9IDApIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJjaHVua1NpemUgbXVzdCBiZSBncmVhdGVyIHRoYW4gMFwiKTtcbiAgfVxuICBjb25zdCByZXN1bHQgPSBbXTtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBhcnJheS5sZW5ndGg7IGkgKz0gY2h1bmtTaXplKSB7XG4gICAgcmVzdWx0LnB1c2goYXJyYXkuc2xpY2UoaSwgaSArIGNodW5rU2l6ZSkpO1xuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbi8vIGNvcmUvZW1iZWQvZW1iZWQtbWFueS50c1xuYXN5bmMgZnVuY3Rpb24gZW1iZWRNYW55KHtcbiAgbW9kZWwsXG4gIHZhbHVlcyxcbiAgbWF4UmV0cmllcyxcbiAgYWJvcnRTaWduYWwsXG4gIGhlYWRlcnMsXG4gIGV4cGVyaW1lbnRhbF90ZWxlbWV0cnk6IHRlbGVtZXRyeVxufSkge1xuICB2YXIgX2ExMjtcbiAgY29uc3QgYmFzZVRlbGVtZXRyeUF0dHJpYnV0ZXMgPSBnZXRCYXNlVGVsZW1ldHJ5QXR0cmlidXRlcyh7XG4gICAgbW9kZWwsXG4gICAgdGVsZW1ldHJ5LFxuICAgIGhlYWRlcnMsXG4gICAgc2V0dGluZ3M6IHsgbWF4UmV0cmllcyB9XG4gIH0pO1xuICBjb25zdCB0cmFjZXIgPSBnZXRUcmFjZXIoeyBpc0VuYWJsZWQ6IChfYTEyID0gdGVsZW1ldHJ5ID09IG51bGwgPyB2b2lkIDAgOiB0ZWxlbWV0cnkuaXNFbmFibGVkKSAhPSBudWxsID8gX2ExMiA6IGZhbHNlIH0pO1xuICByZXR1cm4gcmVjb3JkU3Bhbih7XG4gICAgbmFtZTogXCJhaS5lbWJlZE1hbnlcIixcbiAgICBhdHRyaWJ1dGVzOiBzZWxlY3RUZWxlbWV0cnlBdHRyaWJ1dGVzKHtcbiAgICAgIHRlbGVtZXRyeSxcbiAgICAgIGF0dHJpYnV0ZXM6IHtcbiAgICAgICAgLi4uYXNzZW1ibGVPcGVyYXRpb25OYW1lKHsgb3BlcmF0aW9uTmFtZTogXCJhaS5lbWJlZE1hbnlcIiwgdGVsZW1ldHJ5IH0pLFxuICAgICAgICAuLi5iYXNlVGVsZW1ldHJ5QXR0cmlidXRlcyxcbiAgICAgICAgLy8gc3BlY2lmaWMgc2V0dGluZ3MgdGhhdCBvbmx5IG1ha2Ugc2Vuc2Ugb24gdGhlIG91dGVyIGxldmVsOlxuICAgICAgICBcImFpLnZhbHVlc1wiOiB7XG4gICAgICAgICAgaW5wdXQ6ICgpID0+IHZhbHVlcy5tYXAoKHZhbHVlKSA9PiBKU09OLnN0cmluZ2lmeSh2YWx1ZSkpXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KSxcbiAgICB0cmFjZXIsXG4gICAgZm46IGFzeW5jIChzcGFuKSA9PiB7XG4gICAgICBjb25zdCByZXRyeSA9IHJldHJ5V2l0aEV4cG9uZW50aWFsQmFja29mZih7IG1heFJldHJpZXMgfSk7XG4gICAgICBjb25zdCBtYXhFbWJlZGRpbmdzUGVyQ2FsbCA9IG1vZGVsLm1heEVtYmVkZGluZ3NQZXJDYWxsO1xuICAgICAgaWYgKG1heEVtYmVkZGluZ3NQZXJDYWxsID09IG51bGwpIHtcbiAgICAgICAgY29uc3QgeyBlbWJlZGRpbmdzOiBlbWJlZGRpbmdzMiwgdXNhZ2UgfSA9IGF3YWl0IHJldHJ5KCgpID0+IHtcbiAgICAgICAgICByZXR1cm4gcmVjb3JkU3Bhbih7XG4gICAgICAgICAgICBuYW1lOiBcImFpLmVtYmVkTWFueS5kb0VtYmVkXCIsXG4gICAgICAgICAgICBhdHRyaWJ1dGVzOiBzZWxlY3RUZWxlbWV0cnlBdHRyaWJ1dGVzKHtcbiAgICAgICAgICAgICAgdGVsZW1ldHJ5LFxuICAgICAgICAgICAgICBhdHRyaWJ1dGVzOiB7XG4gICAgICAgICAgICAgICAgLi4uYXNzZW1ibGVPcGVyYXRpb25OYW1lKHtcbiAgICAgICAgICAgICAgICAgIG9wZXJhdGlvbk5hbWU6IFwiYWkuZW1iZWRNYW55LmRvRW1iZWRcIixcbiAgICAgICAgICAgICAgICAgIHRlbGVtZXRyeVxuICAgICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgICAgIC4uLmJhc2VUZWxlbWV0cnlBdHRyaWJ1dGVzLFxuICAgICAgICAgICAgICAgIC8vIHNwZWNpZmljIHNldHRpbmdzIHRoYXQgb25seSBtYWtlIHNlbnNlIG9uIHRoZSBvdXRlciBsZXZlbDpcbiAgICAgICAgICAgICAgICBcImFpLnZhbHVlc1wiOiB7XG4gICAgICAgICAgICAgICAgICBpbnB1dDogKCkgPT4gdmFsdWVzLm1hcCgodmFsdWUpID0+IEpTT04uc3RyaW5naWZ5KHZhbHVlKSlcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgdHJhY2VyLFxuICAgICAgICAgICAgZm46IGFzeW5jIChkb0VtYmVkU3BhbikgPT4ge1xuICAgICAgICAgICAgICB2YXIgX2ExMztcbiAgICAgICAgICAgICAgY29uc3QgbW9kZWxSZXNwb25zZSA9IGF3YWl0IG1vZGVsLmRvRW1iZWQoe1xuICAgICAgICAgICAgICAgIHZhbHVlcyxcbiAgICAgICAgICAgICAgICBhYm9ydFNpZ25hbCxcbiAgICAgICAgICAgICAgICBoZWFkZXJzXG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICBjb25zdCBlbWJlZGRpbmdzMyA9IG1vZGVsUmVzcG9uc2UuZW1iZWRkaW5ncztcbiAgICAgICAgICAgICAgY29uc3QgdXNhZ2UyID0gKF9hMTMgPSBtb2RlbFJlc3BvbnNlLnVzYWdlKSAhPSBudWxsID8gX2ExMyA6IHsgdG9rZW5zOiBOYU4gfTtcbiAgICAgICAgICAgICAgZG9FbWJlZFNwYW4uc2V0QXR0cmlidXRlcyhcbiAgICAgICAgICAgICAgICBzZWxlY3RUZWxlbWV0cnlBdHRyaWJ1dGVzKHtcbiAgICAgICAgICAgICAgICAgIHRlbGVtZXRyeSxcbiAgICAgICAgICAgICAgICAgIGF0dHJpYnV0ZXM6IHtcbiAgICAgICAgICAgICAgICAgICAgXCJhaS5lbWJlZGRpbmdzXCI6IHtcbiAgICAgICAgICAgICAgICAgICAgICBvdXRwdXQ6ICgpID0+IGVtYmVkZGluZ3MzLm1hcCgoZW1iZWRkaW5nKSA9PiBKU09OLnN0cmluZ2lmeShlbWJlZGRpbmcpKVxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICBcImFpLnVzYWdlLnRva2Vuc1wiOiB1c2FnZTIudG9rZW5zXG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgcmV0dXJuIHsgZW1iZWRkaW5nczogZW1iZWRkaW5nczMsIHVzYWdlOiB1c2FnZTIgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgICAgIHNwYW4uc2V0QXR0cmlidXRlcyhcbiAgICAgICAgICBzZWxlY3RUZWxlbWV0cnlBdHRyaWJ1dGVzKHtcbiAgICAgICAgICAgIHRlbGVtZXRyeSxcbiAgICAgICAgICAgIGF0dHJpYnV0ZXM6IHtcbiAgICAgICAgICAgICAgXCJhaS5lbWJlZGRpbmdzXCI6IHtcbiAgICAgICAgICAgICAgICBvdXRwdXQ6ICgpID0+IGVtYmVkZGluZ3MyLm1hcCgoZW1iZWRkaW5nKSA9PiBKU09OLnN0cmluZ2lmeShlbWJlZGRpbmcpKVxuICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICBcImFpLnVzYWdlLnRva2Vuc1wiOiB1c2FnZS50b2tlbnNcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KVxuICAgICAgICApO1xuICAgICAgICByZXR1cm4gbmV3IERlZmF1bHRFbWJlZE1hbnlSZXN1bHQoeyB2YWx1ZXMsIGVtYmVkZGluZ3M6IGVtYmVkZGluZ3MyLCB1c2FnZSB9KTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHZhbHVlQ2h1bmtzID0gc3BsaXRBcnJheSh2YWx1ZXMsIG1heEVtYmVkZGluZ3NQZXJDYWxsKTtcbiAgICAgIGNvbnN0IGVtYmVkZGluZ3MgPSBbXTtcbiAgICAgIGxldCB0b2tlbnMgPSAwO1xuICAgICAgZm9yIChjb25zdCBjaHVuayBvZiB2YWx1ZUNodW5rcykge1xuICAgICAgICBjb25zdCB7IGVtYmVkZGluZ3M6IHJlc3BvbnNlRW1iZWRkaW5ncywgdXNhZ2UgfSA9IGF3YWl0IHJldHJ5KCgpID0+IHtcbiAgICAgICAgICByZXR1cm4gcmVjb3JkU3Bhbih7XG4gICAgICAgICAgICBuYW1lOiBcImFpLmVtYmVkTWFueS5kb0VtYmVkXCIsXG4gICAgICAgICAgICBhdHRyaWJ1dGVzOiBzZWxlY3RUZWxlbWV0cnlBdHRyaWJ1dGVzKHtcbiAgICAgICAgICAgICAgdGVsZW1ldHJ5LFxuICAgICAgICAgICAgICBhdHRyaWJ1dGVzOiB7XG4gICAgICAgICAgICAgICAgLi4uYXNzZW1ibGVPcGVyYXRpb25OYW1lKHtcbiAgICAgICAgICAgICAgICAgIG9wZXJhdGlvbk5hbWU6IFwiYWkuZW1iZWRNYW55LmRvRW1iZWRcIixcbiAgICAgICAgICAgICAgICAgIHRlbGVtZXRyeVxuICAgICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgICAgIC4uLmJhc2VUZWxlbWV0cnlBdHRyaWJ1dGVzLFxuICAgICAgICAgICAgICAgIC8vIHNwZWNpZmljIHNldHRpbmdzIHRoYXQgb25seSBtYWtlIHNlbnNlIG9uIHRoZSBvdXRlciBsZXZlbDpcbiAgICAgICAgICAgICAgICBcImFpLnZhbHVlc1wiOiB7XG4gICAgICAgICAgICAgICAgICBpbnB1dDogKCkgPT4gY2h1bmsubWFwKCh2YWx1ZSkgPT4gSlNPTi5zdHJpbmdpZnkodmFsdWUpKVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSksXG4gICAgICAgICAgICB0cmFjZXIsXG4gICAgICAgICAgICBmbjogYXN5bmMgKGRvRW1iZWRTcGFuKSA9PiB7XG4gICAgICAgICAgICAgIHZhciBfYTEzO1xuICAgICAgICAgICAgICBjb25zdCBtb2RlbFJlc3BvbnNlID0gYXdhaXQgbW9kZWwuZG9FbWJlZCh7XG4gICAgICAgICAgICAgICAgdmFsdWVzOiBjaHVuayxcbiAgICAgICAgICAgICAgICBhYm9ydFNpZ25hbCxcbiAgICAgICAgICAgICAgICBoZWFkZXJzXG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICBjb25zdCBlbWJlZGRpbmdzMiA9IG1vZGVsUmVzcG9uc2UuZW1iZWRkaW5ncztcbiAgICAgICAgICAgICAgY29uc3QgdXNhZ2UyID0gKF9hMTMgPSBtb2RlbFJlc3BvbnNlLnVzYWdlKSAhPSBudWxsID8gX2ExMyA6IHsgdG9rZW5zOiBOYU4gfTtcbiAgICAgICAgICAgICAgZG9FbWJlZFNwYW4uc2V0QXR0cmlidXRlcyhcbiAgICAgICAgICAgICAgICBzZWxlY3RUZWxlbWV0cnlBdHRyaWJ1dGVzKHtcbiAgICAgICAgICAgICAgICAgIHRlbGVtZXRyeSxcbiAgICAgICAgICAgICAgICAgIGF0dHJpYnV0ZXM6IHtcbiAgICAgICAgICAgICAgICAgICAgXCJhaS5lbWJlZGRpbmdzXCI6IHtcbiAgICAgICAgICAgICAgICAgICAgICBvdXRwdXQ6ICgpID0+IGVtYmVkZGluZ3MyLm1hcCgoZW1iZWRkaW5nKSA9PiBKU09OLnN0cmluZ2lmeShlbWJlZGRpbmcpKVxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICBcImFpLnVzYWdlLnRva2Vuc1wiOiB1c2FnZTIudG9rZW5zXG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgcmV0dXJuIHsgZW1iZWRkaW5nczogZW1iZWRkaW5nczIsIHVzYWdlOiB1c2FnZTIgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgICAgIGVtYmVkZGluZ3MucHVzaCguLi5yZXNwb25zZUVtYmVkZGluZ3MpO1xuICAgICAgICB0b2tlbnMgKz0gdXNhZ2UudG9rZW5zO1xuICAgICAgfVxuICAgICAgc3Bhbi5zZXRBdHRyaWJ1dGVzKFxuICAgICAgICBzZWxlY3RUZWxlbWV0cnlBdHRyaWJ1dGVzKHtcbiAgICAgICAgICB0ZWxlbWV0cnksXG4gICAgICAgICAgYXR0cmlidXRlczoge1xuICAgICAgICAgICAgXCJhaS5lbWJlZGRpbmdzXCI6IHtcbiAgICAgICAgICAgICAgb3V0cHV0OiAoKSA9PiBlbWJlZGRpbmdzLm1hcCgoZW1iZWRkaW5nKSA9PiBKU09OLnN0cmluZ2lmeShlbWJlZGRpbmcpKVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIFwiYWkudXNhZ2UudG9rZW5zXCI6IHRva2Vuc1xuICAgICAgICAgIH1cbiAgICAgICAgfSlcbiAgICAgICk7XG4gICAgICByZXR1cm4gbmV3IERlZmF1bHRFbWJlZE1hbnlSZXN1bHQoe1xuICAgICAgICB2YWx1ZXMsXG4gICAgICAgIGVtYmVkZGluZ3MsXG4gICAgICAgIHVzYWdlOiB7IHRva2VucyB9XG4gICAgICB9KTtcbiAgICB9XG4gIH0pO1xufVxudmFyIERlZmF1bHRFbWJlZE1hbnlSZXN1bHQgPSBjbGFzcyB7XG4gIGNvbnN0cnVjdG9yKG9wdGlvbnMpIHtcbiAgICB0aGlzLnZhbHVlcyA9IG9wdGlvbnMudmFsdWVzO1xuICAgIHRoaXMuZW1iZWRkaW5ncyA9IG9wdGlvbnMuZW1iZWRkaW5ncztcbiAgICB0aGlzLnVzYWdlID0gb3B0aW9ucy51c2FnZTtcbiAgfVxufTtcblxuLy8gY29yZS9nZW5lcmF0ZS1vYmplY3QvZ2VuZXJhdGUtb2JqZWN0LnRzXG5pbXBvcnQgeyBzYWZlUGFyc2VKU09OIH0gZnJvbSBcIkBhaS1zZGsvcHJvdmlkZXItdXRpbHNcIjtcbmltcG9ydCB7IGFzU2NoZW1hIH0gZnJvbSBcIkBhaS1zZGsvdWktdXRpbHNcIjtcblxuLy8gY29yZS9wcm9tcHQvY29udmVydC10by1sYW5ndWFnZS1tb2RlbC1wcm9tcHQudHNcbmltcG9ydCB7IGdldEVycm9yTWVzc2FnZSBhcyBnZXRFcnJvck1lc3NhZ2UyIH0gZnJvbSBcIkBhaS1zZGsvcHJvdmlkZXItdXRpbHNcIjtcblxuLy8gdXRpbC9kb3dubG9hZC1lcnJvci50c1xuaW1wb3J0IHsgQUlTREtFcnJvciBhcyBBSVNES0Vycm9yMiB9IGZyb20gXCJAYWktc2RrL3Byb3ZpZGVyXCI7XG52YXIgbmFtZTIgPSBcIkFJX0Rvd25sb2FkRXJyb3JcIjtcbnZhciBtYXJrZXIyID0gYHZlcmNlbC5haS5lcnJvci4ke25hbWUyfWA7XG52YXIgc3ltYm9sMiA9IFN5bWJvbC5mb3IobWFya2VyMik7XG52YXIgX2EyO1xudmFyIERvd25sb2FkRXJyb3IgPSBjbGFzcyBleHRlbmRzIEFJU0RLRXJyb3IyIHtcbiAgY29uc3RydWN0b3Ioe1xuICAgIHVybCxcbiAgICBzdGF0dXNDb2RlLFxuICAgIHN0YXR1c1RleHQsXG4gICAgY2F1c2UsXG4gICAgbWVzc2FnZSA9IGNhdXNlID09IG51bGwgPyBgRmFpbGVkIHRvIGRvd25sb2FkICR7dXJsfTogJHtzdGF0dXNDb2RlfSAke3N0YXR1c1RleHR9YCA6IGBGYWlsZWQgdG8gZG93bmxvYWQgJHt1cmx9OiAke2NhdXNlfWBcbiAgfSkge1xuICAgIHN1cGVyKHsgbmFtZTogbmFtZTIsIG1lc3NhZ2UsIGNhdXNlIH0pO1xuICAgIHRoaXNbX2EyXSA9IHRydWU7XG4gICAgdGhpcy51cmwgPSB1cmw7XG4gICAgdGhpcy5zdGF0dXNDb2RlID0gc3RhdHVzQ29kZTtcbiAgICB0aGlzLnN0YXR1c1RleHQgPSBzdGF0dXNUZXh0O1xuICB9XG4gIHN0YXRpYyBpc0luc3RhbmNlKGVycm9yKSB7XG4gICAgcmV0dXJuIEFJU0RLRXJyb3IyLmhhc01hcmtlcihlcnJvciwgbWFya2VyMik7XG4gIH1cbiAgLyoqXG4gICAqIEBkZXByZWNhdGVkIHVzZSBgaXNJbnN0YW5jZWAgaW5zdGVhZFxuICAgKi9cbiAgc3RhdGljIGlzRG93bmxvYWRFcnJvcihlcnJvcikge1xuICAgIHJldHVybiBlcnJvciBpbnN0YW5jZW9mIEVycm9yICYmIGVycm9yLm5hbWUgPT09IG5hbWUyICYmIHR5cGVvZiBlcnJvci51cmwgPT09IFwic3RyaW5nXCIgJiYgKGVycm9yLnN0YXR1c0NvZGUgPT0gbnVsbCB8fCB0eXBlb2YgZXJyb3Iuc3RhdHVzQ29kZSA9PT0gXCJudW1iZXJcIikgJiYgKGVycm9yLnN0YXR1c1RleHQgPT0gbnVsbCB8fCB0eXBlb2YgZXJyb3Iuc3RhdHVzVGV4dCA9PT0gXCJzdHJpbmdcIik7XG4gIH1cbiAgLyoqXG4gICAqIEBkZXByZWNhdGVkIERvIG5vdCB1c2UgdGhpcyBtZXRob2QuIEl0IHdpbGwgYmUgcmVtb3ZlZCBpbiB0aGUgbmV4dCBtYWpvciB2ZXJzaW9uLlxuICAgKi9cbiAgdG9KU09OKCkge1xuICAgIHJldHVybiB7XG4gICAgICBuYW1lOiB0aGlzLm5hbWUsXG4gICAgICBtZXNzYWdlOiB0aGlzLm1lc3NhZ2UsXG4gICAgICB1cmw6IHRoaXMudXJsLFxuICAgICAgc3RhdHVzQ29kZTogdGhpcy5zdGF0dXNDb2RlLFxuICAgICAgc3RhdHVzVGV4dDogdGhpcy5zdGF0dXNUZXh0LFxuICAgICAgY2F1c2U6IHRoaXMuY2F1c2VcbiAgICB9O1xuICB9XG59O1xuX2EyID0gc3ltYm9sMjtcblxuLy8gdXRpbC9kb3dubG9hZC50c1xuYXN5bmMgZnVuY3Rpb24gZG93bmxvYWQoe1xuICB1cmwsXG4gIGZldGNoSW1wbGVtZW50YXRpb24gPSBmZXRjaFxufSkge1xuICB2YXIgX2ExMjtcbiAgY29uc3QgdXJsVGV4dCA9IHVybC50b1N0cmluZygpO1xuICB0cnkge1xuICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2hJbXBsZW1lbnRhdGlvbih1cmxUZXh0KTtcbiAgICBpZiAoIXJlc3BvbnNlLm9rKSB7XG4gICAgICB0aHJvdyBuZXcgRG93bmxvYWRFcnJvcih7XG4gICAgICAgIHVybDogdXJsVGV4dCxcbiAgICAgICAgc3RhdHVzQ29kZTogcmVzcG9uc2Uuc3RhdHVzLFxuICAgICAgICBzdGF0dXNUZXh0OiByZXNwb25zZS5zdGF0dXNUZXh0XG4gICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgIGRhdGE6IG5ldyBVaW50OEFycmF5KGF3YWl0IHJlc3BvbnNlLmFycmF5QnVmZmVyKCkpLFxuICAgICAgbWltZVR5cGU6IChfYTEyID0gcmVzcG9uc2UuaGVhZGVycy5nZXQoXCJjb250ZW50LXR5cGVcIikpICE9IG51bGwgPyBfYTEyIDogdm9pZCAwXG4gICAgfTtcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICBpZiAoRG93bmxvYWRFcnJvci5pc0luc3RhbmNlKGVycm9yKSkge1xuICAgICAgdGhyb3cgZXJyb3I7XG4gICAgfVxuICAgIHRocm93IG5ldyBEb3dubG9hZEVycm9yKHsgdXJsOiB1cmxUZXh0LCBjYXVzZTogZXJyb3IgfSk7XG4gIH1cbn1cblxuLy8gY29yZS91dGlsL2RldGVjdC1pbWFnZS1taW1ldHlwZS50c1xudmFyIG1pbWVUeXBlU2lnbmF0dXJlcyA9IFtcbiAgeyBtaW1lVHlwZTogXCJpbWFnZS9naWZcIiwgYnl0ZXM6IFs3MSwgNzMsIDcwXSB9LFxuICB7IG1pbWVUeXBlOiBcImltYWdlL3BuZ1wiLCBieXRlczogWzEzNywgODAsIDc4LCA3MV0gfSxcbiAgeyBtaW1lVHlwZTogXCJpbWFnZS9qcGVnXCIsIGJ5dGVzOiBbMjU1LCAyMTZdIH0sXG4gIHsgbWltZVR5cGU6IFwiaW1hZ2Uvd2VicFwiLCBieXRlczogWzgyLCA3MywgNzAsIDcwXSB9XG5dO1xuZnVuY3Rpb24gZGV0ZWN0SW1hZ2VNaW1lVHlwZShpbWFnZSkge1xuICBmb3IgKGNvbnN0IHsgYnl0ZXMsIG1pbWVUeXBlIH0gb2YgbWltZVR5cGVTaWduYXR1cmVzKSB7XG4gICAgaWYgKGltYWdlLmxlbmd0aCA+PSBieXRlcy5sZW5ndGggJiYgYnl0ZXMuZXZlcnkoKGJ5dGUsIGluZGV4KSA9PiBpbWFnZVtpbmRleF0gPT09IGJ5dGUpKSB7XG4gICAgICByZXR1cm4gbWltZVR5cGU7XG4gICAgfVxuICB9XG4gIHJldHVybiB2b2lkIDA7XG59XG5cbi8vIGNvcmUvcHJvbXB0L2RhdGEtY29udGVudC50c1xuaW1wb3J0IHtcbiAgY29udmVydEJhc2U2NFRvVWludDhBcnJheSxcbiAgY29udmVydFVpbnQ4QXJyYXlUb0Jhc2U2NFxufSBmcm9tIFwiQGFpLXNkay9wcm92aWRlci11dGlsc1wiO1xuXG4vLyBjb3JlL3Byb21wdC9pbnZhbGlkLWRhdGEtY29udGVudC1lcnJvci50c1xuaW1wb3J0IHsgQUlTREtFcnJvciBhcyBBSVNES0Vycm9yMyB9IGZyb20gXCJAYWktc2RrL3Byb3ZpZGVyXCI7XG52YXIgbmFtZTMgPSBcIkFJX0ludmFsaWREYXRhQ29udGVudEVycm9yXCI7XG52YXIgbWFya2VyMyA9IGB2ZXJjZWwuYWkuZXJyb3IuJHtuYW1lM31gO1xudmFyIHN5bWJvbDMgPSBTeW1ib2wuZm9yKG1hcmtlcjMpO1xudmFyIF9hMztcbnZhciBJbnZhbGlkRGF0YUNvbnRlbnRFcnJvciA9IGNsYXNzIGV4dGVuZHMgQUlTREtFcnJvcjMge1xuICBjb25zdHJ1Y3Rvcih7XG4gICAgY29udGVudCxcbiAgICBjYXVzZSxcbiAgICBtZXNzYWdlID0gYEludmFsaWQgZGF0YSBjb250ZW50LiBFeHBlY3RlZCBhIGJhc2U2NCBzdHJpbmcsIFVpbnQ4QXJyYXksIEFycmF5QnVmZmVyLCBvciBCdWZmZXIsIGJ1dCBnb3QgJHt0eXBlb2YgY29udGVudH0uYFxuICB9KSB7XG4gICAgc3VwZXIoeyBuYW1lOiBuYW1lMywgbWVzc2FnZSwgY2F1c2UgfSk7XG4gICAgdGhpc1tfYTNdID0gdHJ1ZTtcbiAgICB0aGlzLmNvbnRlbnQgPSBjb250ZW50O1xuICB9XG4gIHN0YXRpYyBpc0luc3RhbmNlKGVycm9yKSB7XG4gICAgcmV0dXJuIEFJU0RLRXJyb3IzLmhhc01hcmtlcihlcnJvciwgbWFya2VyMyk7XG4gIH1cbiAgLyoqXG4gICAqIEBkZXByZWNhdGVkIHVzZSBgaXNJbnN0YW5jZWAgaW5zdGVhZFxuICAgKi9cbiAgc3RhdGljIGlzSW52YWxpZERhdGFDb250ZW50RXJyb3IoZXJyb3IpIHtcbiAgICByZXR1cm4gZXJyb3IgaW5zdGFuY2VvZiBFcnJvciAmJiBlcnJvci5uYW1lID09PSBuYW1lMyAmJiBlcnJvci5jb250ZW50ICE9IG51bGw7XG4gIH1cbiAgLyoqXG4gICAqIEBkZXByZWNhdGVkIERvIG5vdCB1c2UgdGhpcyBtZXRob2QuIEl0IHdpbGwgYmUgcmVtb3ZlZCBpbiB0aGUgbmV4dCBtYWpvciB2ZXJzaW9uLlxuICAgKi9cbiAgdG9KU09OKCkge1xuICAgIHJldHVybiB7XG4gICAgICBuYW1lOiB0aGlzLm5hbWUsXG4gICAgICBtZXNzYWdlOiB0aGlzLm1lc3NhZ2UsXG4gICAgICBzdGFjazogdGhpcy5zdGFjayxcbiAgICAgIGNhdXNlOiB0aGlzLmNhdXNlLFxuICAgICAgY29udGVudDogdGhpcy5jb250ZW50XG4gICAgfTtcbiAgfVxufTtcbl9hMyA9IHN5bWJvbDM7XG5cbi8vIGNvcmUvcHJvbXB0L2RhdGEtY29udGVudC50c1xuZnVuY3Rpb24gY29udmVydERhdGFDb250ZW50VG9CYXNlNjRTdHJpbmcoY29udGVudCkge1xuICBpZiAodHlwZW9mIGNvbnRlbnQgPT09IFwic3RyaW5nXCIpIHtcbiAgICByZXR1cm4gY29udGVudDtcbiAgfVxuICBpZiAoY29udGVudCBpbnN0YW5jZW9mIEFycmF5QnVmZmVyKSB7XG4gICAgcmV0dXJuIGNvbnZlcnRVaW50OEFycmF5VG9CYXNlNjQobmV3IFVpbnQ4QXJyYXkoY29udGVudCkpO1xuICB9XG4gIHJldHVybiBjb252ZXJ0VWludDhBcnJheVRvQmFzZTY0KGNvbnRlbnQpO1xufVxuZnVuY3Rpb24gY29udmVydERhdGFDb250ZW50VG9VaW50OEFycmF5KGNvbnRlbnQpIHtcbiAgaWYgKGNvbnRlbnQgaW5zdGFuY2VvZiBVaW50OEFycmF5KSB7XG4gICAgcmV0dXJuIGNvbnRlbnQ7XG4gIH1cbiAgaWYgKHR5cGVvZiBjb250ZW50ID09PSBcInN0cmluZ1wiKSB7XG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiBjb252ZXJ0QmFzZTY0VG9VaW50OEFycmF5KGNvbnRlbnQpO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICB0aHJvdyBuZXcgSW52YWxpZERhdGFDb250ZW50RXJyb3Ioe1xuICAgICAgICBtZXNzYWdlOiBcIkludmFsaWQgZGF0YSBjb250ZW50LiBDb250ZW50IHN0cmluZyBpcyBub3QgYSBiYXNlNjQtZW5jb2RlZCBtZWRpYS5cIixcbiAgICAgICAgY29udGVudCxcbiAgICAgICAgY2F1c2U6IGVycm9yXG4gICAgICB9KTtcbiAgICB9XG4gIH1cbiAgaWYgKGNvbnRlbnQgaW5zdGFuY2VvZiBBcnJheUJ1ZmZlcikge1xuICAgIHJldHVybiBuZXcgVWludDhBcnJheShjb250ZW50KTtcbiAgfVxuICB0aHJvdyBuZXcgSW52YWxpZERhdGFDb250ZW50RXJyb3IoeyBjb250ZW50IH0pO1xufVxuZnVuY3Rpb24gY29udmVydFVpbnQ4QXJyYXlUb1RleHQodWludDhBcnJheSkge1xuICB0cnkge1xuICAgIHJldHVybiBuZXcgVGV4dERlY29kZXIoKS5kZWNvZGUodWludDhBcnJheSk7XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiRXJyb3IgZGVjb2RpbmcgVWludDhBcnJheSB0byB0ZXh0XCIpO1xuICB9XG59XG5cbi8vIGNvcmUvcHJvbXB0L2ludmFsaWQtbWVzc2FnZS1yb2xlLWVycm9yLnRzXG5pbXBvcnQgeyBBSVNES0Vycm9yIGFzIEFJU0RLRXJyb3I0IH0gZnJvbSBcIkBhaS1zZGsvcHJvdmlkZXJcIjtcbnZhciBuYW1lNCA9IFwiQUlfSW52YWxpZE1lc3NhZ2VSb2xlRXJyb3JcIjtcbnZhciBtYXJrZXI0ID0gYHZlcmNlbC5haS5lcnJvci4ke25hbWU0fWA7XG52YXIgc3ltYm9sNCA9IFN5bWJvbC5mb3IobWFya2VyNCk7XG52YXIgX2E0O1xudmFyIEludmFsaWRNZXNzYWdlUm9sZUVycm9yID0gY2xhc3MgZXh0ZW5kcyBBSVNES0Vycm9yNCB7XG4gIGNvbnN0cnVjdG9yKHtcbiAgICByb2xlLFxuICAgIG1lc3NhZ2UgPSBgSW52YWxpZCBtZXNzYWdlIHJvbGU6ICcke3JvbGV9Jy4gTXVzdCBiZSBvbmUgb2Y6IFwic3lzdGVtXCIsIFwidXNlclwiLCBcImFzc2lzdGFudFwiLCBcInRvb2xcIi5gXG4gIH0pIHtcbiAgICBzdXBlcih7IG5hbWU6IG5hbWU0LCBtZXNzYWdlIH0pO1xuICAgIHRoaXNbX2E0XSA9IHRydWU7XG4gICAgdGhpcy5yb2xlID0gcm9sZTtcbiAgfVxuICBzdGF0aWMgaXNJbnN0YW5jZShlcnJvcikge1xuICAgIHJldHVybiBBSVNES0Vycm9yNC5oYXNNYXJrZXIoZXJyb3IsIG1hcmtlcjQpO1xuICB9XG4gIC8qKlxuICAgKiBAZGVwcmVjYXRlZCB1c2UgYGlzSW5zdGFuY2VgIGluc3RlYWRcbiAgICovXG4gIHN0YXRpYyBpc0ludmFsaWRNZXNzYWdlUm9sZUVycm9yKGVycm9yKSB7XG4gICAgcmV0dXJuIGVycm9yIGluc3RhbmNlb2YgRXJyb3IgJiYgZXJyb3IubmFtZSA9PT0gbmFtZTQgJiYgdHlwZW9mIGVycm9yLnJvbGUgPT09IFwic3RyaW5nXCI7XG4gIH1cbiAgLyoqXG4gICAqIEBkZXByZWNhdGVkIERvIG5vdCB1c2UgdGhpcyBtZXRob2QuIEl0IHdpbGwgYmUgcmVtb3ZlZCBpbiB0aGUgbmV4dCBtYWpvciB2ZXJzaW9uLlxuICAgKi9cbiAgdG9KU09OKCkge1xuICAgIHJldHVybiB7XG4gICAgICBuYW1lOiB0aGlzLm5hbWUsXG4gICAgICBtZXNzYWdlOiB0aGlzLm1lc3NhZ2UsXG4gICAgICBzdGFjazogdGhpcy5zdGFjayxcbiAgICAgIHJvbGU6IHRoaXMucm9sZVxuICAgIH07XG4gIH1cbn07XG5fYTQgPSBzeW1ib2w0O1xuXG4vLyBjb3JlL3Byb21wdC9jb252ZXJ0LXRvLWxhbmd1YWdlLW1vZGVsLXByb21wdC50c1xuYXN5bmMgZnVuY3Rpb24gY29udmVydFRvTGFuZ3VhZ2VNb2RlbFByb21wdCh7XG4gIHByb21wdCxcbiAgbW9kZWxTdXBwb3J0c0ltYWdlVXJscyA9IHRydWUsXG4gIGRvd25sb2FkSW1wbGVtZW50YXRpb24gPSBkb3dubG9hZFxufSkge1xuICBjb25zdCBsYW5ndWFnZU1vZGVsTWVzc2FnZXMgPSBbXTtcbiAgaWYgKHByb21wdC5zeXN0ZW0gIT0gbnVsbCkge1xuICAgIGxhbmd1YWdlTW9kZWxNZXNzYWdlcy5wdXNoKHsgcm9sZTogXCJzeXN0ZW1cIiwgY29udGVudDogcHJvbXB0LnN5c3RlbSB9KTtcbiAgfVxuICBjb25zdCBkb3dubG9hZGVkSW1hZ2VzID0gbW9kZWxTdXBwb3J0c0ltYWdlVXJscyB8fCBwcm9tcHQubWVzc2FnZXMgPT0gbnVsbCA/IG51bGwgOiBhd2FpdCBkb3dubG9hZEltYWdlcyhwcm9tcHQubWVzc2FnZXMsIGRvd25sb2FkSW1wbGVtZW50YXRpb24pO1xuICBjb25zdCBwcm9tcHRUeXBlID0gcHJvbXB0LnR5cGU7XG4gIHN3aXRjaCAocHJvbXB0VHlwZSkge1xuICAgIGNhc2UgXCJwcm9tcHRcIjoge1xuICAgICAgbGFuZ3VhZ2VNb2RlbE1lc3NhZ2VzLnB1c2goe1xuICAgICAgICByb2xlOiBcInVzZXJcIixcbiAgICAgICAgY29udGVudDogW3sgdHlwZTogXCJ0ZXh0XCIsIHRleHQ6IHByb21wdC5wcm9tcHQgfV1cbiAgICAgIH0pO1xuICAgICAgYnJlYWs7XG4gICAgfVxuICAgIGNhc2UgXCJtZXNzYWdlc1wiOiB7XG4gICAgICBsYW5ndWFnZU1vZGVsTWVzc2FnZXMucHVzaChcbiAgICAgICAgLi4ucHJvbXB0Lm1lc3NhZ2VzLm1hcChcbiAgICAgICAgICAobWVzc2FnZSkgPT4gY29udmVydFRvTGFuZ3VhZ2VNb2RlbE1lc3NhZ2UobWVzc2FnZSwgZG93bmxvYWRlZEltYWdlcylcbiAgICAgICAgKVxuICAgICAgKTtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBkZWZhdWx0OiB7XG4gICAgICBjb25zdCBfZXhoYXVzdGl2ZUNoZWNrID0gcHJvbXB0VHlwZTtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgVW5zdXBwb3J0ZWQgcHJvbXB0IHR5cGU6ICR7X2V4aGF1c3RpdmVDaGVja31gKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGxhbmd1YWdlTW9kZWxNZXNzYWdlcztcbn1cbmZ1bmN0aW9uIGNvbnZlcnRUb0xhbmd1YWdlTW9kZWxNZXNzYWdlKG1lc3NhZ2UsIGRvd25sb2FkZWRJbWFnZXMpIHtcbiAgY29uc3Qgcm9sZSA9IG1lc3NhZ2Uucm9sZTtcbiAgc3dpdGNoIChyb2xlKSB7XG4gICAgY2FzZSBcInN5c3RlbVwiOiB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICByb2xlOiBcInN5c3RlbVwiLFxuICAgICAgICBjb250ZW50OiBtZXNzYWdlLmNvbnRlbnQsXG4gICAgICAgIHByb3ZpZGVyTWV0YWRhdGE6IG1lc3NhZ2UuZXhwZXJpbWVudGFsX3Byb3ZpZGVyTWV0YWRhdGFcbiAgICAgIH07XG4gICAgfVxuICAgIGNhc2UgXCJ1c2VyXCI6IHtcbiAgICAgIGlmICh0eXBlb2YgbWVzc2FnZS5jb250ZW50ID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgcm9sZTogXCJ1c2VyXCIsXG4gICAgICAgICAgY29udGVudDogW3sgdHlwZTogXCJ0ZXh0XCIsIHRleHQ6IG1lc3NhZ2UuY29udGVudCB9XSxcbiAgICAgICAgICBwcm92aWRlck1ldGFkYXRhOiBtZXNzYWdlLmV4cGVyaW1lbnRhbF9wcm92aWRlck1ldGFkYXRhXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgICByZXR1cm4ge1xuICAgICAgICByb2xlOiBcInVzZXJcIixcbiAgICAgICAgY29udGVudDogbWVzc2FnZS5jb250ZW50Lm1hcChcbiAgICAgICAgICAocGFydCkgPT4ge1xuICAgICAgICAgICAgdmFyIF9hMTIsIF9iLCBfYztcbiAgICAgICAgICAgIHN3aXRjaCAocGFydC50eXBlKSB7XG4gICAgICAgICAgICAgIGNhc2UgXCJ0ZXh0XCI6IHtcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgdHlwZTogXCJ0ZXh0XCIsXG4gICAgICAgICAgICAgICAgICB0ZXh0OiBwYXJ0LnRleHQsXG4gICAgICAgICAgICAgICAgICBwcm92aWRlck1ldGFkYXRhOiBwYXJ0LmV4cGVyaW1lbnRhbF9wcm92aWRlck1ldGFkYXRhXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBjYXNlIFwiaW1hZ2VcIjoge1xuICAgICAgICAgICAgICAgIGlmIChwYXJ0LmltYWdlIGluc3RhbmNlb2YgVVJMKSB7XG4gICAgICAgICAgICAgICAgICBpZiAoZG93bmxvYWRlZEltYWdlcyA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgICAgdHlwZTogXCJpbWFnZVwiLFxuICAgICAgICAgICAgICAgICAgICAgIGltYWdlOiBwYXJ0LmltYWdlLFxuICAgICAgICAgICAgICAgICAgICAgIG1pbWVUeXBlOiBwYXJ0Lm1pbWVUeXBlLFxuICAgICAgICAgICAgICAgICAgICAgIHByb3ZpZGVyTWV0YWRhdGE6IHBhcnQuZXhwZXJpbWVudGFsX3Byb3ZpZGVyTWV0YWRhdGFcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGRvd25sb2FkZWRJbWFnZSA9IGRvd25sb2FkZWRJbWFnZXNbcGFydC5pbWFnZS50b1N0cmluZygpXTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgICB0eXBlOiBcImltYWdlXCIsXG4gICAgICAgICAgICAgICAgICAgICAgaW1hZ2U6IGRvd25sb2FkZWRJbWFnZS5kYXRhLFxuICAgICAgICAgICAgICAgICAgICAgIG1pbWVUeXBlOiAoX2ExMiA9IHBhcnQubWltZVR5cGUpICE9IG51bGwgPyBfYTEyIDogZG93bmxvYWRlZEltYWdlLm1pbWVUeXBlLFxuICAgICAgICAgICAgICAgICAgICAgIHByb3ZpZGVyTWV0YWRhdGE6IHBhcnQuZXhwZXJpbWVudGFsX3Byb3ZpZGVyTWV0YWRhdGFcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBwYXJ0LmltYWdlID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCB1cmwgPSBuZXcgVVJMKHBhcnQuaW1hZ2UpO1xuICAgICAgICAgICAgICAgICAgICBzd2l0Y2ggKHVybC5wcm90b2NvbCkge1xuICAgICAgICAgICAgICAgICAgICAgIGNhc2UgXCJodHRwOlwiOlxuICAgICAgICAgICAgICAgICAgICAgIGNhc2UgXCJodHRwczpcIjoge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGRvd25sb2FkZWRJbWFnZXMgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6IFwiaW1hZ2VcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbWFnZTogdXJsLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1pbWVUeXBlOiBwYXJ0Lm1pbWVUeXBlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHByb3ZpZGVyTWV0YWRhdGE6IHBhcnQuZXhwZXJpbWVudGFsX3Byb3ZpZGVyTWV0YWRhdGFcbiAgICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGRvd25sb2FkZWRJbWFnZSA9IGRvd25sb2FkZWRJbWFnZXNbcGFydC5pbWFnZV07XG4gICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogXCJpbWFnZVwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGltYWdlOiBkb3dubG9hZGVkSW1hZ2UuZGF0YSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtaW1lVHlwZTogKF9iID0gcGFydC5taW1lVHlwZSkgIT0gbnVsbCA/IF9iIDogZG93bmxvYWRlZEltYWdlLm1pbWVUeXBlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHByb3ZpZGVyTWV0YWRhdGE6IHBhcnQuZXhwZXJpbWVudGFsX3Byb3ZpZGVyTWV0YWRhdGFcbiAgICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgY2FzZSBcImRhdGE6XCI6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IFtoZWFkZXIsIGJhc2U2NENvbnRlbnRdID0gcGFydC5pbWFnZS5zcGxpdChcIixcIik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IG1pbWVUeXBlID0gaGVhZGVyLnNwbGl0KFwiO1wiKVswXS5zcGxpdChcIjpcIilbMV07XG4gICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChtaW1lVHlwZSA9PSBudWxsIHx8IGJhc2U2NENvbnRlbnQgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgZGF0YSBVUkwgZm9ybWF0XCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogXCJpbWFnZVwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGltYWdlOiBjb252ZXJ0RGF0YUNvbnRlbnRUb1VpbnQ4QXJyYXkoYmFzZTY0Q29udGVudCksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbWltZVR5cGUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcHJvdmlkZXJNZXRhZGF0YTogcGFydC5leHBlcmltZW50YWxfcHJvdmlkZXJNZXRhZGF0YVxuICAgICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGBFcnJvciBwcm9jZXNzaW5nIGRhdGEgVVJMOiAke2dldEVycm9yTWVzc2FnZTIoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKX1gXG4gICAgICAgICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgIGRlZmF1bHQ6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICAgICAgICAgICAgICAgICAgYFVuc3VwcG9ydGVkIFVSTCBwcm90b2NvbDogJHt1cmwucHJvdG9jb2x9YFxuICAgICAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIH0gY2F0Y2ggKF9pZ25vcmVkKSB7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnN0IGltYWdlVWludDggPSBjb252ZXJ0RGF0YUNvbnRlbnRUb1VpbnQ4QXJyYXkocGFydC5pbWFnZSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgIHR5cGU6IFwiaW1hZ2VcIixcbiAgICAgICAgICAgICAgICAgIGltYWdlOiBpbWFnZVVpbnQ4LFxuICAgICAgICAgICAgICAgICAgbWltZVR5cGU6IChfYyA9IHBhcnQubWltZVR5cGUpICE9IG51bGwgPyBfYyA6IGRldGVjdEltYWdlTWltZVR5cGUoaW1hZ2VVaW50OCksXG4gICAgICAgICAgICAgICAgICBwcm92aWRlck1ldGFkYXRhOiBwYXJ0LmV4cGVyaW1lbnRhbF9wcm92aWRlck1ldGFkYXRhXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgKSxcbiAgICAgICAgcHJvdmlkZXJNZXRhZGF0YTogbWVzc2FnZS5leHBlcmltZW50YWxfcHJvdmlkZXJNZXRhZGF0YVxuICAgICAgfTtcbiAgICB9XG4gICAgY2FzZSBcImFzc2lzdGFudFwiOiB7XG4gICAgICBpZiAodHlwZW9mIG1lc3NhZ2UuY29udGVudCA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHJvbGU6IFwiYXNzaXN0YW50XCIsXG4gICAgICAgICAgY29udGVudDogW3sgdHlwZTogXCJ0ZXh0XCIsIHRleHQ6IG1lc3NhZ2UuY29udGVudCB9XSxcbiAgICAgICAgICBwcm92aWRlck1ldGFkYXRhOiBtZXNzYWdlLmV4cGVyaW1lbnRhbF9wcm92aWRlck1ldGFkYXRhXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgICByZXR1cm4ge1xuICAgICAgICByb2xlOiBcImFzc2lzdGFudFwiLFxuICAgICAgICBjb250ZW50OiBtZXNzYWdlLmNvbnRlbnQuZmlsdGVyKFxuICAgICAgICAgIC8vIHJlbW92ZSBlbXB0eSB0ZXh0IHBhcnRzOlxuICAgICAgICAgIChwYXJ0KSA9PiBwYXJ0LnR5cGUgIT09IFwidGV4dFwiIHx8IHBhcnQudGV4dCAhPT0gXCJcIlxuICAgICAgICApLFxuICAgICAgICBwcm92aWRlck1ldGFkYXRhOiBtZXNzYWdlLmV4cGVyaW1lbnRhbF9wcm92aWRlck1ldGFkYXRhXG4gICAgICB9O1xuICAgIH1cbiAgICBjYXNlIFwidG9vbFwiOiB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICByb2xlOiBcInRvb2xcIixcbiAgICAgICAgY29udGVudDogbWVzc2FnZS5jb250ZW50Lm1hcCgocGFydCkgPT4gKHtcbiAgICAgICAgICB0eXBlOiBcInRvb2wtcmVzdWx0XCIsXG4gICAgICAgICAgdG9vbENhbGxJZDogcGFydC50b29sQ2FsbElkLFxuICAgICAgICAgIHRvb2xOYW1lOiBwYXJ0LnRvb2xOYW1lLFxuICAgICAgICAgIHJlc3VsdDogcGFydC5yZXN1bHQsXG4gICAgICAgICAgcHJvdmlkZXJNZXRhZGF0YTogcGFydC5leHBlcmltZW50YWxfcHJvdmlkZXJNZXRhZGF0YVxuICAgICAgICB9KSksXG4gICAgICAgIHByb3ZpZGVyTWV0YWRhdGE6IG1lc3NhZ2UuZXhwZXJpbWVudGFsX3Byb3ZpZGVyTWV0YWRhdGFcbiAgICAgIH07XG4gICAgfVxuICAgIGRlZmF1bHQ6IHtcbiAgICAgIGNvbnN0IF9leGhhdXN0aXZlQ2hlY2sgPSByb2xlO1xuICAgICAgdGhyb3cgbmV3IEludmFsaWRNZXNzYWdlUm9sZUVycm9yKHsgcm9sZTogX2V4aGF1c3RpdmVDaGVjayB9KTtcbiAgICB9XG4gIH1cbn1cbmFzeW5jIGZ1bmN0aW9uIGRvd25sb2FkSW1hZ2VzKG1lc3NhZ2VzLCBkb3dubG9hZEltcGxlbWVudGF0aW9uKSB7XG4gIGNvbnN0IHVybHMgPSBtZXNzYWdlcy5maWx0ZXIoKG1lc3NhZ2UpID0+IG1lc3NhZ2Uucm9sZSA9PT0gXCJ1c2VyXCIpLm1hcCgobWVzc2FnZSkgPT4gbWVzc2FnZS5jb250ZW50KS5maWx0ZXIoXG4gICAgKGNvbnRlbnQpID0+IEFycmF5LmlzQXJyYXkoY29udGVudClcbiAgKS5mbGF0KCkuZmlsdGVyKChwYXJ0KSA9PiBwYXJ0LnR5cGUgPT09IFwiaW1hZ2VcIikubWFwKChwYXJ0KSA9PiBwYXJ0LmltYWdlKS5tYXAoXG4gICAgKHBhcnQpID0+IChcbiAgICAgIC8vIHN1cHBvcnQgc3RyaW5nIHVybHMgaW4gaW1hZ2UgcGFydHM6XG4gICAgICB0eXBlb2YgcGFydCA9PT0gXCJzdHJpbmdcIiAmJiAocGFydC5zdGFydHNXaXRoKFwiaHR0cDpcIikgfHwgcGFydC5zdGFydHNXaXRoKFwiaHR0cHM6XCIpKSA/IG5ldyBVUkwocGFydCkgOiBwYXJ0XG4gICAgKVxuICApLmZpbHRlcigoaW1hZ2UpID0+IGltYWdlIGluc3RhbmNlb2YgVVJMKTtcbiAgY29uc3QgZG93bmxvYWRlZEltYWdlcyA9IGF3YWl0IFByb21pc2UuYWxsKFxuICAgIHVybHMubWFwKGFzeW5jICh1cmwpID0+ICh7XG4gICAgICB1cmwsXG4gICAgICBkYXRhOiBhd2FpdCBkb3dubG9hZEltcGxlbWVudGF0aW9uKHsgdXJsIH0pXG4gICAgfSkpXG4gICk7XG4gIHJldHVybiBPYmplY3QuZnJvbUVudHJpZXMoXG4gICAgZG93bmxvYWRlZEltYWdlcy5tYXAoKHsgdXJsLCBkYXRhIH0pID0+IFt1cmwudG9TdHJpbmcoKSwgZGF0YV0pXG4gICk7XG59XG5cbi8vIGNvcmUvcHJvbXB0L2dldC12YWxpZGF0ZWQtcHJvbXB0LnRzXG5pbXBvcnQgeyBJbnZhbGlkUHJvbXB0RXJyb3IgfSBmcm9tIFwiQGFpLXNkay9wcm92aWRlclwiO1xuZnVuY3Rpb24gZ2V0VmFsaWRhdGVkUHJvbXB0KHByb21wdCkge1xuICBpZiAocHJvbXB0LnByb21wdCA9PSBudWxsICYmIHByb21wdC5tZXNzYWdlcyA9PSBudWxsKSB7XG4gICAgdGhyb3cgbmV3IEludmFsaWRQcm9tcHRFcnJvcih7XG4gICAgICBwcm9tcHQsXG4gICAgICBtZXNzYWdlOiBcInByb21wdCBvciBtZXNzYWdlcyBtdXN0IGJlIGRlZmluZWRcIlxuICAgIH0pO1xuICB9XG4gIGlmIChwcm9tcHQucHJvbXB0ICE9IG51bGwgJiYgcHJvbXB0Lm1lc3NhZ2VzICE9IG51bGwpIHtcbiAgICB0aHJvdyBuZXcgSW52YWxpZFByb21wdEVycm9yKHtcbiAgICAgIHByb21wdCxcbiAgICAgIG1lc3NhZ2U6IFwicHJvbXB0IGFuZCBtZXNzYWdlcyBjYW5ub3QgYmUgZGVmaW5lZCBhdCB0aGUgc2FtZSB0aW1lXCJcbiAgICB9KTtcbiAgfVxuICBpZiAocHJvbXB0Lm1lc3NhZ2VzICE9IG51bGwpIHtcbiAgICBmb3IgKGNvbnN0IG1lc3NhZ2Ugb2YgcHJvbXB0Lm1lc3NhZ2VzKSB7XG4gICAgICBpZiAobWVzc2FnZS5yb2xlID09PSBcInN5c3RlbVwiICYmIHR5cGVvZiBtZXNzYWdlLmNvbnRlbnQgIT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgdGhyb3cgbmV3IEludmFsaWRQcm9tcHRFcnJvcih7XG4gICAgICAgICAgcHJvbXB0LFxuICAgICAgICAgIG1lc3NhZ2U6IFwic3lzdGVtIG1lc3NhZ2UgY29udGVudCBtdXN0IGJlIGEgc3RyaW5nXCJcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiBwcm9tcHQucHJvbXB0ICE9IG51bGwgPyB7XG4gICAgdHlwZTogXCJwcm9tcHRcIixcbiAgICBwcm9tcHQ6IHByb21wdC5wcm9tcHQsXG4gICAgbWVzc2FnZXM6IHZvaWQgMCxcbiAgICBzeXN0ZW06IHByb21wdC5zeXN0ZW1cbiAgfSA6IHtcbiAgICB0eXBlOiBcIm1lc3NhZ2VzXCIsXG4gICAgcHJvbXB0OiB2b2lkIDAsXG4gICAgbWVzc2FnZXM6IHByb21wdC5tZXNzYWdlcyxcbiAgICAvLyBvbmx5IHBvc3NpYmxlIGNhc2UgYmMgb2YgY2hlY2tzIGFib3ZlXG4gICAgc3lzdGVtOiBwcm9tcHQuc3lzdGVtXG4gIH07XG59XG5cbi8vIGVycm9ycy9pbnZhbGlkLWFyZ3VtZW50LWVycm9yLnRzXG5pbXBvcnQgeyBBSVNES0Vycm9yIGFzIEFJU0RLRXJyb3I1IH0gZnJvbSBcIkBhaS1zZGsvcHJvdmlkZXJcIjtcbnZhciBuYW1lNSA9IFwiQUlfSW52YWxpZEFyZ3VtZW50RXJyb3JcIjtcbnZhciBtYXJrZXI1ID0gYHZlcmNlbC5haS5lcnJvci4ke25hbWU1fWA7XG52YXIgc3ltYm9sNSA9IFN5bWJvbC5mb3IobWFya2VyNSk7XG52YXIgX2E1O1xudmFyIEludmFsaWRBcmd1bWVudEVycm9yID0gY2xhc3MgZXh0ZW5kcyBBSVNES0Vycm9yNSB7XG4gIGNvbnN0cnVjdG9yKHtcbiAgICBwYXJhbWV0ZXIsXG4gICAgdmFsdWUsXG4gICAgbWVzc2FnZVxuICB9KSB7XG4gICAgc3VwZXIoe1xuICAgICAgbmFtZTogbmFtZTUsXG4gICAgICBtZXNzYWdlOiBgSW52YWxpZCBhcmd1bWVudCBmb3IgcGFyYW1ldGVyICR7cGFyYW1ldGVyfTogJHttZXNzYWdlfWBcbiAgICB9KTtcbiAgICB0aGlzW19hNV0gPSB0cnVlO1xuICAgIHRoaXMucGFyYW1ldGVyID0gcGFyYW1ldGVyO1xuICAgIHRoaXMudmFsdWUgPSB2YWx1ZTtcbiAgfVxuICBzdGF0aWMgaXNJbnN0YW5jZShlcnJvcikge1xuICAgIHJldHVybiBBSVNES0Vycm9yNS5oYXNNYXJrZXIoZXJyb3IsIG1hcmtlcjUpO1xuICB9XG4gIC8qKlxuICAgKiBAZGVwcmVjYXRlZCB1c2UgYGlzSW5zdGFuY2VgIGluc3RlYWRcbiAgICovXG4gIHN0YXRpYyBpc0ludmFsaWRBcmd1bWVudEVycm9yKGVycm9yKSB7XG4gICAgcmV0dXJuIGVycm9yIGluc3RhbmNlb2YgRXJyb3IgJiYgZXJyb3IubmFtZSA9PT0gbmFtZTUgJiYgdHlwZW9mIGVycm9yLnBhcmFtZXRlciA9PT0gXCJzdHJpbmdcIiAmJiB0eXBlb2YgZXJyb3IudmFsdWUgPT09IFwic3RyaW5nXCI7XG4gIH1cbiAgdG9KU09OKCkge1xuICAgIHJldHVybiB7XG4gICAgICBuYW1lOiB0aGlzLm5hbWUsXG4gICAgICBtZXNzYWdlOiB0aGlzLm1lc3NhZ2UsXG4gICAgICBzdGFjazogdGhpcy5zdGFjayxcbiAgICAgIHBhcmFtZXRlcjogdGhpcy5wYXJhbWV0ZXIsXG4gICAgICB2YWx1ZTogdGhpcy52YWx1ZVxuICAgIH07XG4gIH1cbn07XG5fYTUgPSBzeW1ib2w1O1xuXG4vLyBjb3JlL3Byb21wdC9wcmVwYXJlLWNhbGwtc2V0dGluZ3MudHNcbmZ1bmN0aW9uIHByZXBhcmVDYWxsU2V0dGluZ3Moe1xuICBtYXhUb2tlbnMsXG4gIHRlbXBlcmF0dXJlLFxuICB0b3BQLFxuICBwcmVzZW5jZVBlbmFsdHksXG4gIGZyZXF1ZW5jeVBlbmFsdHksXG4gIHN0b3BTZXF1ZW5jZXMsXG4gIHNlZWQsXG4gIG1heFJldHJpZXNcbn0pIHtcbiAgaWYgKG1heFRva2VucyAhPSBudWxsKSB7XG4gICAgaWYgKCFOdW1iZXIuaXNJbnRlZ2VyKG1heFRva2VucykpIHtcbiAgICAgIHRocm93IG5ldyBJbnZhbGlkQXJndW1lbnRFcnJvcih7XG4gICAgICAgIHBhcmFtZXRlcjogXCJtYXhUb2tlbnNcIixcbiAgICAgICAgdmFsdWU6IG1heFRva2VucyxcbiAgICAgICAgbWVzc2FnZTogXCJtYXhUb2tlbnMgbXVzdCBiZSBhbiBpbnRlZ2VyXCJcbiAgICAgIH0pO1xuICAgIH1cbiAgICBpZiAobWF4VG9rZW5zIDwgMSkge1xuICAgICAgdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudEVycm9yKHtcbiAgICAgICAgcGFyYW1ldGVyOiBcIm1heFRva2Vuc1wiLFxuICAgICAgICB2YWx1ZTogbWF4VG9rZW5zLFxuICAgICAgICBtZXNzYWdlOiBcIm1heFRva2VucyBtdXN0IGJlID49IDFcIlxuICAgICAgfSk7XG4gICAgfVxuICB9XG4gIGlmICh0ZW1wZXJhdHVyZSAhPSBudWxsKSB7XG4gICAgaWYgKHR5cGVvZiB0ZW1wZXJhdHVyZSAhPT0gXCJudW1iZXJcIikge1xuICAgICAgdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudEVycm9yKHtcbiAgICAgICAgcGFyYW1ldGVyOiBcInRlbXBlcmF0dXJlXCIsXG4gICAgICAgIHZhbHVlOiB0ZW1wZXJhdHVyZSxcbiAgICAgICAgbWVzc2FnZTogXCJ0ZW1wZXJhdHVyZSBtdXN0IGJlIGEgbnVtYmVyXCJcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuICBpZiAodG9wUCAhPSBudWxsKSB7XG4gICAgaWYgKHR5cGVvZiB0b3BQICE9PSBcIm51bWJlclwiKSB7XG4gICAgICB0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50RXJyb3Ioe1xuICAgICAgICBwYXJhbWV0ZXI6IFwidG9wUFwiLFxuICAgICAgICB2YWx1ZTogdG9wUCxcbiAgICAgICAgbWVzc2FnZTogXCJ0b3BQIG11c3QgYmUgYSBudW1iZXJcIlxuICAgICAgfSk7XG4gICAgfVxuICB9XG4gIGlmIChwcmVzZW5jZVBlbmFsdHkgIT0gbnVsbCkge1xuICAgIGlmICh0eXBlb2YgcHJlc2VuY2VQZW5hbHR5ICE9PSBcIm51bWJlclwiKSB7XG4gICAgICB0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50RXJyb3Ioe1xuICAgICAgICBwYXJhbWV0ZXI6IFwicHJlc2VuY2VQZW5hbHR5XCIsXG4gICAgICAgIHZhbHVlOiBwcmVzZW5jZVBlbmFsdHksXG4gICAgICAgIG1lc3NhZ2U6IFwicHJlc2VuY2VQZW5hbHR5IG11c3QgYmUgYSBudW1iZXJcIlxuICAgICAgfSk7XG4gICAgfVxuICB9XG4gIGlmIChmcmVxdWVuY3lQZW5hbHR5ICE9IG51bGwpIHtcbiAgICBpZiAodHlwZW9mIGZyZXF1ZW5jeVBlbmFsdHkgIT09IFwibnVtYmVyXCIpIHtcbiAgICAgIHRocm93IG5ldyBJbnZhbGlkQXJndW1lbnRFcnJvcih7XG4gICAgICAgIHBhcmFtZXRlcjogXCJmcmVxdWVuY3lQZW5hbHR5XCIsXG4gICAgICAgIHZhbHVlOiBmcmVxdWVuY3lQZW5hbHR5LFxuICAgICAgICBtZXNzYWdlOiBcImZyZXF1ZW5jeVBlbmFsdHkgbXVzdCBiZSBhIG51bWJlclwiXG4gICAgICB9KTtcbiAgICB9XG4gIH1cbiAgaWYgKHNlZWQgIT0gbnVsbCkge1xuICAgIGlmICghTnVtYmVyLmlzSW50ZWdlcihzZWVkKSkge1xuICAgICAgdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudEVycm9yKHtcbiAgICAgICAgcGFyYW1ldGVyOiBcInNlZWRcIixcbiAgICAgICAgdmFsdWU6IHNlZWQsXG4gICAgICAgIG1lc3NhZ2U6IFwic2VlZCBtdXN0IGJlIGFuIGludGVnZXJcIlxuICAgICAgfSk7XG4gICAgfVxuICB9XG4gIGlmIChtYXhSZXRyaWVzICE9IG51bGwpIHtcbiAgICBpZiAoIU51bWJlci5pc0ludGVnZXIobWF4UmV0cmllcykpIHtcbiAgICAgIHRocm93IG5ldyBJbnZhbGlkQXJndW1lbnRFcnJvcih7XG4gICAgICAgIHBhcmFtZXRlcjogXCJtYXhSZXRyaWVzXCIsXG4gICAgICAgIHZhbHVlOiBtYXhSZXRyaWVzLFxuICAgICAgICBtZXNzYWdlOiBcIm1heFJldHJpZXMgbXVzdCBiZSBhbiBpbnRlZ2VyXCJcbiAgICAgIH0pO1xuICAgIH1cbiAgICBpZiAobWF4UmV0cmllcyA8IDApIHtcbiAgICAgIHRocm93IG5ldyBJbnZhbGlkQXJndW1lbnRFcnJvcih7XG4gICAgICAgIHBhcmFtZXRlcjogXCJtYXhSZXRyaWVzXCIsXG4gICAgICAgIHZhbHVlOiBtYXhSZXRyaWVzLFxuICAgICAgICBtZXNzYWdlOiBcIm1heFJldHJpZXMgbXVzdCBiZSA+PSAwXCJcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuICByZXR1cm4ge1xuICAgIG1heFRva2VucyxcbiAgICB0ZW1wZXJhdHVyZTogdGVtcGVyYXR1cmUgIT0gbnVsbCA/IHRlbXBlcmF0dXJlIDogMCxcbiAgICB0b3BQLFxuICAgIHByZXNlbmNlUGVuYWx0eSxcbiAgICBmcmVxdWVuY3lQZW5hbHR5LFxuICAgIHN0b3BTZXF1ZW5jZXM6IHN0b3BTZXF1ZW5jZXMgIT0gbnVsbCAmJiBzdG9wU2VxdWVuY2VzLmxlbmd0aCA+IDAgPyBzdG9wU2VxdWVuY2VzIDogdm9pZCAwLFxuICAgIHNlZWQsXG4gICAgbWF4UmV0cmllczogbWF4UmV0cmllcyAhPSBudWxsID8gbWF4UmV0cmllcyA6IDJcbiAgfTtcbn1cblxuLy8gY29yZS90eXBlcy90b2tlbi11c2FnZS50c1xuZnVuY3Rpb24gY2FsY3VsYXRlQ29tcGxldGlvblRva2VuVXNhZ2UodXNhZ2UpIHtcbiAgcmV0dXJuIHtcbiAgICBwcm9tcHRUb2tlbnM6IHVzYWdlLnByb21wdFRva2VucyxcbiAgICBjb21wbGV0aW9uVG9rZW5zOiB1c2FnZS5jb21wbGV0aW9uVG9rZW5zLFxuICAgIHRvdGFsVG9rZW5zOiB1c2FnZS5wcm9tcHRUb2tlbnMgKyB1c2FnZS5jb21wbGV0aW9uVG9rZW5zXG4gIH07XG59XG5cbi8vIGNvcmUvdXRpbC9wcmVwYXJlLXJlc3BvbnNlLWhlYWRlcnMudHNcbmZ1bmN0aW9uIHByZXBhcmVSZXNwb25zZUhlYWRlcnMoaW5pdCwge1xuICBjb250ZW50VHlwZSxcbiAgZGF0YVN0cmVhbVZlcnNpb25cbn0pIHtcbiAgdmFyIF9hMTI7XG4gIGNvbnN0IGhlYWRlcnMgPSBuZXcgSGVhZGVycygoX2ExMiA9IGluaXQgPT0gbnVsbCA/IHZvaWQgMCA6IGluaXQuaGVhZGVycykgIT0gbnVsbCA/IF9hMTIgOiB7fSk7XG4gIGlmICghaGVhZGVycy5oYXMoXCJDb250ZW50LVR5cGVcIikpIHtcbiAgICBoZWFkZXJzLnNldChcIkNvbnRlbnQtVHlwZVwiLCBjb250ZW50VHlwZSk7XG4gIH1cbiAgaWYgKGRhdGFTdHJlYW1WZXJzaW9uICE9PSB2b2lkIDApIHtcbiAgICBoZWFkZXJzLnNldChcIlgtVmVyY2VsLUFJLURhdGEtU3RyZWFtXCIsIGRhdGFTdHJlYW1WZXJzaW9uKTtcbiAgfVxuICByZXR1cm4gaGVhZGVycztcbn1cblxuLy8gY29yZS9nZW5lcmF0ZS1vYmplY3QvaW5qZWN0LWpzb24tc2NoZW1hLWludG8tc3lzdGVtLnRzXG52YXIgREVGQVVMVF9TQ0hFTUFfUFJFRklYID0gXCJKU09OIHNjaGVtYTpcIjtcbnZhciBERUZBVUxUX1NDSEVNQV9TVUZGSVggPSBcIllvdSBNVVNUIGFuc3dlciB3aXRoIGEgSlNPTiBvYmplY3QgdGhhdCBtYXRjaGVzIHRoZSBKU09OIHNjaGVtYSBhYm92ZS5cIjtcbmZ1bmN0aW9uIGluamVjdEpzb25TY2hlbWFJbnRvU3lzdGVtKHtcbiAgc3lzdGVtLFxuICBzY2hlbWEsXG4gIHNjaGVtYVByZWZpeCA9IERFRkFVTFRfU0NIRU1BX1BSRUZJWCxcbiAgc2NoZW1hU3VmZml4ID0gREVGQVVMVF9TQ0hFTUFfU1VGRklYXG59KSB7XG4gIHJldHVybiBbXG4gICAgc3lzdGVtLFxuICAgIHN5c3RlbSAhPSBudWxsID8gXCJcIiA6IG51bGwsXG4gICAgLy8gYWRkIGEgbmV3bGluZSBpZiBzeXN0ZW0gaXMgbm90IG51bGxcbiAgICBzY2hlbWFQcmVmaXgsXG4gICAgSlNPTi5zdHJpbmdpZnkoc2NoZW1hKSxcbiAgICBzY2hlbWFTdWZmaXhcbiAgXS5maWx0ZXIoKGxpbmUpID0+IGxpbmUgIT0gbnVsbCkuam9pbihcIlxcblwiKTtcbn1cblxuLy8gY29yZS9nZW5lcmF0ZS1vYmplY3Qvbm8tb2JqZWN0LWdlbmVyYXRlZC1lcnJvci50c1xuaW1wb3J0IHsgQUlTREtFcnJvciBhcyBBSVNES0Vycm9yNiB9IGZyb20gXCJAYWktc2RrL3Byb3ZpZGVyXCI7XG52YXIgbmFtZTYgPSBcIkFJX05vT2JqZWN0R2VuZXJhdGVkRXJyb3JcIjtcbnZhciBtYXJrZXI2ID0gYHZlcmNlbC5haS5lcnJvci4ke25hbWU2fWA7XG52YXIgc3ltYm9sNiA9IFN5bWJvbC5mb3IobWFya2VyNik7XG52YXIgX2E2O1xudmFyIE5vT2JqZWN0R2VuZXJhdGVkRXJyb3IgPSBjbGFzcyBleHRlbmRzIEFJU0RLRXJyb3I2IHtcbiAgLy8gdXNlZCBpbiBpc0luc3RhbmNlXG4gIGNvbnN0cnVjdG9yKHsgbWVzc2FnZSA9IFwiTm8gb2JqZWN0IGdlbmVyYXRlZC5cIiB9ID0ge30pIHtcbiAgICBzdXBlcih7IG5hbWU6IG5hbWU2LCBtZXNzYWdlIH0pO1xuICAgIHRoaXNbX2E2XSA9IHRydWU7XG4gIH1cbiAgc3RhdGljIGlzSW5zdGFuY2UoZXJyb3IpIHtcbiAgICByZXR1cm4gQUlTREtFcnJvcjYuaGFzTWFya2VyKGVycm9yLCBtYXJrZXI2KTtcbiAgfVxuICAvKipcbiAgICogQGRlcHJlY2F0ZWQgVXNlIGlzSW5zdGFuY2UgaW5zdGVhZC5cbiAgICovXG4gIHN0YXRpYyBpc05vT2JqZWN0R2VuZXJhdGVkRXJyb3IoZXJyb3IpIHtcbiAgICByZXR1cm4gZXJyb3IgaW5zdGFuY2VvZiBFcnJvciAmJiBlcnJvci5uYW1lID09PSBuYW1lNjtcbiAgfVxuICAvKipcbiAgICogQGRlcHJlY2F0ZWQgRG8gbm90IHVzZSB0aGlzIG1ldGhvZC4gSXQgd2lsbCBiZSByZW1vdmVkIGluIHRoZSBuZXh0IG1ham9yIHZlcnNpb24uXG4gICAqL1xuICB0b0pTT04oKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIG5hbWU6IHRoaXMubmFtZSxcbiAgICAgIGNhdXNlOiB0aGlzLmNhdXNlLFxuICAgICAgbWVzc2FnZTogdGhpcy5tZXNzYWdlLFxuICAgICAgc3RhY2s6IHRoaXMuc3RhY2tcbiAgICB9O1xuICB9XG59O1xuX2E2ID0gc3ltYm9sNjtcblxuLy8gY29yZS9nZW5lcmF0ZS1vYmplY3QvZ2VuZXJhdGUtb2JqZWN0LnRzXG5hc3luYyBmdW5jdGlvbiBnZW5lcmF0ZU9iamVjdCh7XG4gIG1vZGVsLFxuICBzY2hlbWE6IGlucHV0U2NoZW1hLFxuICBzY2hlbWFOYW1lLFxuICBzY2hlbWFEZXNjcmlwdGlvbixcbiAgbW9kZSxcbiAgc3lzdGVtLFxuICBwcm9tcHQsXG4gIG1lc3NhZ2VzLFxuICBtYXhSZXRyaWVzLFxuICBhYm9ydFNpZ25hbCxcbiAgaGVhZGVycyxcbiAgZXhwZXJpbWVudGFsX3RlbGVtZXRyeTogdGVsZW1ldHJ5LFxuICAuLi5zZXR0aW5nc1xufSkge1xuICB2YXIgX2ExMjtcbiAgY29uc3QgYmFzZVRlbGVtZXRyeUF0dHJpYnV0ZXMgPSBnZXRCYXNlVGVsZW1ldHJ5QXR0cmlidXRlcyh7XG4gICAgbW9kZWwsXG4gICAgdGVsZW1ldHJ5LFxuICAgIGhlYWRlcnMsXG4gICAgc2V0dGluZ3M6IHsgLi4uc2V0dGluZ3MsIG1heFJldHJpZXMgfVxuICB9KTtcbiAgY29uc3Qgc2NoZW1hID0gYXNTY2hlbWEoaW5wdXRTY2hlbWEpO1xuICBjb25zdCB0cmFjZXIgPSBnZXRUcmFjZXIoeyBpc0VuYWJsZWQ6IChfYTEyID0gdGVsZW1ldHJ5ID09IG51bGwgPyB2b2lkIDAgOiB0ZWxlbWV0cnkuaXNFbmFibGVkKSAhPSBudWxsID8gX2ExMiA6IGZhbHNlIH0pO1xuICByZXR1cm4gcmVjb3JkU3Bhbih7XG4gICAgbmFtZTogXCJhaS5nZW5lcmF0ZU9iamVjdFwiLFxuICAgIGF0dHJpYnV0ZXM6IHNlbGVjdFRlbGVtZXRyeUF0dHJpYnV0ZXMoe1xuICAgICAgdGVsZW1ldHJ5LFxuICAgICAgYXR0cmlidXRlczoge1xuICAgICAgICAuLi5hc3NlbWJsZU9wZXJhdGlvbk5hbWUoe1xuICAgICAgICAgIG9wZXJhdGlvbk5hbWU6IFwiYWkuZ2VuZXJhdGVPYmplY3RcIixcbiAgICAgICAgICB0ZWxlbWV0cnlcbiAgICAgICAgfSksXG4gICAgICAgIC4uLmJhc2VUZWxlbWV0cnlBdHRyaWJ1dGVzLFxuICAgICAgICAvLyBzcGVjaWZpYyBzZXR0aW5ncyB0aGF0IG9ubHkgbWFrZSBzZW5zZSBvbiB0aGUgb3V0ZXIgbGV2ZWw6XG4gICAgICAgIFwiYWkucHJvbXB0XCI6IHtcbiAgICAgICAgICBpbnB1dDogKCkgPT4gSlNPTi5zdHJpbmdpZnkoeyBzeXN0ZW0sIHByb21wdCwgbWVzc2FnZXMgfSlcbiAgICAgICAgfSxcbiAgICAgICAgXCJhaS5zY2hlbWFcIjoge1xuICAgICAgICAgIGlucHV0OiAoKSA9PiBKU09OLnN0cmluZ2lmeShzY2hlbWEuanNvblNjaGVtYSlcbiAgICAgICAgfSxcbiAgICAgICAgXCJhaS5zY2hlbWEubmFtZVwiOiBzY2hlbWFOYW1lLFxuICAgICAgICBcImFpLnNjaGVtYS5kZXNjcmlwdGlvblwiOiBzY2hlbWFEZXNjcmlwdGlvbixcbiAgICAgICAgXCJhaS5zZXR0aW5ncy5tb2RlXCI6IG1vZGVcbiAgICAgIH1cbiAgICB9KSxcbiAgICB0cmFjZXIsXG4gICAgZm46IGFzeW5jIChzcGFuKSA9PiB7XG4gICAgICBjb25zdCByZXRyeSA9IHJldHJ5V2l0aEV4cG9uZW50aWFsQmFja29mZih7IG1heFJldHJpZXMgfSk7XG4gICAgICBpZiAobW9kZSA9PT0gXCJhdXRvXCIgfHwgbW9kZSA9PSBudWxsKSB7XG4gICAgICAgIG1vZGUgPSBtb2RlbC5kZWZhdWx0T2JqZWN0R2VuZXJhdGlvbk1vZGU7XG4gICAgICB9XG4gICAgICBsZXQgcmVzdWx0O1xuICAgICAgbGV0IGZpbmlzaFJlYXNvbjtcbiAgICAgIGxldCB1c2FnZTtcbiAgICAgIGxldCB3YXJuaW5ncztcbiAgICAgIGxldCByYXdSZXNwb25zZTtcbiAgICAgIGxldCBsb2dwcm9icztcbiAgICAgIGxldCBwcm92aWRlck1ldGFkYXRhO1xuICAgICAgc3dpdGNoIChtb2RlKSB7XG4gICAgICAgIGNhc2UgXCJqc29uXCI6IHtcbiAgICAgICAgICBjb25zdCB2YWxpZGF0ZWRQcm9tcHQgPSBnZXRWYWxpZGF0ZWRQcm9tcHQoe1xuICAgICAgICAgICAgc3lzdGVtOiBtb2RlbC5zdXBwb3J0c1N0cnVjdHVyZWRPdXRwdXRzID8gc3lzdGVtIDogaW5qZWN0SnNvblNjaGVtYUludG9TeXN0ZW0oe1xuICAgICAgICAgICAgICBzeXN0ZW0sXG4gICAgICAgICAgICAgIHNjaGVtYTogc2NoZW1hLmpzb25TY2hlbWFcbiAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgcHJvbXB0LFxuICAgICAgICAgICAgbWVzc2FnZXNcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBjb25zdCBwcm9tcHRNZXNzYWdlcyA9IGF3YWl0IGNvbnZlcnRUb0xhbmd1YWdlTW9kZWxQcm9tcHQoe1xuICAgICAgICAgICAgcHJvbXB0OiB2YWxpZGF0ZWRQcm9tcHQsXG4gICAgICAgICAgICBtb2RlbFN1cHBvcnRzSW1hZ2VVcmxzOiBtb2RlbC5zdXBwb3J0c0ltYWdlVXJsc1xuICAgICAgICAgIH0pO1xuICAgICAgICAgIGNvbnN0IGlucHV0Rm9ybWF0ID0gdmFsaWRhdGVkUHJvbXB0LnR5cGU7XG4gICAgICAgICAgY29uc3QgZ2VuZXJhdGVSZXN1bHQgPSBhd2FpdCByZXRyeShcbiAgICAgICAgICAgICgpID0+IHJlY29yZFNwYW4oe1xuICAgICAgICAgICAgICBuYW1lOiBcImFpLmdlbmVyYXRlT2JqZWN0LmRvR2VuZXJhdGVcIixcbiAgICAgICAgICAgICAgYXR0cmlidXRlczogc2VsZWN0VGVsZW1ldHJ5QXR0cmlidXRlcyh7XG4gICAgICAgICAgICAgICAgdGVsZW1ldHJ5LFxuICAgICAgICAgICAgICAgIGF0dHJpYnV0ZXM6IHtcbiAgICAgICAgICAgICAgICAgIC4uLmFzc2VtYmxlT3BlcmF0aW9uTmFtZSh7XG4gICAgICAgICAgICAgICAgICAgIG9wZXJhdGlvbk5hbWU6IFwiYWkuZ2VuZXJhdGVPYmplY3QuZG9HZW5lcmF0ZVwiLFxuICAgICAgICAgICAgICAgICAgICB0ZWxlbWV0cnlcbiAgICAgICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgICAgICAgLi4uYmFzZVRlbGVtZXRyeUF0dHJpYnV0ZXMsXG4gICAgICAgICAgICAgICAgICBcImFpLnByb21wdC5mb3JtYXRcIjoge1xuICAgICAgICAgICAgICAgICAgICBpbnB1dDogKCkgPT4gaW5wdXRGb3JtYXRcbiAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICBcImFpLnByb21wdC5tZXNzYWdlc1wiOiB7XG4gICAgICAgICAgICAgICAgICAgIGlucHV0OiAoKSA9PiBKU09OLnN0cmluZ2lmeShwcm9tcHRNZXNzYWdlcylcbiAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICBcImFpLnNldHRpbmdzLm1vZGVcIjogbW9kZSxcbiAgICAgICAgICAgICAgICAgIC8vIHN0YW5kYXJkaXplZCBnZW4tYWkgbGxtIHNwYW4gYXR0cmlidXRlczpcbiAgICAgICAgICAgICAgICAgIFwiZ2VuX2FpLnJlcXVlc3QubW9kZWxcIjogbW9kZWwubW9kZWxJZCxcbiAgICAgICAgICAgICAgICAgIFwiZ2VuX2FpLnN5c3RlbVwiOiBtb2RlbC5wcm92aWRlcixcbiAgICAgICAgICAgICAgICAgIFwiZ2VuX2FpLnJlcXVlc3QubWF4X3Rva2Vuc1wiOiBzZXR0aW5ncy5tYXhUb2tlbnMsXG4gICAgICAgICAgICAgICAgICBcImdlbl9haS5yZXF1ZXN0LnRlbXBlcmF0dXJlXCI6IHNldHRpbmdzLnRlbXBlcmF0dXJlLFxuICAgICAgICAgICAgICAgICAgXCJnZW5fYWkucmVxdWVzdC50b3BfcFwiOiBzZXR0aW5ncy50b3BQXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgICAgdHJhY2VyLFxuICAgICAgICAgICAgICBmbjogYXN5bmMgKHNwYW4yKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgcmVzdWx0MiA9IGF3YWl0IG1vZGVsLmRvR2VuZXJhdGUoe1xuICAgICAgICAgICAgICAgICAgbW9kZToge1xuICAgICAgICAgICAgICAgICAgICB0eXBlOiBcIm9iamVjdC1qc29uXCIsXG4gICAgICAgICAgICAgICAgICAgIHNjaGVtYTogc2NoZW1hLmpzb25TY2hlbWEsXG4gICAgICAgICAgICAgICAgICAgIG5hbWU6IHNjaGVtYU5hbWUsXG4gICAgICAgICAgICAgICAgICAgIGRlc2NyaXB0aW9uOiBzY2hlbWFEZXNjcmlwdGlvblxuICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgIC4uLnByZXBhcmVDYWxsU2V0dGluZ3Moc2V0dGluZ3MpLFxuICAgICAgICAgICAgICAgICAgaW5wdXRGb3JtYXQsXG4gICAgICAgICAgICAgICAgICBwcm9tcHQ6IHByb21wdE1lc3NhZ2VzLFxuICAgICAgICAgICAgICAgICAgYWJvcnRTaWduYWwsXG4gICAgICAgICAgICAgICAgICBoZWFkZXJzXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgaWYgKHJlc3VsdDIudGV4dCA9PT0gdm9pZCAwKSB7XG4gICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgTm9PYmplY3RHZW5lcmF0ZWRFcnJvcigpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBzcGFuMi5zZXRBdHRyaWJ1dGVzKFxuICAgICAgICAgICAgICAgICAgc2VsZWN0VGVsZW1ldHJ5QXR0cmlidXRlcyh7XG4gICAgICAgICAgICAgICAgICAgIHRlbGVtZXRyeSxcbiAgICAgICAgICAgICAgICAgICAgYXR0cmlidXRlczoge1xuICAgICAgICAgICAgICAgICAgICAgIFwiYWkuZmluaXNoUmVhc29uXCI6IHJlc3VsdDIuZmluaXNoUmVhc29uLFxuICAgICAgICAgICAgICAgICAgICAgIFwiYWkudXNhZ2UucHJvbXB0VG9rZW5zXCI6IHJlc3VsdDIudXNhZ2UucHJvbXB0VG9rZW5zLFxuICAgICAgICAgICAgICAgICAgICAgIFwiYWkudXNhZ2UuY29tcGxldGlvblRva2Vuc1wiOiByZXN1bHQyLnVzYWdlLmNvbXBsZXRpb25Ub2tlbnMsXG4gICAgICAgICAgICAgICAgICAgICAgXCJhaS5yZXN1bHQub2JqZWN0XCI6IHsgb3V0cHV0OiAoKSA9PiByZXN1bHQyLnRleHQgfSxcbiAgICAgICAgICAgICAgICAgICAgICAvLyBzdGFuZGFyZGl6ZWQgZ2VuLWFpIGxsbSBzcGFuIGF0dHJpYnV0ZXM6XG4gICAgICAgICAgICAgICAgICAgICAgXCJnZW5fYWkucmVzcG9uc2UuZmluaXNoX3JlYXNvbnNcIjogW3Jlc3VsdDIuZmluaXNoUmVhc29uXSxcbiAgICAgICAgICAgICAgICAgICAgICBcImdlbl9haS51c2FnZS5wcm9tcHRfdG9rZW5zXCI6IHJlc3VsdDIudXNhZ2UucHJvbXB0VG9rZW5zLFxuICAgICAgICAgICAgICAgICAgICAgIFwiZ2VuX2FpLnVzYWdlLmNvbXBsZXRpb25fdG9rZW5zXCI6IHJlc3VsdDIudXNhZ2UuY29tcGxldGlvblRva2Vuc1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHsgLi4ucmVzdWx0Miwgb2JqZWN0VGV4dDogcmVzdWx0Mi50ZXh0IH07XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgKTtcbiAgICAgICAgICByZXN1bHQgPSBnZW5lcmF0ZVJlc3VsdC5vYmplY3RUZXh0O1xuICAgICAgICAgIGZpbmlzaFJlYXNvbiA9IGdlbmVyYXRlUmVzdWx0LmZpbmlzaFJlYXNvbjtcbiAgICAgICAgICB1c2FnZSA9IGdlbmVyYXRlUmVzdWx0LnVzYWdlO1xuICAgICAgICAgIHdhcm5pbmdzID0gZ2VuZXJhdGVSZXN1bHQud2FybmluZ3M7XG4gICAgICAgICAgcmF3UmVzcG9uc2UgPSBnZW5lcmF0ZVJlc3VsdC5yYXdSZXNwb25zZTtcbiAgICAgICAgICBsb2dwcm9icyA9IGdlbmVyYXRlUmVzdWx0LmxvZ3Byb2JzO1xuICAgICAgICAgIHByb3ZpZGVyTWV0YWRhdGEgPSBnZW5lcmF0ZVJlc3VsdC5wcm92aWRlck1ldGFkYXRhO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGNhc2UgXCJ0b29sXCI6IHtcbiAgICAgICAgICBjb25zdCB2YWxpZGF0ZWRQcm9tcHQgPSBnZXRWYWxpZGF0ZWRQcm9tcHQoe1xuICAgICAgICAgICAgc3lzdGVtLFxuICAgICAgICAgICAgcHJvbXB0LFxuICAgICAgICAgICAgbWVzc2FnZXNcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBjb25zdCBwcm9tcHRNZXNzYWdlcyA9IGF3YWl0IGNvbnZlcnRUb0xhbmd1YWdlTW9kZWxQcm9tcHQoe1xuICAgICAgICAgICAgcHJvbXB0OiB2YWxpZGF0ZWRQcm9tcHQsXG4gICAgICAgICAgICBtb2RlbFN1cHBvcnRzSW1hZ2VVcmxzOiBtb2RlbC5zdXBwb3J0c0ltYWdlVXJsc1xuICAgICAgICAgIH0pO1xuICAgICAgICAgIGNvbnN0IGlucHV0Rm9ybWF0ID0gdmFsaWRhdGVkUHJvbXB0LnR5cGU7XG4gICAgICAgICAgY29uc3QgZ2VuZXJhdGVSZXN1bHQgPSBhd2FpdCByZXRyeShcbiAgICAgICAgICAgICgpID0+IHJlY29yZFNwYW4oe1xuICAgICAgICAgICAgICBuYW1lOiBcImFpLmdlbmVyYXRlT2JqZWN0LmRvR2VuZXJhdGVcIixcbiAgICAgICAgICAgICAgYXR0cmlidXRlczogc2VsZWN0VGVsZW1ldHJ5QXR0cmlidXRlcyh7XG4gICAgICAgICAgICAgICAgdGVsZW1ldHJ5LFxuICAgICAgICAgICAgICAgIGF0dHJpYnV0ZXM6IHtcbiAgICAgICAgICAgICAgICAgIC4uLmFzc2VtYmxlT3BlcmF0aW9uTmFtZSh7XG4gICAgICAgICAgICAgICAgICAgIG9wZXJhdGlvbk5hbWU6IFwiYWkuZ2VuZXJhdGVPYmplY3QuZG9HZW5lcmF0ZVwiLFxuICAgICAgICAgICAgICAgICAgICB0ZWxlbWV0cnlcbiAgICAgICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgICAgICAgLi4uYmFzZVRlbGVtZXRyeUF0dHJpYnV0ZXMsXG4gICAgICAgICAgICAgICAgICBcImFpLnByb21wdC5mb3JtYXRcIjoge1xuICAgICAgICAgICAgICAgICAgICBpbnB1dDogKCkgPT4gaW5wdXRGb3JtYXRcbiAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICBcImFpLnByb21wdC5tZXNzYWdlc1wiOiB7XG4gICAgICAgICAgICAgICAgICAgIGlucHV0OiAoKSA9PiBKU09OLnN0cmluZ2lmeShwcm9tcHRNZXNzYWdlcylcbiAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICBcImFpLnNldHRpbmdzLm1vZGVcIjogbW9kZSxcbiAgICAgICAgICAgICAgICAgIC8vIHN0YW5kYXJkaXplZCBnZW4tYWkgbGxtIHNwYW4gYXR0cmlidXRlczpcbiAgICAgICAgICAgICAgICAgIFwiZ2VuX2FpLnJlcXVlc3QubW9kZWxcIjogbW9kZWwubW9kZWxJZCxcbiAgICAgICAgICAgICAgICAgIFwiZ2VuX2FpLnN5c3RlbVwiOiBtb2RlbC5wcm92aWRlcixcbiAgICAgICAgICAgICAgICAgIFwiZ2VuX2FpLnJlcXVlc3QubWF4X3Rva2Vuc1wiOiBzZXR0aW5ncy5tYXhUb2tlbnMsXG4gICAgICAgICAgICAgICAgICBcImdlbl9haS5yZXF1ZXN0LnRlbXBlcmF0dXJlXCI6IHNldHRpbmdzLnRlbXBlcmF0dXJlLFxuICAgICAgICAgICAgICAgICAgXCJnZW5fYWkucmVxdWVzdC50b3BfcFwiOiBzZXR0aW5ncy50b3BQXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgICAgdHJhY2VyLFxuICAgICAgICAgICAgICBmbjogYXN5bmMgKHNwYW4yKSA9PiB7XG4gICAgICAgICAgICAgICAgdmFyIF9hMTMsIF9iO1xuICAgICAgICAgICAgICAgIGNvbnN0IHJlc3VsdDIgPSBhd2FpdCBtb2RlbC5kb0dlbmVyYXRlKHtcbiAgICAgICAgICAgICAgICAgIG1vZGU6IHtcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogXCJvYmplY3QtdG9vbFwiLFxuICAgICAgICAgICAgICAgICAgICB0b29sOiB7XG4gICAgICAgICAgICAgICAgICAgICAgdHlwZTogXCJmdW5jdGlvblwiLFxuICAgICAgICAgICAgICAgICAgICAgIG5hbWU6IHNjaGVtYU5hbWUgIT0gbnVsbCA/IHNjaGVtYU5hbWUgOiBcImpzb25cIixcbiAgICAgICAgICAgICAgICAgICAgICBkZXNjcmlwdGlvbjogc2NoZW1hRGVzY3JpcHRpb24gIT0gbnVsbCA/IHNjaGVtYURlc2NyaXB0aW9uIDogXCJSZXNwb25kIHdpdGggYSBKU09OIG9iamVjdC5cIixcbiAgICAgICAgICAgICAgICAgICAgICBwYXJhbWV0ZXJzOiBzY2hlbWEuanNvblNjaGVtYVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgLi4ucHJlcGFyZUNhbGxTZXR0aW5ncyhzZXR0aW5ncyksXG4gICAgICAgICAgICAgICAgICBpbnB1dEZvcm1hdCxcbiAgICAgICAgICAgICAgICAgIHByb21wdDogcHJvbXB0TWVzc2FnZXMsXG4gICAgICAgICAgICAgICAgICBhYm9ydFNpZ25hbCxcbiAgICAgICAgICAgICAgICAgIGhlYWRlcnNcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBjb25zdCBvYmplY3RUZXh0ID0gKF9iID0gKF9hMTMgPSByZXN1bHQyLnRvb2xDYWxscykgPT0gbnVsbCA/IHZvaWQgMCA6IF9hMTNbMF0pID09IG51bGwgPyB2b2lkIDAgOiBfYi5hcmdzO1xuICAgICAgICAgICAgICAgIGlmIChvYmplY3RUZXh0ID09PSB2b2lkIDApIHtcbiAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBOb09iamVjdEdlbmVyYXRlZEVycm9yKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHNwYW4yLnNldEF0dHJpYnV0ZXMoXG4gICAgICAgICAgICAgICAgICBzZWxlY3RUZWxlbWV0cnlBdHRyaWJ1dGVzKHtcbiAgICAgICAgICAgICAgICAgICAgdGVsZW1ldHJ5LFxuICAgICAgICAgICAgICAgICAgICBhdHRyaWJ1dGVzOiB7XG4gICAgICAgICAgICAgICAgICAgICAgXCJhaS5maW5pc2hSZWFzb25cIjogcmVzdWx0Mi5maW5pc2hSZWFzb24sXG4gICAgICAgICAgICAgICAgICAgICAgXCJhaS51c2FnZS5wcm9tcHRUb2tlbnNcIjogcmVzdWx0Mi51c2FnZS5wcm9tcHRUb2tlbnMsXG4gICAgICAgICAgICAgICAgICAgICAgXCJhaS51c2FnZS5jb21wbGV0aW9uVG9rZW5zXCI6IHJlc3VsdDIudXNhZ2UuY29tcGxldGlvblRva2VucyxcbiAgICAgICAgICAgICAgICAgICAgICBcImFpLnJlc3VsdC5vYmplY3RcIjogeyBvdXRwdXQ6ICgpID0+IG9iamVjdFRleHQgfSxcbiAgICAgICAgICAgICAgICAgICAgICAvLyBzdGFuZGFyZGl6ZWQgZ2VuLWFpIGxsbSBzcGFuIGF0dHJpYnV0ZXM6XG4gICAgICAgICAgICAgICAgICAgICAgXCJnZW5fYWkucmVzcG9uc2UuZmluaXNoX3JlYXNvbnNcIjogW3Jlc3VsdDIuZmluaXNoUmVhc29uXSxcbiAgICAgICAgICAgICAgICAgICAgICBcImdlbl9haS51c2FnZS5wcm9tcHRfdG9rZW5zXCI6IHJlc3VsdDIudXNhZ2UucHJvbXB0VG9rZW5zLFxuICAgICAgICAgICAgICAgICAgICAgIFwiZ2VuX2FpLnVzYWdlLmNvbXBsZXRpb25fdG9rZW5zXCI6IHJlc3VsdDIudXNhZ2UuY29tcGxldGlvblRva2Vuc1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHsgLi4ucmVzdWx0Miwgb2JqZWN0VGV4dCB9O1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KVxuICAgICAgICAgICk7XG4gICAgICAgICAgcmVzdWx0ID0gZ2VuZXJhdGVSZXN1bHQub2JqZWN0VGV4dDtcbiAgICAgICAgICBmaW5pc2hSZWFzb24gPSBnZW5lcmF0ZVJlc3VsdC5maW5pc2hSZWFzb247XG4gICAgICAgICAgdXNhZ2UgPSBnZW5lcmF0ZVJlc3VsdC51c2FnZTtcbiAgICAgICAgICB3YXJuaW5ncyA9IGdlbmVyYXRlUmVzdWx0Lndhcm5pbmdzO1xuICAgICAgICAgIHJhd1Jlc3BvbnNlID0gZ2VuZXJhdGVSZXN1bHQucmF3UmVzcG9uc2U7XG4gICAgICAgICAgbG9ncHJvYnMgPSBnZW5lcmF0ZVJlc3VsdC5sb2dwcm9icztcbiAgICAgICAgICBwcm92aWRlck1ldGFkYXRhID0gZ2VuZXJhdGVSZXN1bHQucHJvdmlkZXJNZXRhZGF0YTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBjYXNlIHZvaWQgMDoge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICAgIFwiTW9kZWwgZG9lcyBub3QgaGF2ZSBhIGRlZmF1bHQgb2JqZWN0IGdlbmVyYXRpb24gbW9kZS5cIlxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgICAgZGVmYXVsdDoge1xuICAgICAgICAgIGNvbnN0IF9leGhhdXN0aXZlQ2hlY2sgPSBtb2RlO1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgVW5zdXBwb3J0ZWQgbW9kZTogJHtfZXhoYXVzdGl2ZUNoZWNrfWApO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBjb25zdCBwYXJzZVJlc3VsdCA9IHNhZmVQYXJzZUpTT04oeyB0ZXh0OiByZXN1bHQsIHNjaGVtYSB9KTtcbiAgICAgIGlmICghcGFyc2VSZXN1bHQuc3VjY2Vzcykge1xuICAgICAgICB0aHJvdyBwYXJzZVJlc3VsdC5lcnJvcjtcbiAgICAgIH1cbiAgICAgIHNwYW4uc2V0QXR0cmlidXRlcyhcbiAgICAgICAgc2VsZWN0VGVsZW1ldHJ5QXR0cmlidXRlcyh7XG4gICAgICAgICAgdGVsZW1ldHJ5LFxuICAgICAgICAgIGF0dHJpYnV0ZXM6IHtcbiAgICAgICAgICAgIFwiYWkuZmluaXNoUmVhc29uXCI6IGZpbmlzaFJlYXNvbixcbiAgICAgICAgICAgIFwiYWkudXNhZ2UucHJvbXB0VG9rZW5zXCI6IHVzYWdlLnByb21wdFRva2VucyxcbiAgICAgICAgICAgIFwiYWkudXNhZ2UuY29tcGxldGlvblRva2Vuc1wiOiB1c2FnZS5jb21wbGV0aW9uVG9rZW5zLFxuICAgICAgICAgICAgXCJhaS5yZXN1bHQub2JqZWN0XCI6IHtcbiAgICAgICAgICAgICAgb3V0cHV0OiAoKSA9PiBKU09OLnN0cmluZ2lmeShwYXJzZVJlc3VsdC52YWx1ZSlcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0pXG4gICAgICApO1xuICAgICAgcmV0dXJuIG5ldyBEZWZhdWx0R2VuZXJhdGVPYmplY3RSZXN1bHQoe1xuICAgICAgICBvYmplY3Q6IHBhcnNlUmVzdWx0LnZhbHVlLFxuICAgICAgICBmaW5pc2hSZWFzb24sXG4gICAgICAgIHVzYWdlOiBjYWxjdWxhdGVDb21wbGV0aW9uVG9rZW5Vc2FnZSh1c2FnZSksXG4gICAgICAgIHdhcm5pbmdzLFxuICAgICAgICByYXdSZXNwb25zZSxcbiAgICAgICAgbG9ncHJvYnMsXG4gICAgICAgIHByb3ZpZGVyTWV0YWRhdGFcbiAgICAgIH0pO1xuICAgIH1cbiAgfSk7XG59XG52YXIgRGVmYXVsdEdlbmVyYXRlT2JqZWN0UmVzdWx0ID0gY2xhc3Mge1xuICBjb25zdHJ1Y3RvcihvcHRpb25zKSB7XG4gICAgdGhpcy5vYmplY3QgPSBvcHRpb25zLm9iamVjdDtcbiAgICB0aGlzLmZpbmlzaFJlYXNvbiA9IG9wdGlvbnMuZmluaXNoUmVhc29uO1xuICAgIHRoaXMudXNhZ2UgPSBvcHRpb25zLnVzYWdlO1xuICAgIHRoaXMud2FybmluZ3MgPSBvcHRpb25zLndhcm5pbmdzO1xuICAgIHRoaXMucmF3UmVzcG9uc2UgPSBvcHRpb25zLnJhd1Jlc3BvbnNlO1xuICAgIHRoaXMubG9ncHJvYnMgPSBvcHRpb25zLmxvZ3Byb2JzO1xuICAgIHRoaXMuZXhwZXJpbWVudGFsX3Byb3ZpZGVyTWV0YWRhdGEgPSBvcHRpb25zLnByb3ZpZGVyTWV0YWRhdGE7XG4gIH1cbiAgdG9Kc29uUmVzcG9uc2UoaW5pdCkge1xuICAgIHZhciBfYTEyO1xuICAgIHJldHVybiBuZXcgUmVzcG9uc2UoSlNPTi5zdHJpbmdpZnkodGhpcy5vYmplY3QpLCB7XG4gICAgICBzdGF0dXM6IChfYTEyID0gaW5pdCA9PSBudWxsID8gdm9pZCAwIDogaW5pdC5zdGF0dXMpICE9IG51bGwgPyBfYTEyIDogMjAwLFxuICAgICAgaGVhZGVyczogcHJlcGFyZVJlc3BvbnNlSGVhZGVycyhpbml0LCB7XG4gICAgICAgIGNvbnRlbnRUeXBlOiBcImFwcGxpY2F0aW9uL2pzb247IGNoYXJzZXQ9dXRmLThcIlxuICAgICAgfSlcbiAgICB9KTtcbiAgfVxufTtcbnZhciBleHBlcmltZW50YWxfZ2VuZXJhdGVPYmplY3QgPSBnZW5lcmF0ZU9iamVjdDtcblxuLy8gY29yZS9nZW5lcmF0ZS1vYmplY3Qvc3RyZWFtLW9iamVjdC50c1xuaW1wb3J0IHsgc2FmZVZhbGlkYXRlVHlwZXMgfSBmcm9tIFwiQGFpLXNkay9wcm92aWRlci11dGlsc1wiO1xuaW1wb3J0IHtcbiAgYXNTY2hlbWEgYXMgYXNTY2hlbWEyLFxuICBpc0RlZXBFcXVhbERhdGEsXG4gIHBhcnNlUGFydGlhbEpzb25cbn0gZnJvbSBcIkBhaS1zZGsvdWktdXRpbHNcIjtcblxuLy8gdXRpbC9jcmVhdGUtcmVzb2x2YWJsZS1wcm9taXNlLnRzXG5mdW5jdGlvbiBjcmVhdGVSZXNvbHZhYmxlUHJvbWlzZSgpIHtcbiAgbGV0IHJlc29sdmU7XG4gIGxldCByZWplY3Q7XG4gIGNvbnN0IHByb21pc2UgPSBuZXcgUHJvbWlzZSgocmVzLCByZWopID0+IHtcbiAgICByZXNvbHZlID0gcmVzO1xuICAgIHJlamVjdCA9IHJlajtcbiAgfSk7XG4gIHJldHVybiB7XG4gICAgcHJvbWlzZSxcbiAgICByZXNvbHZlLFxuICAgIHJlamVjdFxuICB9O1xufVxuXG4vLyB1dGlsL2RlbGF5ZWQtcHJvbWlzZS50c1xudmFyIERlbGF5ZWRQcm9taXNlID0gY2xhc3Mge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICB0aGlzLnN0YXR1cyA9IHsgdHlwZTogXCJwZW5kaW5nXCIgfTtcbiAgICB0aGlzLl9yZXNvbHZlID0gdm9pZCAwO1xuICAgIHRoaXMuX3JlamVjdCA9IHZvaWQgMDtcbiAgfVxuICBnZXQgdmFsdWUoKSB7XG4gICAgaWYgKHRoaXMucHJvbWlzZSkge1xuICAgICAgcmV0dXJuIHRoaXMucHJvbWlzZTtcbiAgICB9XG4gICAgdGhpcy5wcm9taXNlID0gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgaWYgKHRoaXMuc3RhdHVzLnR5cGUgPT09IFwicmVzb2x2ZWRcIikge1xuICAgICAgICByZXNvbHZlKHRoaXMuc3RhdHVzLnZhbHVlKTtcbiAgICAgIH0gZWxzZSBpZiAodGhpcy5zdGF0dXMudHlwZSA9PT0gXCJyZWplY3RlZFwiKSB7XG4gICAgICAgIHJlamVjdCh0aGlzLnN0YXR1cy5lcnJvcik7XG4gICAgICB9XG4gICAgICB0aGlzLl9yZXNvbHZlID0gcmVzb2x2ZTtcbiAgICAgIHRoaXMuX3JlamVjdCA9IHJlamVjdDtcbiAgICB9KTtcbiAgICByZXR1cm4gdGhpcy5wcm9taXNlO1xuICB9XG4gIHJlc29sdmUodmFsdWUpIHtcbiAgICB2YXIgX2ExMjtcbiAgICB0aGlzLnN0YXR1cyA9IHsgdHlwZTogXCJyZXNvbHZlZFwiLCB2YWx1ZSB9O1xuICAgIGlmICh0aGlzLnByb21pc2UpIHtcbiAgICAgIChfYTEyID0gdGhpcy5fcmVzb2x2ZSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9hMTIuY2FsbCh0aGlzLCB2YWx1ZSk7XG4gICAgfVxuICB9XG4gIHJlamVjdChlcnJvcikge1xuICAgIHZhciBfYTEyO1xuICAgIHRoaXMuc3RhdHVzID0geyB0eXBlOiBcInJlamVjdGVkXCIsIGVycm9yIH07XG4gICAgaWYgKHRoaXMucHJvbWlzZSkge1xuICAgICAgKF9hMTIgPSB0aGlzLl9yZWplY3QpID09IG51bGwgPyB2b2lkIDAgOiBfYTEyLmNhbGwodGhpcywgZXJyb3IpO1xuICAgIH1cbiAgfVxufTtcblxuLy8gY29yZS91dGlsL2FzeW5jLWl0ZXJhYmxlLXN0cmVhbS50c1xuZnVuY3Rpb24gY3JlYXRlQXN5bmNJdGVyYWJsZVN0cmVhbShzb3VyY2UsIHRyYW5zZm9ybWVyKSB7XG4gIGNvbnN0IHRyYW5zZm9ybWVkU3RyZWFtID0gc291cmNlLnBpcGVUaHJvdWdoKFxuICAgIG5ldyBUcmFuc2Zvcm1TdHJlYW0odHJhbnNmb3JtZXIpXG4gICk7XG4gIHRyYW5zZm9ybWVkU3RyZWFtW1N5bWJvbC5hc3luY0l0ZXJhdG9yXSA9ICgpID0+IHtcbiAgICBjb25zdCByZWFkZXIgPSB0cmFuc2Zvcm1lZFN0cmVhbS5nZXRSZWFkZXIoKTtcbiAgICByZXR1cm4ge1xuICAgICAgYXN5bmMgbmV4dCgpIHtcbiAgICAgICAgY29uc3QgeyBkb25lLCB2YWx1ZSB9ID0gYXdhaXQgcmVhZGVyLnJlYWQoKTtcbiAgICAgICAgcmV0dXJuIGRvbmUgPyB7IGRvbmU6IHRydWUsIHZhbHVlOiB2b2lkIDAgfSA6IHsgZG9uZTogZmFsc2UsIHZhbHVlIH07XG4gICAgICB9XG4gICAgfTtcbiAgfTtcbiAgcmV0dXJuIHRyYW5zZm9ybWVkU3RyZWFtO1xufVxuXG4vLyBjb3JlL2dlbmVyYXRlLW9iamVjdC9zdHJlYW0tb2JqZWN0LnRzXG5hc3luYyBmdW5jdGlvbiBzdHJlYW1PYmplY3Qoe1xuICBtb2RlbCxcbiAgc2NoZW1hOiBpbnB1dFNjaGVtYSxcbiAgc2NoZW1hTmFtZSxcbiAgc2NoZW1hRGVzY3JpcHRpb24sXG4gIG1vZGUsXG4gIHN5c3RlbSxcbiAgcHJvbXB0LFxuICBtZXNzYWdlcyxcbiAgbWF4UmV0cmllcyxcbiAgYWJvcnRTaWduYWwsXG4gIGhlYWRlcnMsXG4gIGV4cGVyaW1lbnRhbF90ZWxlbWV0cnk6IHRlbGVtZXRyeSxcbiAgb25GaW5pc2gsXG4gIC4uLnNldHRpbmdzXG59KSB7XG4gIHZhciBfYTEyO1xuICBjb25zdCBiYXNlVGVsZW1ldHJ5QXR0cmlidXRlcyA9IGdldEJhc2VUZWxlbWV0cnlBdHRyaWJ1dGVzKHtcbiAgICBtb2RlbCxcbiAgICB0ZWxlbWV0cnksXG4gICAgaGVhZGVycyxcbiAgICBzZXR0aW5nczogeyAuLi5zZXR0aW5ncywgbWF4UmV0cmllcyB9XG4gIH0pO1xuICBjb25zdCB0cmFjZXIgPSBnZXRUcmFjZXIoeyBpc0VuYWJsZWQ6IChfYTEyID0gdGVsZW1ldHJ5ID09IG51bGwgPyB2b2lkIDAgOiB0ZWxlbWV0cnkuaXNFbmFibGVkKSAhPSBudWxsID8gX2ExMiA6IGZhbHNlIH0pO1xuICBjb25zdCByZXRyeSA9IHJldHJ5V2l0aEV4cG9uZW50aWFsQmFja29mZih7IG1heFJldHJpZXMgfSk7XG4gIGNvbnN0IHNjaGVtYSA9IGFzU2NoZW1hMihpbnB1dFNjaGVtYSk7XG4gIHJldHVybiByZWNvcmRTcGFuKHtcbiAgICBuYW1lOiBcImFpLnN0cmVhbU9iamVjdFwiLFxuICAgIGF0dHJpYnV0ZXM6IHNlbGVjdFRlbGVtZXRyeUF0dHJpYnV0ZXMoe1xuICAgICAgdGVsZW1ldHJ5LFxuICAgICAgYXR0cmlidXRlczoge1xuICAgICAgICAuLi5hc3NlbWJsZU9wZXJhdGlvbk5hbWUoe1xuICAgICAgICAgIG9wZXJhdGlvbk5hbWU6IFwiYWkuc3RyZWFtT2JqZWN0XCIsXG4gICAgICAgICAgdGVsZW1ldHJ5XG4gICAgICAgIH0pLFxuICAgICAgICAuLi5iYXNlVGVsZW1ldHJ5QXR0cmlidXRlcyxcbiAgICAgICAgLy8gc3BlY2lmaWMgc2V0dGluZ3MgdGhhdCBvbmx5IG1ha2Ugc2Vuc2Ugb24gdGhlIG91dGVyIGxldmVsOlxuICAgICAgICBcImFpLnByb21wdFwiOiB7XG4gICAgICAgICAgaW5wdXQ6ICgpID0+IEpTT04uc3RyaW5naWZ5KHsgc3lzdGVtLCBwcm9tcHQsIG1lc3NhZ2VzIH0pXG4gICAgICAgIH0sXG4gICAgICAgIFwiYWkuc2NoZW1hXCI6IHsgaW5wdXQ6ICgpID0+IEpTT04uc3RyaW5naWZ5KHNjaGVtYS5qc29uU2NoZW1hKSB9LFxuICAgICAgICBcImFpLnNjaGVtYS5uYW1lXCI6IHNjaGVtYU5hbWUsXG4gICAgICAgIFwiYWkuc2NoZW1hLmRlc2NyaXB0aW9uXCI6IHNjaGVtYURlc2NyaXB0aW9uLFxuICAgICAgICBcImFpLnNldHRpbmdzLm1vZGVcIjogbW9kZVxuICAgICAgfVxuICAgIH0pLFxuICAgIHRyYWNlcixcbiAgICBlbmRXaGVuRG9uZTogZmFsc2UsXG4gICAgZm46IGFzeW5jIChyb290U3BhbikgPT4ge1xuICAgICAgaWYgKG1vZGUgPT09IFwiYXV0b1wiIHx8IG1vZGUgPT0gbnVsbCkge1xuICAgICAgICBtb2RlID0gbW9kZWwuZGVmYXVsdE9iamVjdEdlbmVyYXRpb25Nb2RlO1xuICAgICAgfVxuICAgICAgbGV0IGNhbGxPcHRpb25zO1xuICAgICAgbGV0IHRyYW5zZm9ybWVyO1xuICAgICAgc3dpdGNoIChtb2RlKSB7XG4gICAgICAgIGNhc2UgXCJqc29uXCI6IHtcbiAgICAgICAgICBjb25zdCB2YWxpZGF0ZWRQcm9tcHQgPSBnZXRWYWxpZGF0ZWRQcm9tcHQoe1xuICAgICAgICAgICAgc3lzdGVtOiBtb2RlbC5zdXBwb3J0c1N0cnVjdHVyZWRPdXRwdXRzID8gc3lzdGVtIDogaW5qZWN0SnNvblNjaGVtYUludG9TeXN0ZW0oe1xuICAgICAgICAgICAgICBzeXN0ZW0sXG4gICAgICAgICAgICAgIHNjaGVtYTogc2NoZW1hLmpzb25TY2hlbWFcbiAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgcHJvbXB0LFxuICAgICAgICAgICAgbWVzc2FnZXNcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBjYWxsT3B0aW9ucyA9IHtcbiAgICAgICAgICAgIG1vZGU6IHtcbiAgICAgICAgICAgICAgdHlwZTogXCJvYmplY3QtanNvblwiLFxuICAgICAgICAgICAgICBzY2hlbWE6IHNjaGVtYS5qc29uU2NoZW1hLFxuICAgICAgICAgICAgICBuYW1lOiBzY2hlbWFOYW1lLFxuICAgICAgICAgICAgICBkZXNjcmlwdGlvbjogc2NoZW1hRGVzY3JpcHRpb25cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAuLi5wcmVwYXJlQ2FsbFNldHRpbmdzKHNldHRpbmdzKSxcbiAgICAgICAgICAgIGlucHV0Rm9ybWF0OiB2YWxpZGF0ZWRQcm9tcHQudHlwZSxcbiAgICAgICAgICAgIHByb21wdDogYXdhaXQgY29udmVydFRvTGFuZ3VhZ2VNb2RlbFByb21wdCh7XG4gICAgICAgICAgICAgIHByb21wdDogdmFsaWRhdGVkUHJvbXB0LFxuICAgICAgICAgICAgICBtb2RlbFN1cHBvcnRzSW1hZ2VVcmxzOiBtb2RlbC5zdXBwb3J0c0ltYWdlVXJsc1xuICAgICAgICAgICAgfSksXG4gICAgICAgICAgICBhYm9ydFNpZ25hbCxcbiAgICAgICAgICAgIGhlYWRlcnNcbiAgICAgICAgICB9O1xuICAgICAgICAgIHRyYW5zZm9ybWVyID0ge1xuICAgICAgICAgICAgdHJhbnNmb3JtOiAoY2h1bmssIGNvbnRyb2xsZXIpID0+IHtcbiAgICAgICAgICAgICAgc3dpdGNoIChjaHVuay50eXBlKSB7XG4gICAgICAgICAgICAgICAgY2FzZSBcInRleHQtZGVsdGFcIjpcbiAgICAgICAgICAgICAgICAgIGNvbnRyb2xsZXIuZW5xdWV1ZShjaHVuay50ZXh0RGVsdGEpO1xuICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSBcImZpbmlzaFwiOlxuICAgICAgICAgICAgICAgIGNhc2UgXCJlcnJvclwiOlxuICAgICAgICAgICAgICAgICAgY29udHJvbGxlci5lbnF1ZXVlKGNodW5rKTtcbiAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBjYXNlIFwidG9vbFwiOiB7XG4gICAgICAgICAgY29uc3QgdmFsaWRhdGVkUHJvbXB0ID0gZ2V0VmFsaWRhdGVkUHJvbXB0KHtcbiAgICAgICAgICAgIHN5c3RlbSxcbiAgICAgICAgICAgIHByb21wdCxcbiAgICAgICAgICAgIG1lc3NhZ2VzXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgY2FsbE9wdGlvbnMgPSB7XG4gICAgICAgICAgICBtb2RlOiB7XG4gICAgICAgICAgICAgIHR5cGU6IFwib2JqZWN0LXRvb2xcIixcbiAgICAgICAgICAgICAgdG9vbDoge1xuICAgICAgICAgICAgICAgIHR5cGU6IFwiZnVuY3Rpb25cIixcbiAgICAgICAgICAgICAgICBuYW1lOiBzY2hlbWFOYW1lICE9IG51bGwgPyBzY2hlbWFOYW1lIDogXCJqc29uXCIsXG4gICAgICAgICAgICAgICAgZGVzY3JpcHRpb246IHNjaGVtYURlc2NyaXB0aW9uICE9IG51bGwgPyBzY2hlbWFEZXNjcmlwdGlvbiA6IFwiUmVzcG9uZCB3aXRoIGEgSlNPTiBvYmplY3QuXCIsXG4gICAgICAgICAgICAgICAgcGFyYW1ldGVyczogc2NoZW1hLmpzb25TY2hlbWFcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIC4uLnByZXBhcmVDYWxsU2V0dGluZ3Moc2V0dGluZ3MpLFxuICAgICAgICAgICAgaW5wdXRGb3JtYXQ6IHZhbGlkYXRlZFByb21wdC50eXBlLFxuICAgICAgICAgICAgcHJvbXB0OiBhd2FpdCBjb252ZXJ0VG9MYW5ndWFnZU1vZGVsUHJvbXB0KHtcbiAgICAgICAgICAgICAgcHJvbXB0OiB2YWxpZGF0ZWRQcm9tcHQsXG4gICAgICAgICAgICAgIG1vZGVsU3VwcG9ydHNJbWFnZVVybHM6IG1vZGVsLnN1cHBvcnRzSW1hZ2VVcmxzXG4gICAgICAgICAgICB9KSxcbiAgICAgICAgICAgIGFib3J0U2lnbmFsLFxuICAgICAgICAgICAgaGVhZGVyc1xuICAgICAgICAgIH07XG4gICAgICAgICAgdHJhbnNmb3JtZXIgPSB7XG4gICAgICAgICAgICB0cmFuc2Zvcm0oY2h1bmssIGNvbnRyb2xsZXIpIHtcbiAgICAgICAgICAgICAgc3dpdGNoIChjaHVuay50eXBlKSB7XG4gICAgICAgICAgICAgICAgY2FzZSBcInRvb2wtY2FsbC1kZWx0YVwiOlxuICAgICAgICAgICAgICAgICAgY29udHJvbGxlci5lbnF1ZXVlKGNodW5rLmFyZ3NUZXh0RGVsdGEpO1xuICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSBcImZpbmlzaFwiOlxuICAgICAgICAgICAgICAgIGNhc2UgXCJlcnJvclwiOlxuICAgICAgICAgICAgICAgICAgY29udHJvbGxlci5lbnF1ZXVlKGNodW5rKTtcbiAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBjYXNlIHZvaWQgMDoge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICAgIFwiTW9kZWwgZG9lcyBub3QgaGF2ZSBhIGRlZmF1bHQgb2JqZWN0IGdlbmVyYXRpb24gbW9kZS5cIlxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgICAgZGVmYXVsdDoge1xuICAgICAgICAgIGNvbnN0IF9leGhhdXN0aXZlQ2hlY2sgPSBtb2RlO1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgVW5zdXBwb3J0ZWQgbW9kZTogJHtfZXhoYXVzdGl2ZUNoZWNrfWApO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBjb25zdCB7XG4gICAgICAgIHJlc3VsdDogeyBzdHJlYW0sIHdhcm5pbmdzLCByYXdSZXNwb25zZSB9LFxuICAgICAgICBkb1N0cmVhbVNwYW5cbiAgICAgIH0gPSBhd2FpdCByZXRyeShcbiAgICAgICAgKCkgPT4gcmVjb3JkU3Bhbih7XG4gICAgICAgICAgbmFtZTogXCJhaS5zdHJlYW1PYmplY3QuZG9TdHJlYW1cIixcbiAgICAgICAgICBhdHRyaWJ1dGVzOiBzZWxlY3RUZWxlbWV0cnlBdHRyaWJ1dGVzKHtcbiAgICAgICAgICAgIHRlbGVtZXRyeSxcbiAgICAgICAgICAgIGF0dHJpYnV0ZXM6IHtcbiAgICAgICAgICAgICAgLi4uYXNzZW1ibGVPcGVyYXRpb25OYW1lKHtcbiAgICAgICAgICAgICAgICBvcGVyYXRpb25OYW1lOiBcImFpLnN0cmVhbU9iamVjdC5kb1N0cmVhbVwiLFxuICAgICAgICAgICAgICAgIHRlbGVtZXRyeVxuICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgICAgLi4uYmFzZVRlbGVtZXRyeUF0dHJpYnV0ZXMsXG4gICAgICAgICAgICAgIFwiYWkucHJvbXB0LmZvcm1hdFwiOiB7XG4gICAgICAgICAgICAgICAgaW5wdXQ6ICgpID0+IGNhbGxPcHRpb25zLmlucHV0Rm9ybWF0XG4gICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgIFwiYWkucHJvbXB0Lm1lc3NhZ2VzXCI6IHtcbiAgICAgICAgICAgICAgICBpbnB1dDogKCkgPT4gSlNPTi5zdHJpbmdpZnkoY2FsbE9wdGlvbnMucHJvbXB0KVxuICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICBcImFpLnNldHRpbmdzLm1vZGVcIjogbW9kZSxcbiAgICAgICAgICAgICAgLy8gc3RhbmRhcmRpemVkIGdlbi1haSBsbG0gc3BhbiBhdHRyaWJ1dGVzOlxuICAgICAgICAgICAgICBcImdlbl9haS5yZXF1ZXN0Lm1vZGVsXCI6IG1vZGVsLm1vZGVsSWQsXG4gICAgICAgICAgICAgIFwiZ2VuX2FpLnN5c3RlbVwiOiBtb2RlbC5wcm92aWRlcixcbiAgICAgICAgICAgICAgXCJnZW5fYWkucmVxdWVzdC5tYXhfdG9rZW5zXCI6IHNldHRpbmdzLm1heFRva2VucyxcbiAgICAgICAgICAgICAgXCJnZW5fYWkucmVxdWVzdC50ZW1wZXJhdHVyZVwiOiBzZXR0aW5ncy50ZW1wZXJhdHVyZSxcbiAgICAgICAgICAgICAgXCJnZW5fYWkucmVxdWVzdC50b3BfcFwiOiBzZXR0aW5ncy50b3BQXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSksXG4gICAgICAgICAgdHJhY2VyLFxuICAgICAgICAgIGVuZFdoZW5Eb25lOiBmYWxzZSxcbiAgICAgICAgICBmbjogYXN5bmMgKGRvU3RyZWFtU3BhbjIpID0+ICh7XG4gICAgICAgICAgICByZXN1bHQ6IGF3YWl0IG1vZGVsLmRvU3RyZWFtKGNhbGxPcHRpb25zKSxcbiAgICAgICAgICAgIGRvU3RyZWFtU3BhbjogZG9TdHJlYW1TcGFuMlxuICAgICAgICAgIH0pXG4gICAgICAgIH0pXG4gICAgICApO1xuICAgICAgcmV0dXJuIG5ldyBEZWZhdWx0U3RyZWFtT2JqZWN0UmVzdWx0KHtcbiAgICAgICAgc3RyZWFtOiBzdHJlYW0ucGlwZVRocm91Z2gobmV3IFRyYW5zZm9ybVN0cmVhbSh0cmFuc2Zvcm1lcikpLFxuICAgICAgICB3YXJuaW5ncyxcbiAgICAgICAgcmF3UmVzcG9uc2UsXG4gICAgICAgIHNjaGVtYSxcbiAgICAgICAgb25GaW5pc2gsXG4gICAgICAgIHJvb3RTcGFuLFxuICAgICAgICBkb1N0cmVhbVNwYW4sXG4gICAgICAgIHRlbGVtZXRyeVxuICAgICAgfSk7XG4gICAgfVxuICB9KTtcbn1cbnZhciBEZWZhdWx0U3RyZWFtT2JqZWN0UmVzdWx0ID0gY2xhc3Mge1xuICBjb25zdHJ1Y3Rvcih7XG4gICAgc3RyZWFtLFxuICAgIHdhcm5pbmdzLFxuICAgIHJhd1Jlc3BvbnNlLFxuICAgIHNjaGVtYSxcbiAgICBvbkZpbmlzaCxcbiAgICByb290U3BhbixcbiAgICBkb1N0cmVhbVNwYW4sXG4gICAgdGVsZW1ldHJ5XG4gIH0pIHtcbiAgICB0aGlzLndhcm5pbmdzID0gd2FybmluZ3M7XG4gICAgdGhpcy5yYXdSZXNwb25zZSA9IHJhd1Jlc3BvbnNlO1xuICAgIHRoaXMub2JqZWN0UHJvbWlzZSA9IG5ldyBEZWxheWVkUHJvbWlzZSgpO1xuICAgIGNvbnN0IHsgcmVzb2x2ZTogcmVzb2x2ZVVzYWdlLCBwcm9taXNlOiB1c2FnZVByb21pc2UgfSA9IGNyZWF0ZVJlc29sdmFibGVQcm9taXNlKCk7XG4gICAgdGhpcy51c2FnZSA9IHVzYWdlUHJvbWlzZTtcbiAgICBjb25zdCB7XG4gICAgICByZXNvbHZlOiByZXNvbHZlUHJvdmlkZXJNZXRhZGF0YSxcbiAgICAgIHByb21pc2U6IHByb3ZpZGVyTWV0YWRhdGFQcm9taXNlXG4gICAgfSA9IGNyZWF0ZVJlc29sdmFibGVQcm9taXNlKCk7XG4gICAgdGhpcy5leHBlcmltZW50YWxfcHJvdmlkZXJNZXRhZGF0YSA9IHByb3ZpZGVyTWV0YWRhdGFQcm9taXNlO1xuICAgIGxldCB1c2FnZTtcbiAgICBsZXQgZmluaXNoUmVhc29uO1xuICAgIGxldCBwcm92aWRlck1ldGFkYXRhO1xuICAgIGxldCBvYmplY3Q7XG4gICAgbGV0IGVycm9yO1xuICAgIGxldCBhY2N1bXVsYXRlZFRleHQgPSBcIlwiO1xuICAgIGxldCBkZWx0YSA9IFwiXCI7XG4gICAgbGV0IGxhdGVzdE9iamVjdCA9IHZvaWQgMDtcbiAgICBsZXQgZmlyc3RDaHVuayA9IHRydWU7XG4gICAgY29uc3Qgc2VsZiA9IHRoaXM7XG4gICAgdGhpcy5vcmlnaW5hbFN0cmVhbSA9IHN0cmVhbS5waXBlVGhyb3VnaChcbiAgICAgIG5ldyBUcmFuc2Zvcm1TdHJlYW0oe1xuICAgICAgICBhc3luYyB0cmFuc2Zvcm0oY2h1bmssIGNvbnRyb2xsZXIpIHtcbiAgICAgICAgICBpZiAoZmlyc3RDaHVuaykge1xuICAgICAgICAgICAgZmlyc3RDaHVuayA9IGZhbHNlO1xuICAgICAgICAgICAgZG9TdHJlYW1TcGFuLmFkZEV2ZW50KFwiYWkuc3RyZWFtLmZpcnN0Q2h1bmtcIik7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICh0eXBlb2YgY2h1bmsgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgIGFjY3VtdWxhdGVkVGV4dCArPSBjaHVuaztcbiAgICAgICAgICAgIGRlbHRhICs9IGNodW5rO1xuICAgICAgICAgICAgY29uc3QgY3VycmVudE9iamVjdCA9IHBhcnNlUGFydGlhbEpzb24oXG4gICAgICAgICAgICAgIGFjY3VtdWxhdGVkVGV4dFxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIGlmICghaXNEZWVwRXF1YWxEYXRhKGxhdGVzdE9iamVjdCwgY3VycmVudE9iamVjdCkpIHtcbiAgICAgICAgICAgICAgbGF0ZXN0T2JqZWN0ID0gY3VycmVudE9iamVjdDtcbiAgICAgICAgICAgICAgY29udHJvbGxlci5lbnF1ZXVlKHtcbiAgICAgICAgICAgICAgICB0eXBlOiBcIm9iamVjdFwiLFxuICAgICAgICAgICAgICAgIG9iamVjdDogY3VycmVudE9iamVjdFxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgY29udHJvbGxlci5lbnF1ZXVlKHtcbiAgICAgICAgICAgICAgICB0eXBlOiBcInRleHQtZGVsdGFcIixcbiAgICAgICAgICAgICAgICB0ZXh0RGVsdGE6IGRlbHRhXG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICBkZWx0YSA9IFwiXCI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICAgIHN3aXRjaCAoY2h1bmsudHlwZSkge1xuICAgICAgICAgICAgY2FzZSBcImZpbmlzaFwiOiB7XG4gICAgICAgICAgICAgIGlmIChkZWx0YSAhPT0gXCJcIikge1xuICAgICAgICAgICAgICAgIGNvbnRyb2xsZXIuZW5xdWV1ZSh7XG4gICAgICAgICAgICAgICAgICB0eXBlOiBcInRleHQtZGVsdGFcIixcbiAgICAgICAgICAgICAgICAgIHRleHREZWx0YTogZGVsdGFcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBmaW5pc2hSZWFzb24gPSBjaHVuay5maW5pc2hSZWFzb247XG4gICAgICAgICAgICAgIHVzYWdlID0gY2FsY3VsYXRlQ29tcGxldGlvblRva2VuVXNhZ2UoY2h1bmsudXNhZ2UpO1xuICAgICAgICAgICAgICBwcm92aWRlck1ldGFkYXRhID0gY2h1bmsucHJvdmlkZXJNZXRhZGF0YTtcbiAgICAgICAgICAgICAgY29udHJvbGxlci5lbnF1ZXVlKHsgLi4uY2h1bmssIHVzYWdlIH0pO1xuICAgICAgICAgICAgICByZXNvbHZlVXNhZ2UodXNhZ2UpO1xuICAgICAgICAgICAgICByZXNvbHZlUHJvdmlkZXJNZXRhZGF0YShwcm92aWRlck1ldGFkYXRhKTtcbiAgICAgICAgICAgICAgY29uc3QgdmFsaWRhdGlvblJlc3VsdCA9IHNhZmVWYWxpZGF0ZVR5cGVzKHtcbiAgICAgICAgICAgICAgICB2YWx1ZTogbGF0ZXN0T2JqZWN0LFxuICAgICAgICAgICAgICAgIHNjaGVtYVxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgaWYgKHZhbGlkYXRpb25SZXN1bHQuc3VjY2Vzcykge1xuICAgICAgICAgICAgICAgIG9iamVjdCA9IHZhbGlkYXRpb25SZXN1bHQudmFsdWU7XG4gICAgICAgICAgICAgICAgc2VsZi5vYmplY3RQcm9taXNlLnJlc29sdmUob2JqZWN0KTtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBlcnJvciA9IHZhbGlkYXRpb25SZXN1bHQuZXJyb3I7XG4gICAgICAgICAgICAgICAgc2VsZi5vYmplY3RQcm9taXNlLnJlamVjdChlcnJvcik7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBkZWZhdWx0OiB7XG4gICAgICAgICAgICAgIGNvbnRyb2xsZXIuZW5xdWV1ZShjaHVuayk7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgLy8gaW52b2tlIG9uRmluaXNoIGNhbGxiYWNrIGFuZCByZXNvbHZlIHRvb2xSZXN1bHRzIHByb21pc2Ugd2hlbiB0aGUgc3RyZWFtIGlzIGFib3V0IHRvIGNsb3NlOlxuICAgICAgICBhc3luYyBmbHVzaChjb250cm9sbGVyKSB7XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IGZpbmFsVXNhZ2UgPSB1c2FnZSAhPSBudWxsID8gdXNhZ2UgOiB7XG4gICAgICAgICAgICAgIHByb21wdFRva2VuczogTmFOLFxuICAgICAgICAgICAgICBjb21wbGV0aW9uVG9rZW5zOiBOYU4sXG4gICAgICAgICAgICAgIHRvdGFsVG9rZW5zOiBOYU5cbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBkb1N0cmVhbVNwYW4uc2V0QXR0cmlidXRlcyhcbiAgICAgICAgICAgICAgc2VsZWN0VGVsZW1ldHJ5QXR0cmlidXRlcyh7XG4gICAgICAgICAgICAgICAgdGVsZW1ldHJ5LFxuICAgICAgICAgICAgICAgIGF0dHJpYnV0ZXM6IHtcbiAgICAgICAgICAgICAgICAgIFwiYWkuZmluaXNoUmVhc29uXCI6IGZpbmlzaFJlYXNvbixcbiAgICAgICAgICAgICAgICAgIFwiYWkudXNhZ2UucHJvbXB0VG9rZW5zXCI6IGZpbmFsVXNhZ2UucHJvbXB0VG9rZW5zLFxuICAgICAgICAgICAgICAgICAgXCJhaS51c2FnZS5jb21wbGV0aW9uVG9rZW5zXCI6IGZpbmFsVXNhZ2UuY29tcGxldGlvblRva2VucyxcbiAgICAgICAgICAgICAgICAgIFwiYWkucmVzdWx0Lm9iamVjdFwiOiB7XG4gICAgICAgICAgICAgICAgICAgIG91dHB1dDogKCkgPT4gSlNPTi5zdHJpbmdpZnkob2JqZWN0KVxuICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgIC8vIHN0YW5kYXJkaXplZCBnZW4tYWkgbGxtIHNwYW4gYXR0cmlidXRlczpcbiAgICAgICAgICAgICAgICAgIFwiZ2VuX2FpLnVzYWdlLnByb21wdF90b2tlbnNcIjogZmluYWxVc2FnZS5wcm9tcHRUb2tlbnMsXG4gICAgICAgICAgICAgICAgICBcImdlbl9haS51c2FnZS5jb21wbGV0aW9uX3Rva2Vuc1wiOiBmaW5hbFVzYWdlLmNvbXBsZXRpb25Ub2tlbnMsXG4gICAgICAgICAgICAgICAgICBcImdlbl9haS5yZXNwb25zZS5maW5pc2hfcmVhc29uc1wiOiBbZmluaXNoUmVhc29uXVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICBkb1N0cmVhbVNwYW4uZW5kKCk7XG4gICAgICAgICAgICByb290U3Bhbi5zZXRBdHRyaWJ1dGVzKFxuICAgICAgICAgICAgICBzZWxlY3RUZWxlbWV0cnlBdHRyaWJ1dGVzKHtcbiAgICAgICAgICAgICAgICB0ZWxlbWV0cnksXG4gICAgICAgICAgICAgICAgYXR0cmlidXRlczoge1xuICAgICAgICAgICAgICAgICAgXCJhaS51c2FnZS5wcm9tcHRUb2tlbnNcIjogZmluYWxVc2FnZS5wcm9tcHRUb2tlbnMsXG4gICAgICAgICAgICAgICAgICBcImFpLnVzYWdlLmNvbXBsZXRpb25Ub2tlbnNcIjogZmluYWxVc2FnZS5jb21wbGV0aW9uVG9rZW5zLFxuICAgICAgICAgICAgICAgICAgXCJhaS5yZXN1bHQub2JqZWN0XCI6IHtcbiAgICAgICAgICAgICAgICAgICAgb3V0cHV0OiAoKSA9PiBKU09OLnN0cmluZ2lmeShvYmplY3QpXG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIGF3YWl0IChvbkZpbmlzaCA9PSBudWxsID8gdm9pZCAwIDogb25GaW5pc2goe1xuICAgICAgICAgICAgICB1c2FnZTogZmluYWxVc2FnZSxcbiAgICAgICAgICAgICAgb2JqZWN0LFxuICAgICAgICAgICAgICBlcnJvcixcbiAgICAgICAgICAgICAgcmF3UmVzcG9uc2UsXG4gICAgICAgICAgICAgIHdhcm5pbmdzLFxuICAgICAgICAgICAgICBleHBlcmltZW50YWxfcHJvdmlkZXJNZXRhZGF0YTogcHJvdmlkZXJNZXRhZGF0YVxuICAgICAgICAgICAgfSkpO1xuICAgICAgICAgIH0gY2F0Y2ggKGVycm9yMikge1xuICAgICAgICAgICAgY29udHJvbGxlci5lcnJvcihlcnJvcjIpO1xuICAgICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICByb290U3Bhbi5lbmQoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0pXG4gICAgKTtcbiAgfVxuICBnZXQgb2JqZWN0KCkge1xuICAgIHJldHVybiB0aGlzLm9iamVjdFByb21pc2UudmFsdWU7XG4gIH1cbiAgZ2V0IHBhcnRpYWxPYmplY3RTdHJlYW0oKSB7XG4gICAgcmV0dXJuIGNyZWF0ZUFzeW5jSXRlcmFibGVTdHJlYW0odGhpcy5vcmlnaW5hbFN0cmVhbSwge1xuICAgICAgdHJhbnNmb3JtKGNodW5rLCBjb250cm9sbGVyKSB7XG4gICAgICAgIHN3aXRjaCAoY2h1bmsudHlwZSkge1xuICAgICAgICAgIGNhc2UgXCJvYmplY3RcIjpcbiAgICAgICAgICAgIGNvbnRyb2xsZXIuZW5xdWV1ZShjaHVuay5vYmplY3QpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSBcInRleHQtZGVsdGFcIjpcbiAgICAgICAgICBjYXNlIFwiZmluaXNoXCI6XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIFwiZXJyb3JcIjpcbiAgICAgICAgICAgIGNvbnRyb2xsZXIuZXJyb3IoY2h1bmsuZXJyb3IpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgZGVmYXVsdDoge1xuICAgICAgICAgICAgY29uc3QgX2V4aGF1c3RpdmVDaGVjayA9IGNodW5rO1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBVbnN1cHBvcnRlZCBjaHVuayB0eXBlOiAke19leGhhdXN0aXZlQ2hlY2t9YCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbiAgZ2V0IHRleHRTdHJlYW0oKSB7XG4gICAgcmV0dXJuIGNyZWF0ZUFzeW5jSXRlcmFibGVTdHJlYW0odGhpcy5vcmlnaW5hbFN0cmVhbSwge1xuICAgICAgdHJhbnNmb3JtKGNodW5rLCBjb250cm9sbGVyKSB7XG4gICAgICAgIHN3aXRjaCAoY2h1bmsudHlwZSkge1xuICAgICAgICAgIGNhc2UgXCJ0ZXh0LWRlbHRhXCI6XG4gICAgICAgICAgICBjb250cm9sbGVyLmVucXVldWUoY2h1bmsudGV4dERlbHRhKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgXCJvYmplY3RcIjpcbiAgICAgICAgICBjYXNlIFwiZmluaXNoXCI6XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIFwiZXJyb3JcIjpcbiAgICAgICAgICAgIGNvbnRyb2xsZXIuZXJyb3IoY2h1bmsuZXJyb3IpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgZGVmYXVsdDoge1xuICAgICAgICAgICAgY29uc3QgX2V4aGF1c3RpdmVDaGVjayA9IGNodW5rO1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBVbnN1cHBvcnRlZCBjaHVuayB0eXBlOiAke19leGhhdXN0aXZlQ2hlY2t9YCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbiAgZ2V0IGZ1bGxTdHJlYW0oKSB7XG4gICAgcmV0dXJuIGNyZWF0ZUFzeW5jSXRlcmFibGVTdHJlYW0odGhpcy5vcmlnaW5hbFN0cmVhbSwge1xuICAgICAgdHJhbnNmb3JtKGNodW5rLCBjb250cm9sbGVyKSB7XG4gICAgICAgIGNvbnRyb2xsZXIuZW5xdWV1ZShjaHVuayk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbiAgcGlwZVRleHRTdHJlYW1Ub1Jlc3BvbnNlKHJlc3BvbnNlLCBpbml0KSB7XG4gICAgdmFyIF9hMTI7XG4gICAgcmVzcG9uc2Uud3JpdGVIZWFkKChfYTEyID0gaW5pdCA9PSBudWxsID8gdm9pZCAwIDogaW5pdC5zdGF0dXMpICE9IG51bGwgPyBfYTEyIDogMjAwLCB7XG4gICAgICBcIkNvbnRlbnQtVHlwZVwiOiBcInRleHQvcGxhaW47IGNoYXJzZXQ9dXRmLThcIixcbiAgICAgIC4uLmluaXQgPT0gbnVsbCA/IHZvaWQgMCA6IGluaXQuaGVhZGVyc1xuICAgIH0pO1xuICAgIGNvbnN0IHJlYWRlciA9IHRoaXMudGV4dFN0cmVhbS5waXBlVGhyb3VnaChuZXcgVGV4dEVuY29kZXJTdHJlYW0oKSkuZ2V0UmVhZGVyKCk7XG4gICAgY29uc3QgcmVhZCA9IGFzeW5jICgpID0+IHtcbiAgICAgIHRyeSB7XG4gICAgICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICAgICAgY29uc3QgeyBkb25lLCB2YWx1ZSB9ID0gYXdhaXQgcmVhZGVyLnJlYWQoKTtcbiAgICAgICAgICBpZiAoZG9uZSlcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIHJlc3BvbnNlLndyaXRlKHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICByZXNwb25zZS5lbmQoKTtcbiAgICAgIH1cbiAgICB9O1xuICAgIHJlYWQoKTtcbiAgfVxuICB0b1RleHRTdHJlYW1SZXNwb25zZShpbml0KSB7XG4gICAgdmFyIF9hMTI7XG4gICAgcmV0dXJuIG5ldyBSZXNwb25zZSh0aGlzLnRleHRTdHJlYW0ucGlwZVRocm91Z2gobmV3IFRleHRFbmNvZGVyU3RyZWFtKCkpLCB7XG4gICAgICBzdGF0dXM6IChfYTEyID0gaW5pdCA9PSBudWxsID8gdm9pZCAwIDogaW5pdC5zdGF0dXMpICE9IG51bGwgPyBfYTEyIDogMjAwLFxuICAgICAgaGVhZGVyczogcHJlcGFyZVJlc3BvbnNlSGVhZGVycyhpbml0LCB7XG4gICAgICAgIGNvbnRlbnRUeXBlOiBcInRleHQvcGxhaW47IGNoYXJzZXQ9dXRmLThcIlxuICAgICAgfSlcbiAgICB9KTtcbiAgfVxufTtcbnZhciBleHBlcmltZW50YWxfc3RyZWFtT2JqZWN0ID0gc3RyZWFtT2JqZWN0O1xuXG4vLyBjb3JlL3Byb21wdC9wcmVwYXJlLXRvb2xzLWFuZC10b29sLWNob2ljZS50c1xuaW1wb3J0IHsgYXNTY2hlbWEgYXMgYXNTY2hlbWEzIH0gZnJvbSBcIkBhaS1zZGsvdWktdXRpbHNcIjtcblxuLy8gY29yZS91dGlsL2lzLW5vbi1lbXB0eS1vYmplY3QudHNcbmZ1bmN0aW9uIGlzTm9uRW1wdHlPYmplY3Qob2JqZWN0KSB7XG4gIHJldHVybiBvYmplY3QgIT0gbnVsbCAmJiBPYmplY3Qua2V5cyhvYmplY3QpLmxlbmd0aCA+IDA7XG59XG5cbi8vIGNvcmUvcHJvbXB0L3ByZXBhcmUtdG9vbHMtYW5kLXRvb2wtY2hvaWNlLnRzXG5mdW5jdGlvbiBwcmVwYXJlVG9vbHNBbmRUb29sQ2hvaWNlKHtcbiAgdG9vbHMsXG4gIHRvb2xDaG9pY2Vcbn0pIHtcbiAgaWYgKCFpc05vbkVtcHR5T2JqZWN0KHRvb2xzKSkge1xuICAgIHJldHVybiB7XG4gICAgICB0b29sczogdm9pZCAwLFxuICAgICAgdG9vbENob2ljZTogdm9pZCAwXG4gICAgfTtcbiAgfVxuICByZXR1cm4ge1xuICAgIHRvb2xzOiBPYmplY3QuZW50cmllcyh0b29scykubWFwKChbbmFtZTEyLCB0b29sMl0pID0+ICh7XG4gICAgICB0eXBlOiBcImZ1bmN0aW9uXCIsXG4gICAgICBuYW1lOiBuYW1lMTIsXG4gICAgICBkZXNjcmlwdGlvbjogdG9vbDIuZGVzY3JpcHRpb24sXG4gICAgICBwYXJhbWV0ZXJzOiBhc1NjaGVtYTModG9vbDIucGFyYW1ldGVycykuanNvblNjaGVtYVxuICAgIH0pKSxcbiAgICB0b29sQ2hvaWNlOiB0b29sQ2hvaWNlID09IG51bGwgPyB7IHR5cGU6IFwiYXV0b1wiIH0gOiB0eXBlb2YgdG9vbENob2ljZSA9PT0gXCJzdHJpbmdcIiA/IHsgdHlwZTogdG9vbENob2ljZSB9IDogeyB0eXBlOiBcInRvb2xcIiwgdG9vbE5hbWU6IHRvb2xDaG9pY2UudG9vbE5hbWUgfVxuICB9O1xufVxuXG4vLyBjb3JlL2dlbmVyYXRlLXRleHQvdG9vbC1jYWxsLnRzXG5pbXBvcnQgeyBzYWZlUGFyc2VKU09OIGFzIHNhZmVQYXJzZUpTT04yIH0gZnJvbSBcIkBhaS1zZGsvcHJvdmlkZXItdXRpbHNcIjtcbmltcG9ydCB7IGFzU2NoZW1hIGFzIGFzU2NoZW1hNCB9IGZyb20gXCJAYWktc2RrL3VpLXV0aWxzXCI7XG5cbi8vIGVycm9ycy9pbnZhbGlkLXRvb2wtYXJndW1lbnRzLWVycm9yLnRzXG5pbXBvcnQgeyBBSVNES0Vycm9yIGFzIEFJU0RLRXJyb3I3LCBnZXRFcnJvck1lc3NhZ2UgYXMgZ2V0RXJyb3JNZXNzYWdlMyB9IGZyb20gXCJAYWktc2RrL3Byb3ZpZGVyXCI7XG52YXIgbmFtZTcgPSBcIkFJX0ludmFsaWRUb29sQXJndW1lbnRzRXJyb3JcIjtcbnZhciBtYXJrZXI3ID0gYHZlcmNlbC5haS5lcnJvci4ke25hbWU3fWA7XG52YXIgc3ltYm9sNyA9IFN5bWJvbC5mb3IobWFya2VyNyk7XG52YXIgX2E3O1xudmFyIEludmFsaWRUb29sQXJndW1lbnRzRXJyb3IgPSBjbGFzcyBleHRlbmRzIEFJU0RLRXJyb3I3IHtcbiAgY29uc3RydWN0b3Ioe1xuICAgIHRvb2xBcmdzLFxuICAgIHRvb2xOYW1lLFxuICAgIGNhdXNlLFxuICAgIG1lc3NhZ2UgPSBgSW52YWxpZCBhcmd1bWVudHMgZm9yIHRvb2wgJHt0b29sTmFtZX06ICR7Z2V0RXJyb3JNZXNzYWdlMyhcbiAgICAgIGNhdXNlXG4gICAgKX1gXG4gIH0pIHtcbiAgICBzdXBlcih7IG5hbWU6IG5hbWU3LCBtZXNzYWdlLCBjYXVzZSB9KTtcbiAgICB0aGlzW19hN10gPSB0cnVlO1xuICAgIHRoaXMudG9vbEFyZ3MgPSB0b29sQXJncztcbiAgICB0aGlzLnRvb2xOYW1lID0gdG9vbE5hbWU7XG4gIH1cbiAgc3RhdGljIGlzSW5zdGFuY2UoZXJyb3IpIHtcbiAgICByZXR1cm4gQUlTREtFcnJvcjcuaGFzTWFya2VyKGVycm9yLCBtYXJrZXI3KTtcbiAgfVxuICAvKipcbiAgICogQGRlcHJlY2F0ZWQgdXNlIGBpc0luc3RhbmNlYCBpbnN0ZWFkXG4gICAqL1xuICBzdGF0aWMgaXNJbnZhbGlkVG9vbEFyZ3VtZW50c0Vycm9yKGVycm9yKSB7XG4gICAgcmV0dXJuIGVycm9yIGluc3RhbmNlb2YgRXJyb3IgJiYgZXJyb3IubmFtZSA9PT0gbmFtZTcgJiYgdHlwZW9mIGVycm9yLnRvb2xOYW1lID09PSBcInN0cmluZ1wiICYmIHR5cGVvZiBlcnJvci50b29sQXJncyA9PT0gXCJzdHJpbmdcIjtcbiAgfVxuICAvKipcbiAgICogQGRlcHJlY2F0ZWQgRG8gbm90IHVzZSB0aGlzIG1ldGhvZC4gSXQgd2lsbCBiZSByZW1vdmVkIGluIHRoZSBuZXh0IG1ham9yIHZlcnNpb24uXG4gICAqL1xuICB0b0pTT04oKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIG5hbWU6IHRoaXMubmFtZSxcbiAgICAgIG1lc3NhZ2U6IHRoaXMubWVzc2FnZSxcbiAgICAgIGNhdXNlOiB0aGlzLmNhdXNlLFxuICAgICAgc3RhY2s6IHRoaXMuc3RhY2ssXG4gICAgICB0b29sTmFtZTogdGhpcy50b29sTmFtZSxcbiAgICAgIHRvb2xBcmdzOiB0aGlzLnRvb2xBcmdzXG4gICAgfTtcbiAgfVxufTtcbl9hNyA9IHN5bWJvbDc7XG5cbi8vIGVycm9ycy9uby1zdWNoLXRvb2wtZXJyb3IudHNcbmltcG9ydCB7IEFJU0RLRXJyb3IgYXMgQUlTREtFcnJvcjggfSBmcm9tIFwiQGFpLXNkay9wcm92aWRlclwiO1xudmFyIG5hbWU4ID0gXCJBSV9Ob1N1Y2hUb29sRXJyb3JcIjtcbnZhciBtYXJrZXI4ID0gYHZlcmNlbC5haS5lcnJvci4ke25hbWU4fWA7XG52YXIgc3ltYm9sOCA9IFN5bWJvbC5mb3IobWFya2VyOCk7XG52YXIgX2E4O1xudmFyIE5vU3VjaFRvb2xFcnJvciA9IGNsYXNzIGV4dGVuZHMgQUlTREtFcnJvcjgge1xuICBjb25zdHJ1Y3Rvcih7XG4gICAgdG9vbE5hbWUsXG4gICAgYXZhaWxhYmxlVG9vbHMgPSB2b2lkIDAsXG4gICAgbWVzc2FnZSA9IGBNb2RlbCB0cmllZCB0byBjYWxsIHVuYXZhaWxhYmxlIHRvb2wgJyR7dG9vbE5hbWV9Jy4gJHthdmFpbGFibGVUb29scyA9PT0gdm9pZCAwID8gXCJObyB0b29scyBhcmUgYXZhaWxhYmxlLlwiIDogYEF2YWlsYWJsZSB0b29sczogJHthdmFpbGFibGVUb29scy5qb2luKFwiLCBcIil9LmB9YFxuICB9KSB7XG4gICAgc3VwZXIoeyBuYW1lOiBuYW1lOCwgbWVzc2FnZSB9KTtcbiAgICB0aGlzW19hOF0gPSB0cnVlO1xuICAgIHRoaXMudG9vbE5hbWUgPSB0b29sTmFtZTtcbiAgICB0aGlzLmF2YWlsYWJsZVRvb2xzID0gYXZhaWxhYmxlVG9vbHM7XG4gIH1cbiAgc3RhdGljIGlzSW5zdGFuY2UoZXJyb3IpIHtcbiAgICByZXR1cm4gQUlTREtFcnJvcjguaGFzTWFya2VyKGVycm9yLCBtYXJrZXI4KTtcbiAgfVxuICAvKipcbiAgICogQGRlcHJlY2F0ZWQgdXNlIGBpc0luc3RhbmNlYCBpbnN0ZWFkXG4gICAqL1xuICBzdGF0aWMgaXNOb1N1Y2hUb29sRXJyb3IoZXJyb3IpIHtcbiAgICByZXR1cm4gZXJyb3IgaW5zdGFuY2VvZiBFcnJvciAmJiBlcnJvci5uYW1lID09PSBuYW1lOCAmJiBcInRvb2xOYW1lXCIgaW4gZXJyb3IgJiYgZXJyb3IudG9vbE5hbWUgIT0gdm9pZCAwICYmIHR5cGVvZiBlcnJvci5uYW1lID09PSBcInN0cmluZ1wiO1xuICB9XG4gIC8qKlxuICAgKiBAZGVwcmVjYXRlZCBEbyBub3QgdXNlIHRoaXMgbWV0aG9kLiBJdCB3aWxsIGJlIHJlbW92ZWQgaW4gdGhlIG5leHQgbWFqb3IgdmVyc2lvbi5cbiAgICovXG4gIHRvSlNPTigpIHtcbiAgICByZXR1cm4ge1xuICAgICAgbmFtZTogdGhpcy5uYW1lLFxuICAgICAgbWVzc2FnZTogdGhpcy5tZXNzYWdlLFxuICAgICAgc3RhY2s6IHRoaXMuc3RhY2ssXG4gICAgICB0b29sTmFtZTogdGhpcy50b29sTmFtZSxcbiAgICAgIGF2YWlsYWJsZVRvb2xzOiB0aGlzLmF2YWlsYWJsZVRvb2xzXG4gICAgfTtcbiAgfVxufTtcbl9hOCA9IHN5bWJvbDg7XG5cbi8vIGNvcmUvZ2VuZXJhdGUtdGV4dC90b29sLWNhbGwudHNcbmZ1bmN0aW9uIHBhcnNlVG9vbENhbGwoe1xuICB0b29sQ2FsbCxcbiAgdG9vbHNcbn0pIHtcbiAgY29uc3QgdG9vbE5hbWUgPSB0b29sQ2FsbC50b29sTmFtZTtcbiAgaWYgKHRvb2xzID09IG51bGwpIHtcbiAgICB0aHJvdyBuZXcgTm9TdWNoVG9vbEVycm9yKHsgdG9vbE5hbWU6IHRvb2xDYWxsLnRvb2xOYW1lIH0pO1xuICB9XG4gIGNvbnN0IHRvb2wyID0gdG9vbHNbdG9vbE5hbWVdO1xuICBpZiAodG9vbDIgPT0gbnVsbCkge1xuICAgIHRocm93IG5ldyBOb1N1Y2hUb29sRXJyb3Ioe1xuICAgICAgdG9vbE5hbWU6IHRvb2xDYWxsLnRvb2xOYW1lLFxuICAgICAgYXZhaWxhYmxlVG9vbHM6IE9iamVjdC5rZXlzKHRvb2xzKVxuICAgIH0pO1xuICB9XG4gIGNvbnN0IHBhcnNlUmVzdWx0ID0gc2FmZVBhcnNlSlNPTjIoe1xuICAgIHRleHQ6IHRvb2xDYWxsLmFyZ3MsXG4gICAgc2NoZW1hOiBhc1NjaGVtYTQodG9vbDIucGFyYW1ldGVycylcbiAgfSk7XG4gIGlmIChwYXJzZVJlc3VsdC5zdWNjZXNzID09PSBmYWxzZSkge1xuICAgIHRocm93IG5ldyBJbnZhbGlkVG9vbEFyZ3VtZW50c0Vycm9yKHtcbiAgICAgIHRvb2xOYW1lLFxuICAgICAgdG9vbEFyZ3M6IHRvb2xDYWxsLmFyZ3MsXG4gICAgICBjYXVzZTogcGFyc2VSZXN1bHQuZXJyb3JcbiAgICB9KTtcbiAgfVxuICByZXR1cm4ge1xuICAgIHR5cGU6IFwidG9vbC1jYWxsXCIsXG4gICAgdG9vbENhbGxJZDogdG9vbENhbGwudG9vbENhbGxJZCxcbiAgICB0b29sTmFtZSxcbiAgICBhcmdzOiBwYXJzZVJlc3VsdC52YWx1ZVxuICB9O1xufVxuXG4vLyBjb3JlL2dlbmVyYXRlLXRleHQvZ2VuZXJhdGUtdGV4dC50c1xuYXN5bmMgZnVuY3Rpb24gZ2VuZXJhdGVUZXh0KHtcbiAgbW9kZWwsXG4gIHRvb2xzLFxuICB0b29sQ2hvaWNlLFxuICBzeXN0ZW0sXG4gIHByb21wdCxcbiAgbWVzc2FnZXMsXG4gIG1heFJldHJpZXMsXG4gIGFib3J0U2lnbmFsLFxuICBoZWFkZXJzLFxuICBtYXhBdXRvbWF0aWNSb3VuZHRyaXBzID0gMCxcbiAgbWF4VG9vbFJvdW5kdHJpcHMgPSBtYXhBdXRvbWF0aWNSb3VuZHRyaXBzLFxuICBleHBlcmltZW50YWxfdGVsZW1ldHJ5OiB0ZWxlbWV0cnksXG4gIC4uLnNldHRpbmdzXG59KSB7XG4gIHZhciBfYTEyO1xuICBjb25zdCBiYXNlVGVsZW1ldHJ5QXR0cmlidXRlcyA9IGdldEJhc2VUZWxlbWV0cnlBdHRyaWJ1dGVzKHtcbiAgICBtb2RlbCxcbiAgICB0ZWxlbWV0cnksXG4gICAgaGVhZGVycyxcbiAgICBzZXR0aW5nczogeyAuLi5zZXR0aW5ncywgbWF4UmV0cmllcyB9XG4gIH0pO1xuICBjb25zdCB0cmFjZXIgPSBnZXRUcmFjZXIoeyBpc0VuYWJsZWQ6IChfYTEyID0gdGVsZW1ldHJ5ID09IG51bGwgPyB2b2lkIDAgOiB0ZWxlbWV0cnkuaXNFbmFibGVkKSAhPSBudWxsID8gX2ExMiA6IGZhbHNlIH0pO1xuICByZXR1cm4gcmVjb3JkU3Bhbih7XG4gICAgbmFtZTogXCJhaS5nZW5lcmF0ZVRleHRcIixcbiAgICBhdHRyaWJ1dGVzOiBzZWxlY3RUZWxlbWV0cnlBdHRyaWJ1dGVzKHtcbiAgICAgIHRlbGVtZXRyeSxcbiAgICAgIGF0dHJpYnV0ZXM6IHtcbiAgICAgICAgLi4uYXNzZW1ibGVPcGVyYXRpb25OYW1lKHtcbiAgICAgICAgICBvcGVyYXRpb25OYW1lOiBcImFpLmdlbmVyYXRlVGV4dFwiLFxuICAgICAgICAgIHRlbGVtZXRyeVxuICAgICAgICB9KSxcbiAgICAgICAgLi4uYmFzZVRlbGVtZXRyeUF0dHJpYnV0ZXMsXG4gICAgICAgIC8vIHNwZWNpZmljIHNldHRpbmdzIHRoYXQgb25seSBtYWtlIHNlbnNlIG9uIHRoZSBvdXRlciBsZXZlbDpcbiAgICAgICAgXCJhaS5wcm9tcHRcIjoge1xuICAgICAgICAgIGlucHV0OiAoKSA9PiBKU09OLnN0cmluZ2lmeSh7IHN5c3RlbSwgcHJvbXB0LCBtZXNzYWdlcyB9KVxuICAgICAgICB9LFxuICAgICAgICBcImFpLnNldHRpbmdzLm1heFRvb2xSb3VuZHRyaXBzXCI6IG1heFRvb2xSb3VuZHRyaXBzXG4gICAgICB9XG4gICAgfSksXG4gICAgdHJhY2VyLFxuICAgIGZuOiBhc3luYyAoc3BhbikgPT4ge1xuICAgICAgdmFyIF9hMTMsIF9iLCBfYywgX2Q7XG4gICAgICBjb25zdCByZXRyeSA9IHJldHJ5V2l0aEV4cG9uZW50aWFsQmFja29mZih7IG1heFJldHJpZXMgfSk7XG4gICAgICBjb25zdCB2YWxpZGF0ZWRQcm9tcHQgPSBnZXRWYWxpZGF0ZWRQcm9tcHQoe1xuICAgICAgICBzeXN0ZW0sXG4gICAgICAgIHByb21wdCxcbiAgICAgICAgbWVzc2FnZXNcbiAgICAgIH0pO1xuICAgICAgY29uc3QgbW9kZSA9IHtcbiAgICAgICAgdHlwZTogXCJyZWd1bGFyXCIsXG4gICAgICAgIC4uLnByZXBhcmVUb29sc0FuZFRvb2xDaG9pY2UoeyB0b29scywgdG9vbENob2ljZSB9KVxuICAgICAgfTtcbiAgICAgIGNvbnN0IGNhbGxTZXR0aW5ncyA9IHByZXBhcmVDYWxsU2V0dGluZ3Moc2V0dGluZ3MpO1xuICAgICAgY29uc3QgcHJvbXB0TWVzc2FnZXMgPSBhd2FpdCBjb252ZXJ0VG9MYW5ndWFnZU1vZGVsUHJvbXB0KHtcbiAgICAgICAgcHJvbXB0OiB2YWxpZGF0ZWRQcm9tcHQsXG4gICAgICAgIG1vZGVsU3VwcG9ydHNJbWFnZVVybHM6IG1vZGVsLnN1cHBvcnRzSW1hZ2VVcmxzXG4gICAgICB9KTtcbiAgICAgIGxldCBjdXJyZW50TW9kZWxSZXNwb25zZTtcbiAgICAgIGxldCBjdXJyZW50VG9vbENhbGxzID0gW107XG4gICAgICBsZXQgY3VycmVudFRvb2xSZXN1bHRzID0gW107XG4gICAgICBsZXQgcm91bmR0cmlwQ291bnQgPSAwO1xuICAgICAgY29uc3QgcmVzcG9uc2VNZXNzYWdlcyA9IFtdO1xuICAgICAgY29uc3Qgcm91bmR0cmlwcyA9IFtdO1xuICAgICAgY29uc3QgdXNhZ2UgPSB7XG4gICAgICAgIGNvbXBsZXRpb25Ub2tlbnM6IDAsXG4gICAgICAgIHByb21wdFRva2VuczogMCxcbiAgICAgICAgdG90YWxUb2tlbnM6IDBcbiAgICAgIH07XG4gICAgICBkbyB7XG4gICAgICAgIGNvbnN0IGN1cnJlbnRJbnB1dEZvcm1hdCA9IHJvdW5kdHJpcENvdW50ID09PSAwID8gdmFsaWRhdGVkUHJvbXB0LnR5cGUgOiBcIm1lc3NhZ2VzXCI7XG4gICAgICAgIGN1cnJlbnRNb2RlbFJlc3BvbnNlID0gYXdhaXQgcmV0cnkoXG4gICAgICAgICAgKCkgPT4gcmVjb3JkU3Bhbih7XG4gICAgICAgICAgICBuYW1lOiBcImFpLmdlbmVyYXRlVGV4dC5kb0dlbmVyYXRlXCIsXG4gICAgICAgICAgICBhdHRyaWJ1dGVzOiBzZWxlY3RUZWxlbWV0cnlBdHRyaWJ1dGVzKHtcbiAgICAgICAgICAgICAgdGVsZW1ldHJ5LFxuICAgICAgICAgICAgICBhdHRyaWJ1dGVzOiB7XG4gICAgICAgICAgICAgICAgLi4uYXNzZW1ibGVPcGVyYXRpb25OYW1lKHtcbiAgICAgICAgICAgICAgICAgIG9wZXJhdGlvbk5hbWU6IFwiYWkuZ2VuZXJhdGVUZXh0LmRvR2VuZXJhdGVcIixcbiAgICAgICAgICAgICAgICAgIHRlbGVtZXRyeVxuICAgICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgICAgIC4uLmJhc2VUZWxlbWV0cnlBdHRyaWJ1dGVzLFxuICAgICAgICAgICAgICAgIFwiYWkucHJvbXB0LmZvcm1hdFwiOiB7IGlucHV0OiAoKSA9PiBjdXJyZW50SW5wdXRGb3JtYXQgfSxcbiAgICAgICAgICAgICAgICBcImFpLnByb21wdC5tZXNzYWdlc1wiOiB7XG4gICAgICAgICAgICAgICAgICBpbnB1dDogKCkgPT4gSlNPTi5zdHJpbmdpZnkocHJvbXB0TWVzc2FnZXMpXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAvLyBzdGFuZGFyZGl6ZWQgZ2VuLWFpIGxsbSBzcGFuIGF0dHJpYnV0ZXM6XG4gICAgICAgICAgICAgICAgXCJnZW5fYWkucmVxdWVzdC5tb2RlbFwiOiBtb2RlbC5tb2RlbElkLFxuICAgICAgICAgICAgICAgIFwiZ2VuX2FpLnN5c3RlbVwiOiBtb2RlbC5wcm92aWRlcixcbiAgICAgICAgICAgICAgICBcImdlbl9haS5yZXF1ZXN0Lm1heF90b2tlbnNcIjogc2V0dGluZ3MubWF4VG9rZW5zLFxuICAgICAgICAgICAgICAgIFwiZ2VuX2FpLnJlcXVlc3QudGVtcGVyYXR1cmVcIjogc2V0dGluZ3MudGVtcGVyYXR1cmUsXG4gICAgICAgICAgICAgICAgXCJnZW5fYWkucmVxdWVzdC50b3BfcFwiOiBzZXR0aW5ncy50b3BQXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgdHJhY2VyLFxuICAgICAgICAgICAgZm46IGFzeW5jIChzcGFuMikgPT4ge1xuICAgICAgICAgICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBtb2RlbC5kb0dlbmVyYXRlKHtcbiAgICAgICAgICAgICAgICBtb2RlLFxuICAgICAgICAgICAgICAgIC4uLmNhbGxTZXR0aW5ncyxcbiAgICAgICAgICAgICAgICBpbnB1dEZvcm1hdDogY3VycmVudElucHV0Rm9ybWF0LFxuICAgICAgICAgICAgICAgIHByb21wdDogcHJvbXB0TWVzc2FnZXMsXG4gICAgICAgICAgICAgICAgYWJvcnRTaWduYWwsXG4gICAgICAgICAgICAgICAgaGVhZGVyc1xuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgc3BhbjIuc2V0QXR0cmlidXRlcyhcbiAgICAgICAgICAgICAgICBzZWxlY3RUZWxlbWV0cnlBdHRyaWJ1dGVzKHtcbiAgICAgICAgICAgICAgICAgIHRlbGVtZXRyeSxcbiAgICAgICAgICAgICAgICAgIGF0dHJpYnV0ZXM6IHtcbiAgICAgICAgICAgICAgICAgICAgXCJhaS5maW5pc2hSZWFzb25cIjogcmVzdWx0LmZpbmlzaFJlYXNvbixcbiAgICAgICAgICAgICAgICAgICAgXCJhaS51c2FnZS5wcm9tcHRUb2tlbnNcIjogcmVzdWx0LnVzYWdlLnByb21wdFRva2VucyxcbiAgICAgICAgICAgICAgICAgICAgXCJhaS51c2FnZS5jb21wbGV0aW9uVG9rZW5zXCI6IHJlc3VsdC51c2FnZS5jb21wbGV0aW9uVG9rZW5zLFxuICAgICAgICAgICAgICAgICAgICBcImFpLnJlc3VsdC50ZXh0XCI6IHtcbiAgICAgICAgICAgICAgICAgICAgICBvdXRwdXQ6ICgpID0+IHJlc3VsdC50ZXh0XG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIFwiYWkucmVzdWx0LnRvb2xDYWxsc1wiOiB7XG4gICAgICAgICAgICAgICAgICAgICAgb3V0cHV0OiAoKSA9PiBKU09OLnN0cmluZ2lmeShyZXN1bHQudG9vbENhbGxzKVxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAvLyBzdGFuZGFyZGl6ZWQgZ2VuLWFpIGxsbSBzcGFuIGF0dHJpYnV0ZXM6XG4gICAgICAgICAgICAgICAgICAgIFwiZ2VuX2FpLnJlc3BvbnNlLmZpbmlzaF9yZWFzb25zXCI6IFtyZXN1bHQuZmluaXNoUmVhc29uXSxcbiAgICAgICAgICAgICAgICAgICAgXCJnZW5fYWkudXNhZ2UucHJvbXB0X3Rva2Vuc1wiOiByZXN1bHQudXNhZ2UucHJvbXB0VG9rZW5zLFxuICAgICAgICAgICAgICAgICAgICBcImdlbl9haS51c2FnZS5jb21wbGV0aW9uX3Rva2Vuc1wiOiByZXN1bHQudXNhZ2UuY29tcGxldGlvblRva2Vuc1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSlcbiAgICAgICAgKTtcbiAgICAgICAgY3VycmVudFRvb2xDYWxscyA9ICgoX2ExMyA9IGN1cnJlbnRNb2RlbFJlc3BvbnNlLnRvb2xDYWxscykgIT0gbnVsbCA/IF9hMTMgOiBbXSkubWFwKFxuICAgICAgICAgIChtb2RlbFRvb2xDYWxsKSA9PiBwYXJzZVRvb2xDYWxsKHsgdG9vbENhbGw6IG1vZGVsVG9vbENhbGwsIHRvb2xzIH0pXG4gICAgICAgICk7XG4gICAgICAgIGN1cnJlbnRUb29sUmVzdWx0cyA9IHRvb2xzID09IG51bGwgPyBbXSA6IGF3YWl0IGV4ZWN1dGVUb29scyh7XG4gICAgICAgICAgdG9vbENhbGxzOiBjdXJyZW50VG9vbENhbGxzLFxuICAgICAgICAgIHRvb2xzLFxuICAgICAgICAgIHRyYWNlcixcbiAgICAgICAgICB0ZWxlbWV0cnlcbiAgICAgICAgfSk7XG4gICAgICAgIGNvbnN0IGN1cnJlbnRVc2FnZSA9IGNhbGN1bGF0ZUNvbXBsZXRpb25Ub2tlblVzYWdlKFxuICAgICAgICAgIGN1cnJlbnRNb2RlbFJlc3BvbnNlLnVzYWdlXG4gICAgICAgICk7XG4gICAgICAgIHVzYWdlLmNvbXBsZXRpb25Ub2tlbnMgKz0gY3VycmVudFVzYWdlLmNvbXBsZXRpb25Ub2tlbnM7XG4gICAgICAgIHVzYWdlLnByb21wdFRva2VucyArPSBjdXJyZW50VXNhZ2UucHJvbXB0VG9rZW5zO1xuICAgICAgICB1c2FnZS50b3RhbFRva2VucyArPSBjdXJyZW50VXNhZ2UudG90YWxUb2tlbnM7XG4gICAgICAgIHJvdW5kdHJpcHMucHVzaCh7XG4gICAgICAgICAgdGV4dDogKF9iID0gY3VycmVudE1vZGVsUmVzcG9uc2UudGV4dCkgIT0gbnVsbCA/IF9iIDogXCJcIixcbiAgICAgICAgICB0b29sQ2FsbHM6IGN1cnJlbnRUb29sQ2FsbHMsXG4gICAgICAgICAgdG9vbFJlc3VsdHM6IGN1cnJlbnRUb29sUmVzdWx0cyxcbiAgICAgICAgICBmaW5pc2hSZWFzb246IGN1cnJlbnRNb2RlbFJlc3BvbnNlLmZpbmlzaFJlYXNvbixcbiAgICAgICAgICB1c2FnZTogY3VycmVudFVzYWdlLFxuICAgICAgICAgIHdhcm5pbmdzOiBjdXJyZW50TW9kZWxSZXNwb25zZS53YXJuaW5ncyxcbiAgICAgICAgICBsb2dwcm9iczogY3VycmVudE1vZGVsUmVzcG9uc2UubG9ncHJvYnNcbiAgICAgICAgfSk7XG4gICAgICAgIGNvbnN0IG5ld1Jlc3BvbnNlTWVzc2FnZXMgPSB0b1Jlc3BvbnNlTWVzc2FnZXMoe1xuICAgICAgICAgIHRleHQ6IChfYyA9IGN1cnJlbnRNb2RlbFJlc3BvbnNlLnRleHQpICE9IG51bGwgPyBfYyA6IFwiXCIsXG4gICAgICAgICAgdG9vbENhbGxzOiBjdXJyZW50VG9vbENhbGxzLFxuICAgICAgICAgIHRvb2xSZXN1bHRzOiBjdXJyZW50VG9vbFJlc3VsdHNcbiAgICAgICAgfSk7XG4gICAgICAgIHJlc3BvbnNlTWVzc2FnZXMucHVzaCguLi5uZXdSZXNwb25zZU1lc3NhZ2VzKTtcbiAgICAgICAgcHJvbXB0TWVzc2FnZXMucHVzaChcbiAgICAgICAgICAuLi5uZXdSZXNwb25zZU1lc3NhZ2VzLm1hcChcbiAgICAgICAgICAgIChtZXNzYWdlKSA9PiBjb252ZXJ0VG9MYW5ndWFnZU1vZGVsTWVzc2FnZShtZXNzYWdlLCBudWxsKVxuICAgICAgICAgIClcbiAgICAgICAgKTtcbiAgICAgIH0gd2hpbGUgKFxuICAgICAgICAvLyB0aGVyZSBhcmUgdG9vbCBjYWxsczpcbiAgICAgICAgY3VycmVudFRvb2xDYWxscy5sZW5ndGggPiAwICYmIC8vIGFsbCBjdXJyZW50IHRvb2wgY2FsbHMgaGF2ZSByZXN1bHRzOlxuICAgICAgICBjdXJyZW50VG9vbFJlc3VsdHMubGVuZ3RoID09PSBjdXJyZW50VG9vbENhbGxzLmxlbmd0aCAmJiAvLyB0aGUgbnVtYmVyIG9mIHJvdW5kdHJpcHMgaXMgbGVzcyB0aGFuIHRoZSBtYXhpbXVtOlxuICAgICAgICByb3VuZHRyaXBDb3VudCsrIDwgbWF4VG9vbFJvdW5kdHJpcHNcbiAgICAgICk7XG4gICAgICBzcGFuLnNldEF0dHJpYnV0ZXMoXG4gICAgICAgIHNlbGVjdFRlbGVtZXRyeUF0dHJpYnV0ZXMoe1xuICAgICAgICAgIHRlbGVtZXRyeSxcbiAgICAgICAgICBhdHRyaWJ1dGVzOiB7XG4gICAgICAgICAgICBcImFpLmZpbmlzaFJlYXNvblwiOiBjdXJyZW50TW9kZWxSZXNwb25zZS5maW5pc2hSZWFzb24sXG4gICAgICAgICAgICBcImFpLnVzYWdlLnByb21wdFRva2Vuc1wiOiBjdXJyZW50TW9kZWxSZXNwb25zZS51c2FnZS5wcm9tcHRUb2tlbnMsXG4gICAgICAgICAgICBcImFpLnVzYWdlLmNvbXBsZXRpb25Ub2tlbnNcIjogY3VycmVudE1vZGVsUmVzcG9uc2UudXNhZ2UuY29tcGxldGlvblRva2VucyxcbiAgICAgICAgICAgIFwiYWkucmVzdWx0LnRleHRcIjoge1xuICAgICAgICAgICAgICBvdXRwdXQ6ICgpID0+IGN1cnJlbnRNb2RlbFJlc3BvbnNlLnRleHRcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBcImFpLnJlc3VsdC50b29sQ2FsbHNcIjoge1xuICAgICAgICAgICAgICBvdXRwdXQ6ICgpID0+IEpTT04uc3RyaW5naWZ5KGN1cnJlbnRNb2RlbFJlc3BvbnNlLnRvb2xDYWxscylcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0pXG4gICAgICApO1xuICAgICAgcmV0dXJuIG5ldyBEZWZhdWx0R2VuZXJhdGVUZXh0UmVzdWx0KHtcbiAgICAgICAgLy8gQWx3YXlzIHJldHVybiBhIHN0cmluZyBzbyB0aGF0IHRoZSBjYWxsZXIgZG9lc24ndCBoYXZlIHRvIGNoZWNrIGZvciB1bmRlZmluZWQuXG4gICAgICAgIC8vIElmIHRoZXkgbmVlZCB0byBjaGVjayBpZiB0aGUgbW9kZWwgZGlkIG5vdCByZXR1cm4gYW55IHRleHQsXG4gICAgICAgIC8vIHRoZXkgY2FuIGNoZWNrIHRoZSBsZW5ndGggb2YgdGhlIHN0cmluZzpcbiAgICAgICAgdGV4dDogKF9kID0gY3VycmVudE1vZGVsUmVzcG9uc2UudGV4dCkgIT0gbnVsbCA/IF9kIDogXCJcIixcbiAgICAgICAgdG9vbENhbGxzOiBjdXJyZW50VG9vbENhbGxzLFxuICAgICAgICB0b29sUmVzdWx0czogY3VycmVudFRvb2xSZXN1bHRzLFxuICAgICAgICBmaW5pc2hSZWFzb246IGN1cnJlbnRNb2RlbFJlc3BvbnNlLmZpbmlzaFJlYXNvbixcbiAgICAgICAgdXNhZ2UsXG4gICAgICAgIHdhcm5pbmdzOiBjdXJyZW50TW9kZWxSZXNwb25zZS53YXJuaW5ncyxcbiAgICAgICAgcmF3UmVzcG9uc2U6IGN1cnJlbnRNb2RlbFJlc3BvbnNlLnJhd1Jlc3BvbnNlLFxuICAgICAgICBsb2dwcm9iczogY3VycmVudE1vZGVsUmVzcG9uc2UubG9ncHJvYnMsXG4gICAgICAgIHJlc3BvbnNlTWVzc2FnZXMsXG4gICAgICAgIHJvdW5kdHJpcHMsXG4gICAgICAgIHByb3ZpZGVyTWV0YWRhdGE6IGN1cnJlbnRNb2RlbFJlc3BvbnNlLnByb3ZpZGVyTWV0YWRhdGFcbiAgICAgIH0pO1xuICAgIH1cbiAgfSk7XG59XG5hc3luYyBmdW5jdGlvbiBleGVjdXRlVG9vbHMoe1xuICB0b29sQ2FsbHMsXG4gIHRvb2xzLFxuICB0cmFjZXIsXG4gIHRlbGVtZXRyeVxufSkge1xuICBjb25zdCB0b29sUmVzdWx0cyA9IGF3YWl0IFByb21pc2UuYWxsKFxuICAgIHRvb2xDYWxscy5tYXAoYXN5bmMgKHRvb2xDYWxsKSA9PiB7XG4gICAgICBjb25zdCB0b29sMiA9IHRvb2xzW3Rvb2xDYWxsLnRvb2xOYW1lXTtcbiAgICAgIGlmICgodG9vbDIgPT0gbnVsbCA/IHZvaWQgMCA6IHRvb2wyLmV4ZWN1dGUpID09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIHZvaWQgMDtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHJlY29yZFNwYW4oe1xuICAgICAgICBuYW1lOiBcImFpLnRvb2xDYWxsXCIsXG4gICAgICAgIGF0dHJpYnV0ZXM6IHNlbGVjdFRlbGVtZXRyeUF0dHJpYnV0ZXMoe1xuICAgICAgICAgIHRlbGVtZXRyeSxcbiAgICAgICAgICBhdHRyaWJ1dGVzOiB7XG4gICAgICAgICAgICAuLi5hc3NlbWJsZU9wZXJhdGlvbk5hbWUoe1xuICAgICAgICAgICAgICBvcGVyYXRpb25OYW1lOiBcImFpLnRvb2xDYWxsXCIsXG4gICAgICAgICAgICAgIHRlbGVtZXRyeVxuICAgICAgICAgICAgfSksXG4gICAgICAgICAgICBcImFpLnRvb2xDYWxsLm5hbWVcIjogdG9vbENhbGwudG9vbE5hbWUsXG4gICAgICAgICAgICBcImFpLnRvb2xDYWxsLmlkXCI6IHRvb2xDYWxsLnRvb2xDYWxsSWQsXG4gICAgICAgICAgICBcImFpLnRvb2xDYWxsLmFyZ3NcIjoge1xuICAgICAgICAgICAgICBvdXRwdXQ6ICgpID0+IEpTT04uc3RyaW5naWZ5KHRvb2xDYWxsLmFyZ3MpXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9KSxcbiAgICAgICAgdHJhY2VyLFxuICAgICAgICBmbjogYXN5bmMgKHNwYW4pID0+IHtcbiAgICAgICAgICBjb25zdCByZXN1bHQyID0gYXdhaXQgdG9vbDIuZXhlY3V0ZSh0b29sQ2FsbC5hcmdzKTtcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgc3Bhbi5zZXRBdHRyaWJ1dGVzKFxuICAgICAgICAgICAgICBzZWxlY3RUZWxlbWV0cnlBdHRyaWJ1dGVzKHtcbiAgICAgICAgICAgICAgICB0ZWxlbWV0cnksXG4gICAgICAgICAgICAgICAgYXR0cmlidXRlczoge1xuICAgICAgICAgICAgICAgICAgXCJhaS50b29sQ2FsbC5yZXN1bHRcIjoge1xuICAgICAgICAgICAgICAgICAgICBvdXRwdXQ6ICgpID0+IEpTT04uc3RyaW5naWZ5KHJlc3VsdDIpXG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9IGNhdGNoIChpZ25vcmVkKSB7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiByZXN1bHQyO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHRvb2xDYWxsSWQ6IHRvb2xDYWxsLnRvb2xDYWxsSWQsXG4gICAgICAgIHRvb2xOYW1lOiB0b29sQ2FsbC50b29sTmFtZSxcbiAgICAgICAgYXJnczogdG9vbENhbGwuYXJncyxcbiAgICAgICAgcmVzdWx0XG4gICAgICB9O1xuICAgIH0pXG4gICk7XG4gIHJldHVybiB0b29sUmVzdWx0cy5maWx0ZXIoXG4gICAgKHJlc3VsdCkgPT4gcmVzdWx0ICE9IG51bGxcbiAgKTtcbn1cbnZhciBEZWZhdWx0R2VuZXJhdGVUZXh0UmVzdWx0ID0gY2xhc3Mge1xuICBjb25zdHJ1Y3RvcihvcHRpb25zKSB7XG4gICAgdGhpcy50ZXh0ID0gb3B0aW9ucy50ZXh0O1xuICAgIHRoaXMudG9vbENhbGxzID0gb3B0aW9ucy50b29sQ2FsbHM7XG4gICAgdGhpcy50b29sUmVzdWx0cyA9IG9wdGlvbnMudG9vbFJlc3VsdHM7XG4gICAgdGhpcy5maW5pc2hSZWFzb24gPSBvcHRpb25zLmZpbmlzaFJlYXNvbjtcbiAgICB0aGlzLnVzYWdlID0gb3B0aW9ucy51c2FnZTtcbiAgICB0aGlzLndhcm5pbmdzID0gb3B0aW9ucy53YXJuaW5ncztcbiAgICB0aGlzLnJhd1Jlc3BvbnNlID0gb3B0aW9ucy5yYXdSZXNwb25zZTtcbiAgICB0aGlzLmxvZ3Byb2JzID0gb3B0aW9ucy5sb2dwcm9icztcbiAgICB0aGlzLnJlc3BvbnNlTWVzc2FnZXMgPSBvcHRpb25zLnJlc3BvbnNlTWVzc2FnZXM7XG4gICAgdGhpcy5yb3VuZHRyaXBzID0gb3B0aW9ucy5yb3VuZHRyaXBzO1xuICAgIHRoaXMuZXhwZXJpbWVudGFsX3Byb3ZpZGVyTWV0YWRhdGEgPSBvcHRpb25zLnByb3ZpZGVyTWV0YWRhdGE7XG4gIH1cbn07XG5mdW5jdGlvbiB0b1Jlc3BvbnNlTWVzc2FnZXMoe1xuICB0ZXh0LFxuICB0b29sQ2FsbHMsXG4gIHRvb2xSZXN1bHRzXG59KSB7XG4gIGNvbnN0IHJlc3BvbnNlTWVzc2FnZXMgPSBbXTtcbiAgcmVzcG9uc2VNZXNzYWdlcy5wdXNoKHtcbiAgICByb2xlOiBcImFzc2lzdGFudFwiLFxuICAgIGNvbnRlbnQ6IFt7IHR5cGU6IFwidGV4dFwiLCB0ZXh0IH0sIC4uLnRvb2xDYWxsc11cbiAgfSk7XG4gIGlmICh0b29sUmVzdWx0cy5sZW5ndGggPiAwKSB7XG4gICAgcmVzcG9uc2VNZXNzYWdlcy5wdXNoKHtcbiAgICAgIHJvbGU6IFwidG9vbFwiLFxuICAgICAgY29udGVudDogdG9vbFJlc3VsdHMubWFwKChyZXN1bHQpID0+ICh7XG4gICAgICAgIHR5cGU6IFwidG9vbC1yZXN1bHRcIixcbiAgICAgICAgdG9vbENhbGxJZDogcmVzdWx0LnRvb2xDYWxsSWQsXG4gICAgICAgIHRvb2xOYW1lOiByZXN1bHQudG9vbE5hbWUsXG4gICAgICAgIHJlc3VsdDogcmVzdWx0LnJlc3VsdFxuICAgICAgfSkpXG4gICAgfSk7XG4gIH1cbiAgcmV0dXJuIHJlc3BvbnNlTWVzc2FnZXM7XG59XG52YXIgZXhwZXJpbWVudGFsX2dlbmVyYXRlVGV4dCA9IGdlbmVyYXRlVGV4dDtcblxuLy8gY29yZS91dGlsL21lcmdlLXN0cmVhbXMudHNcbmZ1bmN0aW9uIG1lcmdlU3RyZWFtcyhzdHJlYW0xLCBzdHJlYW0yKSB7XG4gIGNvbnN0IHJlYWRlcjEgPSBzdHJlYW0xLmdldFJlYWRlcigpO1xuICBjb25zdCByZWFkZXIyID0gc3RyZWFtMi5nZXRSZWFkZXIoKTtcbiAgbGV0IGxhc3RSZWFkMSA9IHZvaWQgMDtcbiAgbGV0IGxhc3RSZWFkMiA9IHZvaWQgMDtcbiAgbGV0IHN0cmVhbTFEb25lID0gZmFsc2U7XG4gIGxldCBzdHJlYW0yRG9uZSA9IGZhbHNlO1xuICBhc3luYyBmdW5jdGlvbiByZWFkU3RyZWFtMShjb250cm9sbGVyKSB7XG4gICAgdHJ5IHtcbiAgICAgIGlmIChsYXN0UmVhZDEgPT0gbnVsbCkge1xuICAgICAgICBsYXN0UmVhZDEgPSByZWFkZXIxLnJlYWQoKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IGxhc3RSZWFkMTtcbiAgICAgIGxhc3RSZWFkMSA9IHZvaWQgMDtcbiAgICAgIGlmICghcmVzdWx0LmRvbmUpIHtcbiAgICAgICAgY29udHJvbGxlci5lbnF1ZXVlKHJlc3VsdC52YWx1ZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb250cm9sbGVyLmNsb3NlKCk7XG4gICAgICB9XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGNvbnRyb2xsZXIuZXJyb3IoZXJyb3IpO1xuICAgIH1cbiAgfVxuICBhc3luYyBmdW5jdGlvbiByZWFkU3RyZWFtMihjb250cm9sbGVyKSB7XG4gICAgdHJ5IHtcbiAgICAgIGlmIChsYXN0UmVhZDIgPT0gbnVsbCkge1xuICAgICAgICBsYXN0UmVhZDIgPSByZWFkZXIyLnJlYWQoKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IGxhc3RSZWFkMjtcbiAgICAgIGxhc3RSZWFkMiA9IHZvaWQgMDtcbiAgICAgIGlmICghcmVzdWx0LmRvbmUpIHtcbiAgICAgICAgY29udHJvbGxlci5lbnF1ZXVlKHJlc3VsdC52YWx1ZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb250cm9sbGVyLmNsb3NlKCk7XG4gICAgICB9XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGNvbnRyb2xsZXIuZXJyb3IoZXJyb3IpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gbmV3IFJlYWRhYmxlU3RyZWFtKHtcbiAgICBhc3luYyBwdWxsKGNvbnRyb2xsZXIpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGlmIChzdHJlYW0xRG9uZSkge1xuICAgICAgICAgIGF3YWl0IHJlYWRTdHJlYW0yKGNvbnRyb2xsZXIpO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc3RyZWFtMkRvbmUpIHtcbiAgICAgICAgICBhd2FpdCByZWFkU3RyZWFtMShjb250cm9sbGVyKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGxhc3RSZWFkMSA9PSBudWxsKSB7XG4gICAgICAgICAgbGFzdFJlYWQxID0gcmVhZGVyMS5yZWFkKCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGxhc3RSZWFkMiA9PSBudWxsKSB7XG4gICAgICAgICAgbGFzdFJlYWQyID0gcmVhZGVyMi5yZWFkKCk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgeyByZXN1bHQsIHJlYWRlciB9ID0gYXdhaXQgUHJvbWlzZS5yYWNlKFtcbiAgICAgICAgICBsYXN0UmVhZDEudGhlbigocmVzdWx0MikgPT4gKHsgcmVzdWx0OiByZXN1bHQyLCByZWFkZXI6IHJlYWRlcjEgfSkpLFxuICAgICAgICAgIGxhc3RSZWFkMi50aGVuKChyZXN1bHQyKSA9PiAoeyByZXN1bHQ6IHJlc3VsdDIsIHJlYWRlcjogcmVhZGVyMiB9KSlcbiAgICAgICAgXSk7XG4gICAgICAgIGlmICghcmVzdWx0LmRvbmUpIHtcbiAgICAgICAgICBjb250cm9sbGVyLmVucXVldWUocmVzdWx0LnZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocmVhZGVyID09PSByZWFkZXIxKSB7XG4gICAgICAgICAgbGFzdFJlYWQxID0gdm9pZCAwO1xuICAgICAgICAgIGlmIChyZXN1bHQuZG9uZSkge1xuICAgICAgICAgICAgYXdhaXQgcmVhZFN0cmVhbTIoY29udHJvbGxlcik7XG4gICAgICAgICAgICBzdHJlYW0xRG9uZSA9IHRydWU7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGxhc3RSZWFkMiA9IHZvaWQgMDtcbiAgICAgICAgICBpZiAocmVzdWx0LmRvbmUpIHtcbiAgICAgICAgICAgIHN0cmVhbTJEb25lID0gdHJ1ZTtcbiAgICAgICAgICAgIGF3YWl0IHJlYWRTdHJlYW0xKGNvbnRyb2xsZXIpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgY29udHJvbGxlci5lcnJvcihlcnJvcik7XG4gICAgICB9XG4gICAgfSxcbiAgICBjYW5jZWwoKSB7XG4gICAgICByZWFkZXIxLmNhbmNlbCgpO1xuICAgICAgcmVhZGVyMi5jYW5jZWwoKTtcbiAgICB9XG4gIH0pO1xufVxuXG4vLyBjb3JlL2dlbmVyYXRlLXRleHQvcnVuLXRvb2xzLXRyYW5zZm9ybWF0aW9uLnRzXG5pbXBvcnQgeyBnZW5lcmF0ZUlkIH0gZnJvbSBcIkBhaS1zZGsvdWktdXRpbHNcIjtcbmZ1bmN0aW9uIHJ1blRvb2xzVHJhbnNmb3JtYXRpb24oe1xuICB0b29scyxcbiAgZ2VuZXJhdG9yU3RyZWFtLFxuICB0b29sQ2FsbFN0cmVhbWluZyxcbiAgdHJhY2VyLFxuICB0ZWxlbWV0cnlcbn0pIHtcbiAgbGV0IGNhbkNsb3NlID0gZmFsc2U7XG4gIGNvbnN0IG91dHN0YW5kaW5nVG9vbENhbGxzID0gLyogQF9fUFVSRV9fICovIG5ldyBTZXQoKTtcbiAgbGV0IHRvb2xSZXN1bHRzU3RyZWFtQ29udHJvbGxlciA9IG51bGw7XG4gIGNvbnN0IHRvb2xSZXN1bHRzU3RyZWFtID0gbmV3IFJlYWRhYmxlU3RyZWFtKHtcbiAgICBzdGFydChjb250cm9sbGVyKSB7XG4gICAgICB0b29sUmVzdWx0c1N0cmVhbUNvbnRyb2xsZXIgPSBjb250cm9sbGVyO1xuICAgIH1cbiAgfSk7XG4gIGNvbnN0IGFjdGl2ZVRvb2xDYWxscyA9IHt9O1xuICBjb25zdCBmb3J3YXJkU3RyZWFtID0gbmV3IFRyYW5zZm9ybVN0cmVhbSh7XG4gICAgdHJhbnNmb3JtKGNodW5rLCBjb250cm9sbGVyKSB7XG4gICAgICBjb25zdCBjaHVua1R5cGUgPSBjaHVuay50eXBlO1xuICAgICAgc3dpdGNoIChjaHVua1R5cGUpIHtcbiAgICAgICAgY2FzZSBcInRleHQtZGVsdGFcIjpcbiAgICAgICAgY2FzZSBcImVycm9yXCI6IHtcbiAgICAgICAgICBjb250cm9sbGVyLmVucXVldWUoY2h1bmspO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGNhc2UgXCJ0b29sLWNhbGwtZGVsdGFcIjoge1xuICAgICAgICAgIGlmICh0b29sQ2FsbFN0cmVhbWluZykge1xuICAgICAgICAgICAgaWYgKCFhY3RpdmVUb29sQ2FsbHNbY2h1bmsudG9vbENhbGxJZF0pIHtcbiAgICAgICAgICAgICAgY29udHJvbGxlci5lbnF1ZXVlKHtcbiAgICAgICAgICAgICAgICB0eXBlOiBcInRvb2wtY2FsbC1zdHJlYW1pbmctc3RhcnRcIixcbiAgICAgICAgICAgICAgICB0b29sQ2FsbElkOiBjaHVuay50b29sQ2FsbElkLFxuICAgICAgICAgICAgICAgIHRvb2xOYW1lOiBjaHVuay50b29sTmFtZVxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgYWN0aXZlVG9vbENhbGxzW2NodW5rLnRvb2xDYWxsSWRdID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnRyb2xsZXIuZW5xdWV1ZSh7XG4gICAgICAgICAgICAgIHR5cGU6IFwidG9vbC1jYWxsLWRlbHRhXCIsXG4gICAgICAgICAgICAgIHRvb2xDYWxsSWQ6IGNodW5rLnRvb2xDYWxsSWQsXG4gICAgICAgICAgICAgIHRvb2xOYW1lOiBjaHVuay50b29sTmFtZSxcbiAgICAgICAgICAgICAgYXJnc1RleHREZWx0YTogY2h1bmsuYXJnc1RleHREZWx0YVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGNhc2UgXCJ0b29sLWNhbGxcIjoge1xuICAgICAgICAgIGNvbnN0IHRvb2xOYW1lID0gY2h1bmsudG9vbE5hbWU7XG4gICAgICAgICAgaWYgKHRvb2xzID09IG51bGwpIHtcbiAgICAgICAgICAgIHRvb2xSZXN1bHRzU3RyZWFtQ29udHJvbGxlci5lbnF1ZXVlKHtcbiAgICAgICAgICAgICAgdHlwZTogXCJlcnJvclwiLFxuICAgICAgICAgICAgICBlcnJvcjogbmV3IE5vU3VjaFRvb2xFcnJvcih7IHRvb2xOYW1lOiBjaHVuay50b29sTmFtZSB9KVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgICAgY29uc3QgdG9vbDIgPSB0b29sc1t0b29sTmFtZV07XG4gICAgICAgICAgaWYgKHRvb2wyID09IG51bGwpIHtcbiAgICAgICAgICAgIHRvb2xSZXN1bHRzU3RyZWFtQ29udHJvbGxlci5lbnF1ZXVlKHtcbiAgICAgICAgICAgICAgdHlwZTogXCJlcnJvclwiLFxuICAgICAgICAgICAgICBlcnJvcjogbmV3IE5vU3VjaFRvb2xFcnJvcih7XG4gICAgICAgICAgICAgICAgdG9vbE5hbWU6IGNodW5rLnRvb2xOYW1lLFxuICAgICAgICAgICAgICAgIGF2YWlsYWJsZVRvb2xzOiBPYmplY3Qua2V5cyh0b29scylcbiAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCB0b29sQ2FsbCA9IHBhcnNlVG9vbENhbGwoe1xuICAgICAgICAgICAgICB0b29sQ2FsbDogY2h1bmssXG4gICAgICAgICAgICAgIHRvb2xzXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGNvbnRyb2xsZXIuZW5xdWV1ZSh0b29sQ2FsbCk7XG4gICAgICAgICAgICBpZiAodG9vbDIuZXhlY3V0ZSAhPSBudWxsKSB7XG4gICAgICAgICAgICAgIGNvbnN0IHRvb2xFeGVjdXRpb25JZCA9IGdlbmVyYXRlSWQoKTtcbiAgICAgICAgICAgICAgb3V0c3RhbmRpbmdUb29sQ2FsbHMuYWRkKHRvb2xFeGVjdXRpb25JZCk7XG4gICAgICAgICAgICAgIHJlY29yZFNwYW4oe1xuICAgICAgICAgICAgICAgIG5hbWU6IFwiYWkudG9vbENhbGxcIixcbiAgICAgICAgICAgICAgICBhdHRyaWJ1dGVzOiBzZWxlY3RUZWxlbWV0cnlBdHRyaWJ1dGVzKHtcbiAgICAgICAgICAgICAgICAgIHRlbGVtZXRyeSxcbiAgICAgICAgICAgICAgICAgIGF0dHJpYnV0ZXM6IHtcbiAgICAgICAgICAgICAgICAgICAgLi4uYXNzZW1ibGVPcGVyYXRpb25OYW1lKHtcbiAgICAgICAgICAgICAgICAgICAgICBvcGVyYXRpb25OYW1lOiBcImFpLnRvb2xDYWxsXCIsXG4gICAgICAgICAgICAgICAgICAgICAgdGVsZW1ldHJ5XG4gICAgICAgICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgICAgICAgICBcImFpLnRvb2xDYWxsLm5hbWVcIjogdG9vbENhbGwudG9vbE5hbWUsXG4gICAgICAgICAgICAgICAgICAgIFwiYWkudG9vbENhbGwuaWRcIjogdG9vbENhbGwudG9vbENhbGxJZCxcbiAgICAgICAgICAgICAgICAgICAgXCJhaS50b29sQ2FsbC5hcmdzXCI6IHtcbiAgICAgICAgICAgICAgICAgICAgICBvdXRwdXQ6ICgpID0+IEpTT04uc3RyaW5naWZ5KHRvb2xDYWxsLmFyZ3MpXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgICAgICB0cmFjZXIsXG4gICAgICAgICAgICAgICAgZm46IGFzeW5jIChzcGFuKSA9PiB0b29sMi5leGVjdXRlKHRvb2xDYWxsLmFyZ3MpLnRoZW4oXG4gICAgICAgICAgICAgICAgICAocmVzdWx0KSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHRvb2xSZXN1bHRzU3RyZWFtQ29udHJvbGxlci5lbnF1ZXVlKHtcbiAgICAgICAgICAgICAgICAgICAgICAuLi50b29sQ2FsbCxcbiAgICAgICAgICAgICAgICAgICAgICB0eXBlOiBcInRvb2wtcmVzdWx0XCIsXG4gICAgICAgICAgICAgICAgICAgICAgcmVzdWx0XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICBvdXRzdGFuZGluZ1Rvb2xDYWxscy5kZWxldGUodG9vbEV4ZWN1dGlvbklkKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNhbkNsb3NlICYmIG91dHN0YW5kaW5nVG9vbENhbGxzLnNpemUgPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICB0b29sUmVzdWx0c1N0cmVhbUNvbnRyb2xsZXIuY2xvc2UoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgIHNwYW4uc2V0QXR0cmlidXRlcyhcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlbGVjdFRlbGVtZXRyeUF0dHJpYnV0ZXMoe1xuICAgICAgICAgICAgICAgICAgICAgICAgICB0ZWxlbWV0cnksXG4gICAgICAgICAgICAgICAgICAgICAgICAgIGF0dHJpYnV0ZXM6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBcImFpLnRvb2xDYWxsLnJlc3VsdFwiOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvdXRwdXQ6ICgpID0+IEpTT04uc3RyaW5naWZ5KHJlc3VsdClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICAgICAgfSBjYXRjaCAoaWdub3JlZCkge1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgKGVycm9yKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHRvb2xSZXN1bHRzU3RyZWFtQ29udHJvbGxlci5lbnF1ZXVlKHtcbiAgICAgICAgICAgICAgICAgICAgICB0eXBlOiBcImVycm9yXCIsXG4gICAgICAgICAgICAgICAgICAgICAgZXJyb3JcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIG91dHN0YW5kaW5nVG9vbENhbGxzLmRlbGV0ZSh0b29sRXhlY3V0aW9uSWQpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoY2FuQ2xvc2UgJiYgb3V0c3RhbmRpbmdUb29sQ2FsbHMuc2l6ZSA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICAgIHRvb2xSZXN1bHRzU3RyZWFtQ29udHJvbGxlci5jbG9zZSgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgdG9vbFJlc3VsdHNTdHJlYW1Db250cm9sbGVyLmVucXVldWUoe1xuICAgICAgICAgICAgICB0eXBlOiBcImVycm9yXCIsXG4gICAgICAgICAgICAgIGVycm9yXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgY2FzZSBcImZpbmlzaFwiOiB7XG4gICAgICAgICAgY29udHJvbGxlci5lbnF1ZXVlKHtcbiAgICAgICAgICAgIHR5cGU6IFwiZmluaXNoXCIsXG4gICAgICAgICAgICBmaW5pc2hSZWFzb246IGNodW5rLmZpbmlzaFJlYXNvbixcbiAgICAgICAgICAgIGxvZ3Byb2JzOiBjaHVuay5sb2dwcm9icyxcbiAgICAgICAgICAgIHVzYWdlOiBjYWxjdWxhdGVDb21wbGV0aW9uVG9rZW5Vc2FnZShjaHVuay51c2FnZSksXG4gICAgICAgICAgICBleHBlcmltZW50YWxfcHJvdmlkZXJNZXRhZGF0YTogY2h1bmsucHJvdmlkZXJNZXRhZGF0YVxuICAgICAgICAgIH0pO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGRlZmF1bHQ6IHtcbiAgICAgICAgICBjb25zdCBfZXhoYXVzdGl2ZUNoZWNrID0gY2h1bmtUeXBlO1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgVW5oYW5kbGVkIGNodW5rIHR5cGU6ICR7X2V4aGF1c3RpdmVDaGVja31gKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG4gICAgZmx1c2goKSB7XG4gICAgICBjYW5DbG9zZSA9IHRydWU7XG4gICAgICBpZiAob3V0c3RhbmRpbmdUb29sQ2FsbHMuc2l6ZSA9PT0gMCkge1xuICAgICAgICB0b29sUmVzdWx0c1N0cmVhbUNvbnRyb2xsZXIuY2xvc2UoKTtcbiAgICAgIH1cbiAgICB9XG4gIH0pO1xuICByZXR1cm4gbmV3IFJlYWRhYmxlU3RyZWFtKHtcbiAgICBhc3luYyBzdGFydChjb250cm9sbGVyKSB7XG4gICAgICByZXR1cm4gUHJvbWlzZS5hbGwoW1xuICAgICAgICBnZW5lcmF0b3JTdHJlYW0ucGlwZVRocm91Z2goZm9yd2FyZFN0cmVhbSkucGlwZVRvKFxuICAgICAgICAgIG5ldyBXcml0YWJsZVN0cmVhbSh7XG4gICAgICAgICAgICB3cml0ZShjaHVuaykge1xuICAgICAgICAgICAgICBjb250cm9sbGVyLmVucXVldWUoY2h1bmspO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGNsb3NlKCkge1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pXG4gICAgICAgICksXG4gICAgICAgIHRvb2xSZXN1bHRzU3RyZWFtLnBpcGVUbyhcbiAgICAgICAgICBuZXcgV3JpdGFibGVTdHJlYW0oe1xuICAgICAgICAgICAgd3JpdGUoY2h1bmspIHtcbiAgICAgICAgICAgICAgY29udHJvbGxlci5lbnF1ZXVlKGNodW5rKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBjbG9zZSgpIHtcbiAgICAgICAgICAgICAgY29udHJvbGxlci5jbG9zZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pXG4gICAgICAgIClcbiAgICAgIF0pO1xuICAgIH1cbiAgfSk7XG59XG5cbi8vIGNvcmUvZ2VuZXJhdGUtdGV4dC9zdHJlYW0tdGV4dC50c1xuYXN5bmMgZnVuY3Rpb24gc3RyZWFtVGV4dCh7XG4gIG1vZGVsLFxuICB0b29scyxcbiAgdG9vbENob2ljZSxcbiAgc3lzdGVtLFxuICBwcm9tcHQsXG4gIG1lc3NhZ2VzLFxuICBtYXhSZXRyaWVzLFxuICBhYm9ydFNpZ25hbCxcbiAgaGVhZGVycyxcbiAgZXhwZXJpbWVudGFsX3RlbGVtZXRyeTogdGVsZW1ldHJ5LFxuICBleHBlcmltZW50YWxfdG9vbENhbGxTdHJlYW1pbmc6IHRvb2xDYWxsU3RyZWFtaW5nID0gZmFsc2UsXG4gIG9uQ2h1bmssXG4gIG9uRmluaXNoLFxuICAuLi5zZXR0aW5nc1xufSkge1xuICB2YXIgX2ExMjtcbiAgY29uc3QgYmFzZVRlbGVtZXRyeUF0dHJpYnV0ZXMgPSBnZXRCYXNlVGVsZW1ldHJ5QXR0cmlidXRlcyh7XG4gICAgbW9kZWwsXG4gICAgdGVsZW1ldHJ5LFxuICAgIGhlYWRlcnMsXG4gICAgc2V0dGluZ3M6IHsgLi4uc2V0dGluZ3MsIG1heFJldHJpZXMgfVxuICB9KTtcbiAgY29uc3QgdHJhY2VyID0gZ2V0VHJhY2VyKHsgaXNFbmFibGVkOiAoX2ExMiA9IHRlbGVtZXRyeSA9PSBudWxsID8gdm9pZCAwIDogdGVsZW1ldHJ5LmlzRW5hYmxlZCkgIT0gbnVsbCA/IF9hMTIgOiBmYWxzZSB9KTtcbiAgcmV0dXJuIHJlY29yZFNwYW4oe1xuICAgIG5hbWU6IFwiYWkuc3RyZWFtVGV4dFwiLFxuICAgIGF0dHJpYnV0ZXM6IHNlbGVjdFRlbGVtZXRyeUF0dHJpYnV0ZXMoe1xuICAgICAgdGVsZW1ldHJ5LFxuICAgICAgYXR0cmlidXRlczoge1xuICAgICAgICAuLi5hc3NlbWJsZU9wZXJhdGlvbk5hbWUoeyBvcGVyYXRpb25OYW1lOiBcImFpLnN0cmVhbVRleHRcIiwgdGVsZW1ldHJ5IH0pLFxuICAgICAgICAuLi5iYXNlVGVsZW1ldHJ5QXR0cmlidXRlcyxcbiAgICAgICAgLy8gc3BlY2lmaWMgc2V0dGluZ3MgdGhhdCBvbmx5IG1ha2Ugc2Vuc2Ugb24gdGhlIG91dGVyIGxldmVsOlxuICAgICAgICBcImFpLnByb21wdFwiOiB7XG4gICAgICAgICAgaW5wdXQ6ICgpID0+IEpTT04uc3RyaW5naWZ5KHsgc3lzdGVtLCBwcm9tcHQsIG1lc3NhZ2VzIH0pXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KSxcbiAgICB0cmFjZXIsXG4gICAgZW5kV2hlbkRvbmU6IGZhbHNlLFxuICAgIGZuOiBhc3luYyAocm9vdFNwYW4pID0+IHtcbiAgICAgIGNvbnN0IHJldHJ5ID0gcmV0cnlXaXRoRXhwb25lbnRpYWxCYWNrb2ZmKHsgbWF4UmV0cmllcyB9KTtcbiAgICAgIGNvbnN0IHZhbGlkYXRlZFByb21wdCA9IGdldFZhbGlkYXRlZFByb21wdCh7IHN5c3RlbSwgcHJvbXB0LCBtZXNzYWdlcyB9KTtcbiAgICAgIGNvbnN0IHByb21wdE1lc3NhZ2VzID0gYXdhaXQgY29udmVydFRvTGFuZ3VhZ2VNb2RlbFByb21wdCh7XG4gICAgICAgIHByb21wdDogdmFsaWRhdGVkUHJvbXB0LFxuICAgICAgICBtb2RlbFN1cHBvcnRzSW1hZ2VVcmxzOiBtb2RlbC5zdXBwb3J0c0ltYWdlVXJsc1xuICAgICAgfSk7XG4gICAgICBjb25zdCB7XG4gICAgICAgIHJlc3VsdDogeyBzdHJlYW0sIHdhcm5pbmdzLCByYXdSZXNwb25zZSB9LFxuICAgICAgICBkb1N0cmVhbVNwYW5cbiAgICAgIH0gPSBhd2FpdCByZXRyeShcbiAgICAgICAgKCkgPT4gcmVjb3JkU3Bhbih7XG4gICAgICAgICAgbmFtZTogXCJhaS5zdHJlYW1UZXh0LmRvU3RyZWFtXCIsXG4gICAgICAgICAgYXR0cmlidXRlczogc2VsZWN0VGVsZW1ldHJ5QXR0cmlidXRlcyh7XG4gICAgICAgICAgICB0ZWxlbWV0cnksXG4gICAgICAgICAgICBhdHRyaWJ1dGVzOiB7XG4gICAgICAgICAgICAgIC4uLmFzc2VtYmxlT3BlcmF0aW9uTmFtZSh7XG4gICAgICAgICAgICAgICAgb3BlcmF0aW9uTmFtZTogXCJhaS5zdHJlYW1UZXh0LmRvU3RyZWFtXCIsXG4gICAgICAgICAgICAgICAgdGVsZW1ldHJ5XG4gICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgICAuLi5iYXNlVGVsZW1ldHJ5QXR0cmlidXRlcyxcbiAgICAgICAgICAgICAgXCJhaS5wcm9tcHQuZm9ybWF0XCI6IHtcbiAgICAgICAgICAgICAgICBpbnB1dDogKCkgPT4gdmFsaWRhdGVkUHJvbXB0LnR5cGVcbiAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgXCJhaS5wcm9tcHQubWVzc2FnZXNcIjoge1xuICAgICAgICAgICAgICAgIGlucHV0OiAoKSA9PiBKU09OLnN0cmluZ2lmeShwcm9tcHRNZXNzYWdlcylcbiAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgLy8gc3RhbmRhcmRpemVkIGdlbi1haSBsbG0gc3BhbiBhdHRyaWJ1dGVzOlxuICAgICAgICAgICAgICBcImdlbl9haS5yZXF1ZXN0Lm1vZGVsXCI6IG1vZGVsLm1vZGVsSWQsXG4gICAgICAgICAgICAgIFwiZ2VuX2FpLnN5c3RlbVwiOiBtb2RlbC5wcm92aWRlcixcbiAgICAgICAgICAgICAgXCJnZW5fYWkucmVxdWVzdC5tYXhfdG9rZW5zXCI6IHNldHRpbmdzLm1heFRva2VucyxcbiAgICAgICAgICAgICAgXCJnZW5fYWkucmVxdWVzdC50ZW1wZXJhdHVyZVwiOiBzZXR0aW5ncy50ZW1wZXJhdHVyZSxcbiAgICAgICAgICAgICAgXCJnZW5fYWkucmVxdWVzdC50b3BfcFwiOiBzZXR0aW5ncy50b3BQXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSksXG4gICAgICAgICAgdHJhY2VyLFxuICAgICAgICAgIGVuZFdoZW5Eb25lOiBmYWxzZSxcbiAgICAgICAgICBmbjogYXN5bmMgKGRvU3RyZWFtU3BhbjIpID0+IHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgIHJlc3VsdDogYXdhaXQgbW9kZWwuZG9TdHJlYW0oe1xuICAgICAgICAgICAgICAgIG1vZGU6IHtcbiAgICAgICAgICAgICAgICAgIHR5cGU6IFwicmVndWxhclwiLFxuICAgICAgICAgICAgICAgICAgLi4ucHJlcGFyZVRvb2xzQW5kVG9vbENob2ljZSh7IHRvb2xzLCB0b29sQ2hvaWNlIH0pXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAuLi5wcmVwYXJlQ2FsbFNldHRpbmdzKHNldHRpbmdzKSxcbiAgICAgICAgICAgICAgICBpbnB1dEZvcm1hdDogdmFsaWRhdGVkUHJvbXB0LnR5cGUsXG4gICAgICAgICAgICAgICAgcHJvbXB0OiBwcm9tcHRNZXNzYWdlcyxcbiAgICAgICAgICAgICAgICBhYm9ydFNpZ25hbCxcbiAgICAgICAgICAgICAgICBoZWFkZXJzXG4gICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgICBkb1N0cmVhbVNwYW46IGRvU3RyZWFtU3BhbjJcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgfVxuICAgICAgICB9KVxuICAgICAgKTtcbiAgICAgIHJldHVybiBuZXcgRGVmYXVsdFN0cmVhbVRleHRSZXN1bHQoe1xuICAgICAgICBzdHJlYW06IHJ1blRvb2xzVHJhbnNmb3JtYXRpb24oe1xuICAgICAgICAgIHRvb2xzLFxuICAgICAgICAgIGdlbmVyYXRvclN0cmVhbTogc3RyZWFtLFxuICAgICAgICAgIHRvb2xDYWxsU3RyZWFtaW5nLFxuICAgICAgICAgIHRyYWNlcixcbiAgICAgICAgICB0ZWxlbWV0cnlcbiAgICAgICAgfSksXG4gICAgICAgIHdhcm5pbmdzLFxuICAgICAgICByYXdSZXNwb25zZSxcbiAgICAgICAgb25DaHVuayxcbiAgICAgICAgb25GaW5pc2gsXG4gICAgICAgIHJvb3RTcGFuLFxuICAgICAgICBkb1N0cmVhbVNwYW4sXG4gICAgICAgIHRlbGVtZXRyeVxuICAgICAgfSk7XG4gICAgfVxuICB9KTtcbn1cbnZhciBEZWZhdWx0U3RyZWFtVGV4dFJlc3VsdCA9IGNsYXNzIHtcbiAgY29uc3RydWN0b3Ioe1xuICAgIHN0cmVhbSxcbiAgICB3YXJuaW5ncyxcbiAgICByYXdSZXNwb25zZSxcbiAgICBvbkNodW5rLFxuICAgIG9uRmluaXNoLFxuICAgIHJvb3RTcGFuLFxuICAgIGRvU3RyZWFtU3BhbixcbiAgICB0ZWxlbWV0cnlcbiAgfSkge1xuICAgIHRoaXMud2FybmluZ3MgPSB3YXJuaW5ncztcbiAgICB0aGlzLnJhd1Jlc3BvbnNlID0gcmF3UmVzcG9uc2U7XG4gICAgY29uc3QgeyByZXNvbHZlOiByZXNvbHZlVXNhZ2UsIHByb21pc2U6IHVzYWdlUHJvbWlzZSB9ID0gY3JlYXRlUmVzb2x2YWJsZVByb21pc2UoKTtcbiAgICB0aGlzLnVzYWdlID0gdXNhZ2VQcm9taXNlO1xuICAgIGNvbnN0IHsgcmVzb2x2ZTogcmVzb2x2ZUZpbmlzaFJlYXNvbiwgcHJvbWlzZTogZmluaXNoUmVhc29uUHJvbWlzZSB9ID0gY3JlYXRlUmVzb2x2YWJsZVByb21pc2UoKTtcbiAgICB0aGlzLmZpbmlzaFJlYXNvbiA9IGZpbmlzaFJlYXNvblByb21pc2U7XG4gICAgY29uc3QgeyByZXNvbHZlOiByZXNvbHZlVGV4dCwgcHJvbWlzZTogdGV4dFByb21pc2UgfSA9IGNyZWF0ZVJlc29sdmFibGVQcm9taXNlKCk7XG4gICAgdGhpcy50ZXh0ID0gdGV4dFByb21pc2U7XG4gICAgY29uc3QgeyByZXNvbHZlOiByZXNvbHZlVG9vbENhbGxzLCBwcm9taXNlOiB0b29sQ2FsbHNQcm9taXNlIH0gPSBjcmVhdGVSZXNvbHZhYmxlUHJvbWlzZSgpO1xuICAgIHRoaXMudG9vbENhbGxzID0gdG9vbENhbGxzUHJvbWlzZTtcbiAgICBjb25zdCB7IHJlc29sdmU6IHJlc29sdmVUb29sUmVzdWx0cywgcHJvbWlzZTogdG9vbFJlc3VsdHNQcm9taXNlIH0gPSBjcmVhdGVSZXNvbHZhYmxlUHJvbWlzZSgpO1xuICAgIHRoaXMudG9vbFJlc3VsdHMgPSB0b29sUmVzdWx0c1Byb21pc2U7XG4gICAgY29uc3Qge1xuICAgICAgcmVzb2x2ZTogcmVzb2x2ZVByb3ZpZGVyTWV0YWRhdGEsXG4gICAgICBwcm9taXNlOiBwcm92aWRlck1ldGFkYXRhUHJvbWlzZVxuICAgIH0gPSBjcmVhdGVSZXNvbHZhYmxlUHJvbWlzZSgpO1xuICAgIHRoaXMuZXhwZXJpbWVudGFsX3Byb3ZpZGVyTWV0YWRhdGEgPSBwcm92aWRlck1ldGFkYXRhUHJvbWlzZTtcbiAgICBsZXQgZmluaXNoUmVhc29uO1xuICAgIGxldCB1c2FnZTtcbiAgICBsZXQgcHJvdmlkZXJNZXRhZGF0YTtcbiAgICBsZXQgdGV4dCA9IFwiXCI7XG4gICAgY29uc3QgdG9vbENhbGxzID0gW107XG4gICAgY29uc3QgdG9vbFJlc3VsdHMgPSBbXTtcbiAgICBsZXQgZmlyc3RDaHVuayA9IHRydWU7XG4gICAgdGhpcy5vcmlnaW5hbFN0cmVhbSA9IHN0cmVhbS5waXBlVGhyb3VnaChcbiAgICAgIG5ldyBUcmFuc2Zvcm1TdHJlYW0oe1xuICAgICAgICBhc3luYyB0cmFuc2Zvcm0oY2h1bmssIGNvbnRyb2xsZXIpIHtcbiAgICAgICAgICBpZiAoZmlyc3RDaHVuaykge1xuICAgICAgICAgICAgZmlyc3RDaHVuayA9IGZhbHNlO1xuICAgICAgICAgICAgZG9TdHJlYW1TcGFuLmFkZEV2ZW50KFwiYWkuc3RyZWFtLmZpcnN0Q2h1bmtcIik7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChjaHVuay50eXBlID09PSBcInRleHQtZGVsdGFcIiAmJiBjaHVuay50ZXh0RGVsdGEubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICAgIGNvbnRyb2xsZXIuZW5xdWV1ZShjaHVuayk7XG4gICAgICAgICAgY29uc3QgY2h1bmtUeXBlID0gY2h1bmsudHlwZTtcbiAgICAgICAgICBzd2l0Y2ggKGNodW5rVHlwZSkge1xuICAgICAgICAgICAgY2FzZSBcInRleHQtZGVsdGFcIjpcbiAgICAgICAgICAgICAgdGV4dCArPSBjaHVuay50ZXh0RGVsdGE7XG4gICAgICAgICAgICAgIGF3YWl0IChvbkNodW5rID09IG51bGwgPyB2b2lkIDAgOiBvbkNodW5rKHsgY2h1bmsgfSkpO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgXCJ0b29sLWNhbGxcIjpcbiAgICAgICAgICAgICAgdG9vbENhbGxzLnB1c2goY2h1bmspO1xuICAgICAgICAgICAgICBhd2FpdCAob25DaHVuayA9PSBudWxsID8gdm9pZCAwIDogb25DaHVuayh7IGNodW5rIH0pKTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFwidG9vbC1yZXN1bHRcIjpcbiAgICAgICAgICAgICAgdG9vbFJlc3VsdHMucHVzaChjaHVuayk7XG4gICAgICAgICAgICAgIGF3YWl0IChvbkNodW5rID09IG51bGwgPyB2b2lkIDAgOiBvbkNodW5rKHsgY2h1bmsgfSkpO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgXCJmaW5pc2hcIjpcbiAgICAgICAgICAgICAgdXNhZ2UgPSBjaHVuay51c2FnZTtcbiAgICAgICAgICAgICAgZmluaXNoUmVhc29uID0gY2h1bmsuZmluaXNoUmVhc29uO1xuICAgICAgICAgICAgICBwcm92aWRlck1ldGFkYXRhID0gY2h1bmsuZXhwZXJpbWVudGFsX3Byb3ZpZGVyTWV0YWRhdGE7XG4gICAgICAgICAgICAgIHJlc29sdmVVc2FnZSh1c2FnZSk7XG4gICAgICAgICAgICAgIHJlc29sdmVGaW5pc2hSZWFzb24oZmluaXNoUmVhc29uKTtcbiAgICAgICAgICAgICAgcmVzb2x2ZVRleHQodGV4dCk7XG4gICAgICAgICAgICAgIHJlc29sdmVUb29sQ2FsbHModG9vbENhbGxzKTtcbiAgICAgICAgICAgICAgcmVzb2x2ZVByb3ZpZGVyTWV0YWRhdGEocHJvdmlkZXJNZXRhZGF0YSk7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBcInRvb2wtY2FsbC1zdHJlYW1pbmctc3RhcnRcIjpcbiAgICAgICAgICAgIGNhc2UgXCJ0b29sLWNhbGwtZGVsdGFcIjoge1xuICAgICAgICAgICAgICBhd2FpdCAob25DaHVuayA9PSBudWxsID8gdm9pZCAwIDogb25DaHVuayh7IGNodW5rIH0pKTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXNlIFwiZXJyb3JcIjpcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBkZWZhdWx0OiB7XG4gICAgICAgICAgICAgIGNvbnN0IGV4aGF1c3RpdmVDaGVjayA9IGNodW5rVHlwZTtcbiAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBVbmtub3duIGNodW5rIHR5cGU6ICR7ZXhoYXVzdGl2ZUNoZWNrfWApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgLy8gaW52b2tlIG9uRmluaXNoIGNhbGxiYWNrIGFuZCByZXNvbHZlIHRvb2xSZXN1bHRzIHByb21pc2Ugd2hlbiB0aGUgc3RyZWFtIGlzIGFib3V0IHRvIGNsb3NlOlxuICAgICAgICBhc3luYyBmbHVzaChjb250cm9sbGVyKSB7XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IGZpbmFsVXNhZ2UgPSB1c2FnZSAhPSBudWxsID8gdXNhZ2UgOiB7XG4gICAgICAgICAgICAgIHByb21wdFRva2VuczogTmFOLFxuICAgICAgICAgICAgICBjb21wbGV0aW9uVG9rZW5zOiBOYU4sXG4gICAgICAgICAgICAgIHRvdGFsVG9rZW5zOiBOYU5cbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBjb25zdCBmaW5hbEZpbmlzaFJlYXNvbiA9IGZpbmlzaFJlYXNvbiAhPSBudWxsID8gZmluaXNoUmVhc29uIDogXCJ1bmtub3duXCI7XG4gICAgICAgICAgICBjb25zdCB0ZWxlbWV0cnlUb29sQ2FsbHMgPSB0b29sQ2FsbHMubGVuZ3RoID4gMCA/IEpTT04uc3RyaW5naWZ5KHRvb2xDYWxscykgOiB2b2lkIDA7XG4gICAgICAgICAgICBkb1N0cmVhbVNwYW4uc2V0QXR0cmlidXRlcyhcbiAgICAgICAgICAgICAgc2VsZWN0VGVsZW1ldHJ5QXR0cmlidXRlcyh7XG4gICAgICAgICAgICAgICAgdGVsZW1ldHJ5LFxuICAgICAgICAgICAgICAgIGF0dHJpYnV0ZXM6IHtcbiAgICAgICAgICAgICAgICAgIFwiYWkuZmluaXNoUmVhc29uXCI6IGZpbmFsRmluaXNoUmVhc29uLFxuICAgICAgICAgICAgICAgICAgXCJhaS51c2FnZS5wcm9tcHRUb2tlbnNcIjogZmluYWxVc2FnZS5wcm9tcHRUb2tlbnMsXG4gICAgICAgICAgICAgICAgICBcImFpLnVzYWdlLmNvbXBsZXRpb25Ub2tlbnNcIjogZmluYWxVc2FnZS5jb21wbGV0aW9uVG9rZW5zLFxuICAgICAgICAgICAgICAgICAgXCJhaS5yZXN1bHQudGV4dFwiOiB7IG91dHB1dDogKCkgPT4gdGV4dCB9LFxuICAgICAgICAgICAgICAgICAgXCJhaS5yZXN1bHQudG9vbENhbGxzXCI6IHsgb3V0cHV0OiAoKSA9PiB0ZWxlbWV0cnlUb29sQ2FsbHMgfSxcbiAgICAgICAgICAgICAgICAgIC8vIHN0YW5kYXJkaXplZCBnZW4tYWkgbGxtIHNwYW4gYXR0cmlidXRlczpcbiAgICAgICAgICAgICAgICAgIFwiZ2VuX2FpLnJlc3BvbnNlLmZpbmlzaF9yZWFzb25zXCI6IFtmaW5hbEZpbmlzaFJlYXNvbl0sXG4gICAgICAgICAgICAgICAgICBcImdlbl9haS51c2FnZS5wcm9tcHRfdG9rZW5zXCI6IGZpbmFsVXNhZ2UucHJvbXB0VG9rZW5zLFxuICAgICAgICAgICAgICAgICAgXCJnZW5fYWkudXNhZ2UuY29tcGxldGlvbl90b2tlbnNcIjogZmluYWxVc2FnZS5jb21wbGV0aW9uVG9rZW5zXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIGRvU3RyZWFtU3Bhbi5lbmQoKTtcbiAgICAgICAgICAgIHJvb3RTcGFuLnNldEF0dHJpYnV0ZXMoXG4gICAgICAgICAgICAgIHNlbGVjdFRlbGVtZXRyeUF0dHJpYnV0ZXMoe1xuICAgICAgICAgICAgICAgIHRlbGVtZXRyeSxcbiAgICAgICAgICAgICAgICBhdHRyaWJ1dGVzOiB7XG4gICAgICAgICAgICAgICAgICBcImFpLmZpbmlzaFJlYXNvblwiOiBmaW5hbEZpbmlzaFJlYXNvbixcbiAgICAgICAgICAgICAgICAgIFwiYWkudXNhZ2UucHJvbXB0VG9rZW5zXCI6IGZpbmFsVXNhZ2UucHJvbXB0VG9rZW5zLFxuICAgICAgICAgICAgICAgICAgXCJhaS51c2FnZS5jb21wbGV0aW9uVG9rZW5zXCI6IGZpbmFsVXNhZ2UuY29tcGxldGlvblRva2VucyxcbiAgICAgICAgICAgICAgICAgIFwiYWkucmVzdWx0LnRleHRcIjogeyBvdXRwdXQ6ICgpID0+IHRleHQgfSxcbiAgICAgICAgICAgICAgICAgIFwiYWkucmVzdWx0LnRvb2xDYWxsc1wiOiB7IG91dHB1dDogKCkgPT4gdGVsZW1ldHJ5VG9vbENhbGxzIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgcmVzb2x2ZVRvb2xSZXN1bHRzKHRvb2xSZXN1bHRzKTtcbiAgICAgICAgICAgIGF3YWl0IChvbkZpbmlzaCA9PSBudWxsID8gdm9pZCAwIDogb25GaW5pc2goe1xuICAgICAgICAgICAgICBmaW5pc2hSZWFzb246IGZpbmFsRmluaXNoUmVhc29uLFxuICAgICAgICAgICAgICB1c2FnZTogZmluYWxVc2FnZSxcbiAgICAgICAgICAgICAgdGV4dCxcbiAgICAgICAgICAgICAgdG9vbENhbGxzLFxuICAgICAgICAgICAgICAvLyBUaGUgdG9vbCByZXN1bHRzIGFyZSBpbmZlcnJlZCBhcyBhIG5ldmVyW10gdHlwZSwgYmVjYXVzZSB0aGV5IGFyZVxuICAgICAgICAgICAgICAvLyBvcHRpb25hbCBhbmQgdGhlIGV4ZWN1dGUgbWV0aG9kIHdpdGggYW4gaW5mZXJyZWQgcmVzdWx0IHR5cGUgaXNcbiAgICAgICAgICAgICAgLy8gb3B0aW9uYWwgYXMgd2VsbC4gVGhlcmVmb3JlIHdlIG5lZWQgdG8gY2FzdCB0aGUgdG9vbFJlc3VsdHMgdG8gYW55LlxuICAgICAgICAgICAgICAvLyBUaGUgdHlwZSBleHBvc2VkIHRvIHRoZSB1c2VycyB3aWxsIGJlIGNvcnJlY3RseSBpbmZlcnJlZC5cbiAgICAgICAgICAgICAgdG9vbFJlc3VsdHMsXG4gICAgICAgICAgICAgIHJhd1Jlc3BvbnNlLFxuICAgICAgICAgICAgICB3YXJuaW5ncyxcbiAgICAgICAgICAgICAgZXhwZXJpbWVudGFsX3Byb3ZpZGVyTWV0YWRhdGE6IHByb3ZpZGVyTWV0YWRhdGFcbiAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgY29udHJvbGxlci5lcnJvcihlcnJvcik7XG4gICAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgIHJvb3RTcGFuLmVuZCgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSlcbiAgICApO1xuICB9XG4gIC8qKlxuICBTcGxpdCBvdXQgYSBuZXcgc3RyZWFtIGZyb20gdGhlIG9yaWdpbmFsIHN0cmVhbS5cbiAgVGhlIG9yaWdpbmFsIHN0cmVhbSBpcyByZXBsYWNlZCB0byBhbGxvdyBmb3IgZnVydGhlciBzcGxpdHRpbmcsXG4gIHNpbmNlIHdlIGRvIG5vdCBrbm93IGhvdyBtYW55IHRpbWVzIHRoZSBzdHJlYW0gd2lsbCBiZSBzcGxpdC5cbiAgXG4gIE5vdGU6IHRoaXMgbGVhZHMgdG8gYnVmZmVyaW5nIHRoZSBzdHJlYW0gY29udGVudCBvbiB0aGUgc2VydmVyLlxuICBIb3dldmVyLCB0aGUgTExNIHJlc3VsdHMgYXJlIGV4cGVjdGVkIHRvIGJlIHNtYWxsIGVub3VnaCB0byBub3QgY2F1c2UgaXNzdWVzLlxuICAgICAqL1xuICB0ZWVTdHJlYW0oKSB7XG4gICAgY29uc3QgW3N0cmVhbTEsIHN0cmVhbTJdID0gdGhpcy5vcmlnaW5hbFN0cmVhbS50ZWUoKTtcbiAgICB0aGlzLm9yaWdpbmFsU3RyZWFtID0gc3RyZWFtMjtcbiAgICByZXR1cm4gc3RyZWFtMTtcbiAgfVxuICBnZXQgdGV4dFN0cmVhbSgpIHtcbiAgICByZXR1cm4gY3JlYXRlQXN5bmNJdGVyYWJsZVN0cmVhbSh0aGlzLnRlZVN0cmVhbSgpLCB7XG4gICAgICB0cmFuc2Zvcm0oY2h1bmssIGNvbnRyb2xsZXIpIHtcbiAgICAgICAgaWYgKGNodW5rLnR5cGUgPT09IFwidGV4dC1kZWx0YVwiKSB7XG4gICAgICAgICAgY29udHJvbGxlci5lbnF1ZXVlKGNodW5rLnRleHREZWx0YSk7XG4gICAgICAgIH0gZWxzZSBpZiAoY2h1bmsudHlwZSA9PT0gXCJlcnJvclwiKSB7XG4gICAgICAgICAgY29udHJvbGxlci5lcnJvcihjaHVuay5lcnJvcik7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuICBnZXQgZnVsbFN0cmVhbSgpIHtcbiAgICByZXR1cm4gY3JlYXRlQXN5bmNJdGVyYWJsZVN0cmVhbSh0aGlzLnRlZVN0cmVhbSgpLCB7XG4gICAgICB0cmFuc2Zvcm0oY2h1bmssIGNvbnRyb2xsZXIpIHtcbiAgICAgICAgY29udHJvbGxlci5lbnF1ZXVlKGNodW5rKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuICB0b0FJU3RyZWFtKGNhbGxiYWNrcyA9IHt9KSB7XG4gICAgcmV0dXJuIHRoaXMudG9EYXRhU3RyZWFtKHsgY2FsbGJhY2tzIH0pO1xuICB9XG4gIHRvRGF0YVN0cmVhbSh7XG4gICAgY2FsbGJhY2tzID0ge30sXG4gICAgZ2V0RXJyb3JNZXNzYWdlOiBnZXRFcnJvck1lc3NhZ2U0ID0gKCkgPT4gXCJcIlxuICAgIC8vIG1hc2sgZXJyb3IgbWVzc2FnZXMgZm9yIHNhZmV0eSBieSBkZWZhdWx0XG4gIH0gPSB7fSkge1xuICAgIGxldCBhZ2dyZWdhdGVkUmVzcG9uc2UgPSBcIlwiO1xuICAgIGNvbnN0IGNhbGxiYWNrVHJhbnNmb3JtZXIgPSBuZXcgVHJhbnNmb3JtU3RyZWFtKHtcbiAgICAgIGFzeW5jIHN0YXJ0KCkge1xuICAgICAgICBpZiAoY2FsbGJhY2tzLm9uU3RhcnQpXG4gICAgICAgICAgYXdhaXQgY2FsbGJhY2tzLm9uU3RhcnQoKTtcbiAgICAgIH0sXG4gICAgICBhc3luYyB0cmFuc2Zvcm0oY2h1bmssIGNvbnRyb2xsZXIpIHtcbiAgICAgICAgY29udHJvbGxlci5lbnF1ZXVlKGNodW5rKTtcbiAgICAgICAgaWYgKGNodW5rLnR5cGUgPT09IFwidGV4dC1kZWx0YVwiKSB7XG4gICAgICAgICAgY29uc3QgdGV4dERlbHRhID0gY2h1bmsudGV4dERlbHRhO1xuICAgICAgICAgIGFnZ3JlZ2F0ZWRSZXNwb25zZSArPSB0ZXh0RGVsdGE7XG4gICAgICAgICAgaWYgKGNhbGxiYWNrcy5vblRva2VuKVxuICAgICAgICAgICAgYXdhaXQgY2FsbGJhY2tzLm9uVG9rZW4odGV4dERlbHRhKTtcbiAgICAgICAgICBpZiAoY2FsbGJhY2tzLm9uVGV4dClcbiAgICAgICAgICAgIGF3YWl0IGNhbGxiYWNrcy5vblRleHQodGV4dERlbHRhKTtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIGFzeW5jIGZsdXNoKCkge1xuICAgICAgICBpZiAoY2FsbGJhY2tzLm9uQ29tcGxldGlvbilcbiAgICAgICAgICBhd2FpdCBjYWxsYmFja3Mub25Db21wbGV0aW9uKGFnZ3JlZ2F0ZWRSZXNwb25zZSk7XG4gICAgICAgIGlmIChjYWxsYmFja3Mub25GaW5hbClcbiAgICAgICAgICBhd2FpdCBjYWxsYmFja3Mub25GaW5hbChhZ2dyZWdhdGVkUmVzcG9uc2UpO1xuICAgICAgfVxuICAgIH0pO1xuICAgIGNvbnN0IHN0cmVhbVBhcnRzVHJhbnNmb3JtZXIgPSBuZXcgVHJhbnNmb3JtU3RyZWFtKHtcbiAgICAgIHRyYW5zZm9ybTogYXN5bmMgKGNodW5rLCBjb250cm9sbGVyKSA9PiB7XG4gICAgICAgIGNvbnN0IGNodW5rVHlwZSA9IGNodW5rLnR5cGU7XG4gICAgICAgIHN3aXRjaCAoY2h1bmtUeXBlKSB7XG4gICAgICAgICAgY2FzZSBcInRleHQtZGVsdGFcIjpcbiAgICAgICAgICAgIGNvbnRyb2xsZXIuZW5xdWV1ZShmb3JtYXRTdHJlYW1QYXJ0KFwidGV4dFwiLCBjaHVuay50ZXh0RGVsdGEpKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgXCJ0b29sLWNhbGwtc3RyZWFtaW5nLXN0YXJ0XCI6XG4gICAgICAgICAgICBjb250cm9sbGVyLmVucXVldWUoXG4gICAgICAgICAgICAgIGZvcm1hdFN0cmVhbVBhcnQoXCJ0b29sX2NhbGxfc3RyZWFtaW5nX3N0YXJ0XCIsIHtcbiAgICAgICAgICAgICAgICB0b29sQ2FsbElkOiBjaHVuay50b29sQ2FsbElkLFxuICAgICAgICAgICAgICAgIHRvb2xOYW1lOiBjaHVuay50b29sTmFtZVxuICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgXCJ0b29sLWNhbGwtZGVsdGFcIjpcbiAgICAgICAgICAgIGNvbnRyb2xsZXIuZW5xdWV1ZShcbiAgICAgICAgICAgICAgZm9ybWF0U3RyZWFtUGFydChcInRvb2xfY2FsbF9kZWx0YVwiLCB7XG4gICAgICAgICAgICAgICAgdG9vbENhbGxJZDogY2h1bmsudG9vbENhbGxJZCxcbiAgICAgICAgICAgICAgICBhcmdzVGV4dERlbHRhOiBjaHVuay5hcmdzVGV4dERlbHRhXG4gICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSBcInRvb2wtY2FsbFwiOlxuICAgICAgICAgICAgY29udHJvbGxlci5lbnF1ZXVlKFxuICAgICAgICAgICAgICBmb3JtYXRTdHJlYW1QYXJ0KFwidG9vbF9jYWxsXCIsIHtcbiAgICAgICAgICAgICAgICB0b29sQ2FsbElkOiBjaHVuay50b29sQ2FsbElkLFxuICAgICAgICAgICAgICAgIHRvb2xOYW1lOiBjaHVuay50b29sTmFtZSxcbiAgICAgICAgICAgICAgICBhcmdzOiBjaHVuay5hcmdzXG4gICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSBcInRvb2wtcmVzdWx0XCI6XG4gICAgICAgICAgICBjb250cm9sbGVyLmVucXVldWUoXG4gICAgICAgICAgICAgIGZvcm1hdFN0cmVhbVBhcnQoXCJ0b29sX3Jlc3VsdFwiLCB7XG4gICAgICAgICAgICAgICAgdG9vbENhbGxJZDogY2h1bmsudG9vbENhbGxJZCxcbiAgICAgICAgICAgICAgICByZXN1bHQ6IGNodW5rLnJlc3VsdFxuICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgXCJlcnJvclwiOlxuICAgICAgICAgICAgY29udHJvbGxlci5lbnF1ZXVlKFxuICAgICAgICAgICAgICBmb3JtYXRTdHJlYW1QYXJ0KFwiZXJyb3JcIiwgZ2V0RXJyb3JNZXNzYWdlNChjaHVuay5lcnJvcikpXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSBcImZpbmlzaFwiOlxuICAgICAgICAgICAgY29udHJvbGxlci5lbnF1ZXVlKFxuICAgICAgICAgICAgICBmb3JtYXRTdHJlYW1QYXJ0KFwiZmluaXNoX21lc3NhZ2VcIiwge1xuICAgICAgICAgICAgICAgIGZpbmlzaFJlYXNvbjogY2h1bmsuZmluaXNoUmVhc29uLFxuICAgICAgICAgICAgICAgIHVzYWdlOiB7XG4gICAgICAgICAgICAgICAgICBwcm9tcHRUb2tlbnM6IGNodW5rLnVzYWdlLnByb21wdFRva2VucyxcbiAgICAgICAgICAgICAgICAgIGNvbXBsZXRpb25Ub2tlbnM6IGNodW5rLnVzYWdlLmNvbXBsZXRpb25Ub2tlbnNcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgZGVmYXVsdDoge1xuICAgICAgICAgICAgY29uc3QgZXhoYXVzdGl2ZUNoZWNrID0gY2h1bmtUeXBlO1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBVbmtub3duIGNodW5rIHR5cGU6ICR7ZXhoYXVzdGl2ZUNoZWNrfWApO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiB0aGlzLmZ1bGxTdHJlYW0ucGlwZVRocm91Z2goY2FsbGJhY2tUcmFuc2Zvcm1lcikucGlwZVRocm91Z2goc3RyZWFtUGFydHNUcmFuc2Zvcm1lcikucGlwZVRocm91Z2gobmV3IFRleHRFbmNvZGVyU3RyZWFtKCkpO1xuICB9XG4gIHBpcGVBSVN0cmVhbVRvUmVzcG9uc2UocmVzcG9uc2UsIGluaXQpIHtcbiAgICByZXR1cm4gdGhpcy5waXBlRGF0YVN0cmVhbVRvUmVzcG9uc2UocmVzcG9uc2UsIGluaXQpO1xuICB9XG4gIHBpcGVEYXRhU3RyZWFtVG9SZXNwb25zZShyZXNwb25zZSwgaW5pdCkge1xuICAgIHZhciBfYTEyO1xuICAgIHJlc3BvbnNlLndyaXRlSGVhZCgoX2ExMiA9IGluaXQgPT0gbnVsbCA/IHZvaWQgMCA6IGluaXQuc3RhdHVzKSAhPSBudWxsID8gX2ExMiA6IDIwMCwge1xuICAgICAgXCJDb250ZW50LVR5cGVcIjogXCJ0ZXh0L3BsYWluOyBjaGFyc2V0PXV0Zi04XCIsXG4gICAgICAuLi5pbml0ID09IG51bGwgPyB2b2lkIDAgOiBpbml0LmhlYWRlcnNcbiAgICB9KTtcbiAgICBjb25zdCByZWFkZXIgPSB0aGlzLnRvRGF0YVN0cmVhbSgpLmdldFJlYWRlcigpO1xuICAgIGNvbnN0IHJlYWQgPSBhc3luYyAoKSA9PiB7XG4gICAgICB0cnkge1xuICAgICAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgICAgIGNvbnN0IHsgZG9uZSwgdmFsdWUgfSA9IGF3YWl0IHJlYWRlci5yZWFkKCk7XG4gICAgICAgICAgaWYgKGRvbmUpXG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICByZXNwb25zZS53cml0ZSh2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIHRocm93IGVycm9yO1xuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgcmVzcG9uc2UuZW5kKCk7XG4gICAgICB9XG4gICAgfTtcbiAgICByZWFkKCk7XG4gIH1cbiAgcGlwZVRleHRTdHJlYW1Ub1Jlc3BvbnNlKHJlc3BvbnNlLCBpbml0KSB7XG4gICAgdmFyIF9hMTI7XG4gICAgcmVzcG9uc2Uud3JpdGVIZWFkKChfYTEyID0gaW5pdCA9PSBudWxsID8gdm9pZCAwIDogaW5pdC5zdGF0dXMpICE9IG51bGwgPyBfYTEyIDogMjAwLCB7XG4gICAgICBcIkNvbnRlbnQtVHlwZVwiOiBcInRleHQvcGxhaW47IGNoYXJzZXQ9dXRmLThcIixcbiAgICAgIC4uLmluaXQgPT0gbnVsbCA/IHZvaWQgMCA6IGluaXQuaGVhZGVyc1xuICAgIH0pO1xuICAgIGNvbnN0IHJlYWRlciA9IHRoaXMudGV4dFN0cmVhbS5waXBlVGhyb3VnaChuZXcgVGV4dEVuY29kZXJTdHJlYW0oKSkuZ2V0UmVhZGVyKCk7XG4gICAgY29uc3QgcmVhZCA9IGFzeW5jICgpID0+IHtcbiAgICAgIHRyeSB7XG4gICAgICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICAgICAgY29uc3QgeyBkb25lLCB2YWx1ZSB9ID0gYXdhaXQgcmVhZGVyLnJlYWQoKTtcbiAgICAgICAgICBpZiAoZG9uZSlcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIHJlc3BvbnNlLndyaXRlKHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICByZXNwb25zZS5lbmQoKTtcbiAgICAgIH1cbiAgICB9O1xuICAgIHJlYWQoKTtcbiAgfVxuICB0b0FJU3RyZWFtUmVzcG9uc2Uob3B0aW9ucykge1xuICAgIHJldHVybiB0aGlzLnRvRGF0YVN0cmVhbVJlc3BvbnNlKG9wdGlvbnMpO1xuICB9XG4gIHRvRGF0YVN0cmVhbVJlc3BvbnNlKG9wdGlvbnMpIHtcbiAgICB2YXIgX2ExMjtcbiAgICBjb25zdCBpbml0ID0gb3B0aW9ucyA9PSBudWxsID8gdm9pZCAwIDogXCJpbml0XCIgaW4gb3B0aW9ucyA/IG9wdGlvbnMuaW5pdCA6IHtcbiAgICAgIGhlYWRlcnM6IFwiaGVhZGVyc1wiIGluIG9wdGlvbnMgPyBvcHRpb25zLmhlYWRlcnMgOiB2b2lkIDAsXG4gICAgICBzdGF0dXM6IFwic3RhdHVzXCIgaW4gb3B0aW9ucyA/IG9wdGlvbnMuc3RhdHVzIDogdm9pZCAwLFxuICAgICAgc3RhdHVzVGV4dDogXCJzdGF0dXNUZXh0XCIgaW4gb3B0aW9ucyA/IG9wdGlvbnMuc3RhdHVzVGV4dCA6IHZvaWQgMFxuICAgIH07XG4gICAgY29uc3QgZGF0YSA9IG9wdGlvbnMgPT0gbnVsbCA/IHZvaWQgMCA6IFwiZGF0YVwiIGluIG9wdGlvbnMgPyBvcHRpb25zLmRhdGEgOiB2b2lkIDA7XG4gICAgY29uc3QgZ2V0RXJyb3JNZXNzYWdlNCA9IG9wdGlvbnMgPT0gbnVsbCA/IHZvaWQgMCA6IFwiZ2V0RXJyb3JNZXNzYWdlXCIgaW4gb3B0aW9ucyA/IG9wdGlvbnMuZ2V0RXJyb3JNZXNzYWdlIDogdm9pZCAwO1xuICAgIGNvbnN0IHN0cmVhbSA9IGRhdGEgPyBtZXJnZVN0cmVhbXMoZGF0YS5zdHJlYW0sIHRoaXMudG9EYXRhU3RyZWFtKHsgZ2V0RXJyb3JNZXNzYWdlOiBnZXRFcnJvck1lc3NhZ2U0IH0pKSA6IHRoaXMudG9EYXRhU3RyZWFtKHsgZ2V0RXJyb3JNZXNzYWdlOiBnZXRFcnJvck1lc3NhZ2U0IH0pO1xuICAgIHJldHVybiBuZXcgUmVzcG9uc2Uoc3RyZWFtLCB7XG4gICAgICBzdGF0dXM6IChfYTEyID0gaW5pdCA9PSBudWxsID8gdm9pZCAwIDogaW5pdC5zdGF0dXMpICE9IG51bGwgPyBfYTEyIDogMjAwLFxuICAgICAgc3RhdHVzVGV4dDogaW5pdCA9PSBudWxsID8gdm9pZCAwIDogaW5pdC5zdGF0dXNUZXh0LFxuICAgICAgaGVhZGVyczogcHJlcGFyZVJlc3BvbnNlSGVhZGVycyhpbml0LCB7XG4gICAgICAgIGNvbnRlbnRUeXBlOiBcInRleHQvcGxhaW47IGNoYXJzZXQ9dXRmLThcIixcbiAgICAgICAgZGF0YVN0cmVhbVZlcnNpb246IFwidjFcIlxuICAgICAgfSlcbiAgICB9KTtcbiAgfVxuICB0b1RleHRTdHJlYW1SZXNwb25zZShpbml0KSB7XG4gICAgdmFyIF9hMTI7XG4gICAgcmV0dXJuIG5ldyBSZXNwb25zZSh0aGlzLnRleHRTdHJlYW0ucGlwZVRocm91Z2gobmV3IFRleHRFbmNvZGVyU3RyZWFtKCkpLCB7XG4gICAgICBzdGF0dXM6IChfYTEyID0gaW5pdCA9PSBudWxsID8gdm9pZCAwIDogaW5pdC5zdGF0dXMpICE9IG51bGwgPyBfYTEyIDogMjAwLFxuICAgICAgaGVhZGVyczogcHJlcGFyZVJlc3BvbnNlSGVhZGVycyhpbml0LCB7XG4gICAgICAgIGNvbnRlbnRUeXBlOiBcInRleHQvcGxhaW47IGNoYXJzZXQ9dXRmLThcIlxuICAgICAgfSlcbiAgICB9KTtcbiAgfVxufTtcbnZhciBleHBlcmltZW50YWxfc3RyZWFtVGV4dCA9IHN0cmVhbVRleHQ7XG5cbi8vIGNvcmUvcHJvbXB0L2F0dGFjaG1lbnRzLXRvLXBhcnRzLnRzXG5mdW5jdGlvbiBhdHRhY2htZW50c1RvUGFydHMoYXR0YWNobWVudHMpIHtcbiAgdmFyIF9hMTIsIF9iLCBfYztcbiAgY29uc3QgcGFydHMgPSBbXTtcbiAgZm9yIChjb25zdCBhdHRhY2htZW50IG9mIGF0dGFjaG1lbnRzKSB7XG4gICAgbGV0IHVybDtcbiAgICB0cnkge1xuICAgICAgdXJsID0gbmV3IFVSTChhdHRhY2htZW50LnVybCk7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCBVUkw6ICR7YXR0YWNobWVudC51cmx9YCk7XG4gICAgfVxuICAgIHN3aXRjaCAodXJsLnByb3RvY29sKSB7XG4gICAgICBjYXNlIFwiaHR0cDpcIjpcbiAgICAgIGNhc2UgXCJodHRwczpcIjoge1xuICAgICAgICBpZiAoKF9hMTIgPSBhdHRhY2htZW50LmNvbnRlbnRUeXBlKSA9PSBudWxsID8gdm9pZCAwIDogX2ExMi5zdGFydHNXaXRoKFwiaW1hZ2UvXCIpKSB7XG4gICAgICAgICAgcGFydHMucHVzaCh7IHR5cGU6IFwiaW1hZ2VcIiwgaW1hZ2U6IHVybCB9KTtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIGNhc2UgXCJkYXRhOlwiOiB7XG4gICAgICAgIGxldCBoZWFkZXI7XG4gICAgICAgIGxldCBiYXNlNjRDb250ZW50O1xuICAgICAgICBsZXQgbWltZVR5cGU7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgW2hlYWRlciwgYmFzZTY0Q29udGVudF0gPSBhdHRhY2htZW50LnVybC5zcGxpdChcIixcIik7XG4gICAgICAgICAgbWltZVR5cGUgPSBoZWFkZXIuc3BsaXQoXCI7XCIpWzBdLnNwbGl0KFwiOlwiKVsxXTtcbiAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEVycm9yIHByb2Nlc3NpbmcgZGF0YSBVUkw6ICR7YXR0YWNobWVudC51cmx9YCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG1pbWVUeXBlID09IG51bGwgfHwgYmFzZTY0Q29udGVudCA9PSBudWxsKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIGRhdGEgVVJMIGZvcm1hdDogJHthdHRhY2htZW50LnVybH1gKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoKF9iID0gYXR0YWNobWVudC5jb250ZW50VHlwZSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9iLnN0YXJ0c1dpdGgoXCJpbWFnZS9cIikpIHtcbiAgICAgICAgICBwYXJ0cy5wdXNoKHtcbiAgICAgICAgICAgIHR5cGU6IFwiaW1hZ2VcIixcbiAgICAgICAgICAgIGltYWdlOiBjb252ZXJ0RGF0YUNvbnRlbnRUb1VpbnQ4QXJyYXkoYmFzZTY0Q29udGVudClcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSBlbHNlIGlmICgoX2MgPSBhdHRhY2htZW50LmNvbnRlbnRUeXBlKSA9PSBudWxsID8gdm9pZCAwIDogX2Muc3RhcnRzV2l0aChcInRleHQvXCIpKSB7XG4gICAgICAgICAgcGFydHMucHVzaCh7XG4gICAgICAgICAgICB0eXBlOiBcInRleHRcIixcbiAgICAgICAgICAgIHRleHQ6IGNvbnZlcnRVaW50OEFycmF5VG9UZXh0KFxuICAgICAgICAgICAgICBjb252ZXJ0RGF0YUNvbnRlbnRUb1VpbnQ4QXJyYXkoYmFzZTY0Q29udGVudClcbiAgICAgICAgICAgIClcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIGRlZmF1bHQ6IHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBVbnN1cHBvcnRlZCBVUkwgcHJvdG9jb2w6ICR7dXJsLnByb3RvY29sfWApO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gcGFydHM7XG59XG5cbi8vIGNvcmUvcHJvbXB0L2NvbnZlcnQtdG8tY29yZS1tZXNzYWdlcy50c1xuZnVuY3Rpb24gY29udmVydFRvQ29yZU1lc3NhZ2VzKG1lc3NhZ2VzKSB7XG4gIGNvbnN0IGNvcmVNZXNzYWdlcyA9IFtdO1xuICBmb3IgKGNvbnN0IHtcbiAgICByb2xlLFxuICAgIGNvbnRlbnQsXG4gICAgdG9vbEludm9jYXRpb25zLFxuICAgIGV4cGVyaW1lbnRhbF9hdHRhY2htZW50c1xuICB9IG9mIG1lc3NhZ2VzKSB7XG4gICAgc3dpdGNoIChyb2xlKSB7XG4gICAgICBjYXNlIFwic3lzdGVtXCI6IHtcbiAgICAgICAgY29yZU1lc3NhZ2VzLnB1c2goe1xuICAgICAgICAgIHJvbGU6IFwic3lzdGVtXCIsXG4gICAgICAgICAgY29udGVudFxuICAgICAgICB9KTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBjYXNlIFwidXNlclwiOiB7XG4gICAgICAgIGNvcmVNZXNzYWdlcy5wdXNoKHtcbiAgICAgICAgICByb2xlOiBcInVzZXJcIixcbiAgICAgICAgICBjb250ZW50OiBleHBlcmltZW50YWxfYXR0YWNobWVudHMgPyBbXG4gICAgICAgICAgICB7IHR5cGU6IFwidGV4dFwiLCB0ZXh0OiBjb250ZW50IH0sXG4gICAgICAgICAgICAuLi5hdHRhY2htZW50c1RvUGFydHMoZXhwZXJpbWVudGFsX2F0dGFjaG1lbnRzKVxuICAgICAgICAgIF0gOiBjb250ZW50XG4gICAgICAgIH0pO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIGNhc2UgXCJhc3Npc3RhbnRcIjoge1xuICAgICAgICBpZiAodG9vbEludm9jYXRpb25zID09IG51bGwpIHtcbiAgICAgICAgICBjb3JlTWVzc2FnZXMucHVzaCh7IHJvbGU6IFwiYXNzaXN0YW50XCIsIGNvbnRlbnQgfSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgY29yZU1lc3NhZ2VzLnB1c2goe1xuICAgICAgICAgIHJvbGU6IFwiYXNzaXN0YW50XCIsXG4gICAgICAgICAgY29udGVudDogW1xuICAgICAgICAgICAgeyB0eXBlOiBcInRleHRcIiwgdGV4dDogY29udGVudCB9LFxuICAgICAgICAgICAgLi4udG9vbEludm9jYXRpb25zLm1hcCgoeyB0b29sQ2FsbElkLCB0b29sTmFtZSwgYXJncyB9KSA9PiAoe1xuICAgICAgICAgICAgICB0eXBlOiBcInRvb2wtY2FsbFwiLFxuICAgICAgICAgICAgICB0b29sQ2FsbElkLFxuICAgICAgICAgICAgICB0b29sTmFtZSxcbiAgICAgICAgICAgICAgYXJnc1xuICAgICAgICAgICAgfSkpXG4gICAgICAgICAgXVxuICAgICAgICB9KTtcbiAgICAgICAgY29yZU1lc3NhZ2VzLnB1c2goe1xuICAgICAgICAgIHJvbGU6IFwidG9vbFwiLFxuICAgICAgICAgIGNvbnRlbnQ6IHRvb2xJbnZvY2F0aW9ucy5tYXAoXG4gICAgICAgICAgICAoeyB0b29sQ2FsbElkLCB0b29sTmFtZSwgYXJncywgcmVzdWx0IH0pID0+ICh7XG4gICAgICAgICAgICAgIHR5cGU6IFwidG9vbC1yZXN1bHRcIixcbiAgICAgICAgICAgICAgdG9vbENhbGxJZCxcbiAgICAgICAgICAgICAgdG9vbE5hbWUsXG4gICAgICAgICAgICAgIGFyZ3MsXG4gICAgICAgICAgICAgIHJlc3VsdFxuICAgICAgICAgICAgfSlcbiAgICAgICAgICApXG4gICAgICAgIH0pO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIGRlZmF1bHQ6IHtcbiAgICAgICAgY29uc3QgX2V4aGF1c3RpdmVDaGVjayA9IHJvbGU7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgVW5oYW5kbGVkIHJvbGU6ICR7X2V4aGF1c3RpdmVDaGVja31gKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIGNvcmVNZXNzYWdlcztcbn1cblxuLy8gY29yZS9yZWdpc3RyeS9pbnZhbGlkLW1vZGVsLWlkLWVycm9yLnRzXG5pbXBvcnQgeyBBSVNES0Vycm9yIGFzIEFJU0RLRXJyb3I5IH0gZnJvbSBcIkBhaS1zZGsvcHJvdmlkZXJcIjtcbnZhciBuYW1lOSA9IFwiQUlfSW52YWxpZE1vZGVsSWRFcnJvclwiO1xudmFyIG1hcmtlcjkgPSBgdmVyY2VsLmFpLmVycm9yLiR7bmFtZTl9YDtcbnZhciBzeW1ib2w5ID0gU3ltYm9sLmZvcihtYXJrZXI5KTtcbnZhciBfYTk7XG52YXIgSW52YWxpZE1vZGVsSWRFcnJvciA9IGNsYXNzIGV4dGVuZHMgQUlTREtFcnJvcjkge1xuICBjb25zdHJ1Y3Rvcih7XG4gICAgaWQsXG4gICAgbWVzc2FnZSA9IGBJbnZhbGlkIG1vZGVsIGlkOiAke2lkfWBcbiAgfSkge1xuICAgIHN1cGVyKHsgbmFtZTogbmFtZTksIG1lc3NhZ2UgfSk7XG4gICAgdGhpc1tfYTldID0gdHJ1ZTtcbiAgICB0aGlzLmlkID0gaWQ7XG4gIH1cbiAgc3RhdGljIGlzSW5zdGFuY2UoZXJyb3IpIHtcbiAgICByZXR1cm4gQUlTREtFcnJvcjkuaGFzTWFya2VyKGVycm9yLCBtYXJrZXI5KTtcbiAgfVxuICAvKipcbiAgICogQGRlcHJlY2F0ZWQgdXNlIGBpc0luc3RhbmNlYCBpbnN0ZWFkXG4gICAqL1xuICBzdGF0aWMgaXNJbnZhbGlkTW9kZWxJZEVycm9yKGVycm9yKSB7XG4gICAgcmV0dXJuIGVycm9yIGluc3RhbmNlb2YgRXJyb3IgJiYgZXJyb3IubmFtZSA9PT0gbmFtZTkgJiYgdHlwZW9mIGVycm9yLmlkID09PSBcInN0cmluZ1wiO1xuICB9XG4gIC8qKlxuICAgKiBAZGVwcmVjYXRlZCBEbyBub3QgdXNlIHRoaXMgbWV0aG9kLiBJdCB3aWxsIGJlIHJlbW92ZWQgaW4gdGhlIG5leHQgbWFqb3IgdmVyc2lvbi5cbiAgICovXG4gIHRvSlNPTigpIHtcbiAgICByZXR1cm4ge1xuICAgICAgbmFtZTogdGhpcy5uYW1lLFxuICAgICAgbWVzc2FnZTogdGhpcy5tZXNzYWdlLFxuICAgICAgc3RhY2s6IHRoaXMuc3RhY2ssXG4gICAgICBpZDogdGhpcy5pZFxuICAgIH07XG4gIH1cbn07XG5fYTkgPSBzeW1ib2w5O1xuXG4vLyBjb3JlL3JlZ2lzdHJ5L25vLXN1Y2gtbW9kZWwtZXJyb3IudHNcbmltcG9ydCB7IEFJU0RLRXJyb3IgYXMgQUlTREtFcnJvcjEwIH0gZnJvbSBcIkBhaS1zZGsvcHJvdmlkZXJcIjtcbnZhciBuYW1lMTAgPSBcIkFJX05vU3VjaE1vZGVsRXJyb3JcIjtcbnZhciBtYXJrZXIxMCA9IGB2ZXJjZWwuYWkuZXJyb3IuJHtuYW1lMTB9YDtcbnZhciBzeW1ib2wxMCA9IFN5bWJvbC5mb3IobWFya2VyMTApO1xudmFyIF9hMTA7XG52YXIgTm9TdWNoTW9kZWxFcnJvciA9IGNsYXNzIGV4dGVuZHMgQUlTREtFcnJvcjEwIHtcbiAgY29uc3RydWN0b3Ioe1xuICAgIG1vZGVsSWQsXG4gICAgbW9kZWxUeXBlLFxuICAgIG1lc3NhZ2UgPSBgTm8gc3VjaCAke21vZGVsVHlwZX06ICR7bW9kZWxJZH1gXG4gIH0pIHtcbiAgICBzdXBlcih7IG5hbWU6IG5hbWUxMCwgbWVzc2FnZSB9KTtcbiAgICB0aGlzW19hMTBdID0gdHJ1ZTtcbiAgICB0aGlzLm1vZGVsSWQgPSBtb2RlbElkO1xuICAgIHRoaXMubW9kZWxUeXBlID0gbW9kZWxUeXBlO1xuICB9XG4gIHN0YXRpYyBpc0luc3RhbmNlKGVycm9yKSB7XG4gICAgcmV0dXJuIEFJU0RLRXJyb3IxMC5oYXNNYXJrZXIoZXJyb3IsIG1hcmtlcjEwKTtcbiAgfVxuICAvKipcbiAgICogQGRlcHJlY2F0ZWQgdXNlIGBpc0luc3RhbmNlYCBpbnN0ZWFkXG4gICAqL1xuICBzdGF0aWMgaXNOb1N1Y2hNb2RlbEVycm9yKGVycm9yKSB7XG4gICAgcmV0dXJuIGVycm9yIGluc3RhbmNlb2YgRXJyb3IgJiYgZXJyb3IubmFtZSA9PT0gbmFtZTEwICYmIHR5cGVvZiBlcnJvci5tb2RlbElkID09PSBcInN0cmluZ1wiICYmIHR5cGVvZiBlcnJvci5tb2RlbFR5cGUgPT09IFwic3RyaW5nXCI7XG4gIH1cbiAgLyoqXG4gICAqIEBkZXByZWNhdGVkIERvIG5vdCB1c2UgdGhpcyBtZXRob2QuIEl0IHdpbGwgYmUgcmVtb3ZlZCBpbiB0aGUgbmV4dCBtYWpvciB2ZXJzaW9uLlxuICAgKi9cbiAgdG9KU09OKCkge1xuICAgIHJldHVybiB7XG4gICAgICBuYW1lOiB0aGlzLm5hbWUsXG4gICAgICBtZXNzYWdlOiB0aGlzLm1lc3NhZ2UsXG4gICAgICBzdGFjazogdGhpcy5zdGFjayxcbiAgICAgIG1vZGVsSWQ6IHRoaXMubW9kZWxJZCxcbiAgICAgIG1vZGVsVHlwZTogdGhpcy5tb2RlbFR5cGVcbiAgICB9O1xuICB9XG59O1xuX2ExMCA9IHN5bWJvbDEwO1xuXG4vLyBjb3JlL3JlZ2lzdHJ5L25vLXN1Y2gtcHJvdmlkZXItZXJyb3IudHNcbmltcG9ydCB7IEFJU0RLRXJyb3IgYXMgQUlTREtFcnJvcjExIH0gZnJvbSBcIkBhaS1zZGsvcHJvdmlkZXJcIjtcbnZhciBuYW1lMTEgPSBcIkFJX05vU3VjaFByb3ZpZGVyRXJyb3JcIjtcbnZhciBtYXJrZXIxMSA9IGB2ZXJjZWwuYWkuZXJyb3IuJHtuYW1lMTF9YDtcbnZhciBzeW1ib2wxMSA9IFN5bWJvbC5mb3IobWFya2VyMTEpO1xudmFyIF9hMTE7XG52YXIgTm9TdWNoUHJvdmlkZXJFcnJvciA9IGNsYXNzIGV4dGVuZHMgQUlTREtFcnJvcjExIHtcbiAgY29uc3RydWN0b3Ioe1xuICAgIHByb3ZpZGVySWQsXG4gICAgYXZhaWxhYmxlUHJvdmlkZXJzLFxuICAgIG1lc3NhZ2UgPSBgTm8gc3VjaCBwcm92aWRlcjogJHtwcm92aWRlcklkfSAoYXZhaWxhYmxlIHByb3ZpZGVyczogJHthdmFpbGFibGVQcm92aWRlcnMuam9pbigpfSlgXG4gIH0pIHtcbiAgICBzdXBlcih7IG5hbWU6IG5hbWUxMSwgbWVzc2FnZSB9KTtcbiAgICB0aGlzW19hMTFdID0gdHJ1ZTtcbiAgICB0aGlzLnByb3ZpZGVySWQgPSBwcm92aWRlcklkO1xuICAgIHRoaXMuYXZhaWxhYmxlUHJvdmlkZXJzID0gYXZhaWxhYmxlUHJvdmlkZXJzO1xuICB9XG4gIHN0YXRpYyBpc0luc3RhbmNlKGVycm9yKSB7XG4gICAgcmV0dXJuIEFJU0RLRXJyb3IxMS5oYXNNYXJrZXIoZXJyb3IsIG1hcmtlcjExKTtcbiAgfVxuICAvKipcbiAgICogQGRlcHJlY2F0ZWQgdXNlIGBpc0luc3RhbmNlYCBpbnN0ZWFkXG4gICAqL1xuICBzdGF0aWMgaXNOb1N1Y2hQcm92aWRlckVycm9yKGVycm9yKSB7XG4gICAgcmV0dXJuIGVycm9yIGluc3RhbmNlb2YgRXJyb3IgJiYgZXJyb3IubmFtZSA9PT0gbmFtZTExICYmIHR5cGVvZiBlcnJvci5wcm92aWRlcklkID09PSBcInN0cmluZ1wiICYmIEFycmF5LmlzQXJyYXkoZXJyb3IuYXZhaWxhYmxlUHJvdmlkZXJzKTtcbiAgfVxuICAvKipcbiAgICogQGRlcHJlY2F0ZWQgRG8gbm90IHVzZSB0aGlzIG1ldGhvZC4gSXQgd2lsbCBiZSByZW1vdmVkIGluIHRoZSBuZXh0IG1ham9yIHZlcnNpb24uXG4gICAqL1xuICB0b0pTT04oKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIG5hbWU6IHRoaXMubmFtZSxcbiAgICAgIG1lc3NhZ2U6IHRoaXMubWVzc2FnZSxcbiAgICAgIHN0YWNrOiB0aGlzLnN0YWNrLFxuICAgICAgcHJvdmlkZXJJZDogdGhpcy5wcm92aWRlcklkLFxuICAgICAgYXZhaWxhYmxlUHJvdmlkZXJzOiB0aGlzLmF2YWlsYWJsZVByb3ZpZGVyc1xuICAgIH07XG4gIH1cbn07XG5fYTExID0gc3ltYm9sMTE7XG5cbi8vIGNvcmUvcmVnaXN0cnkvcHJvdmlkZXItcmVnaXN0cnkudHNcbmZ1bmN0aW9uIGV4cGVyaW1lbnRhbF9jcmVhdGVQcm92aWRlclJlZ2lzdHJ5KHByb3ZpZGVycykge1xuICBjb25zdCByZWdpc3RyeSA9IG5ldyBEZWZhdWx0UHJvdmlkZXJSZWdpc3RyeSgpO1xuICBmb3IgKGNvbnN0IFtpZCwgcHJvdmlkZXJdIG9mIE9iamVjdC5lbnRyaWVzKHByb3ZpZGVycykpIHtcbiAgICByZWdpc3RyeS5yZWdpc3RlclByb3ZpZGVyKHsgaWQsIHByb3ZpZGVyIH0pO1xuICB9XG4gIHJldHVybiByZWdpc3RyeTtcbn1cbnZhciBleHBlcmltZW50YWxfY3JlYXRlTW9kZWxSZWdpc3RyeSA9IGV4cGVyaW1lbnRhbF9jcmVhdGVQcm92aWRlclJlZ2lzdHJ5O1xudmFyIERlZmF1bHRQcm92aWRlclJlZ2lzdHJ5ID0gY2xhc3Mge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICB0aGlzLnByb3ZpZGVycyA9IHt9O1xuICB9XG4gIHJlZ2lzdGVyUHJvdmlkZXIoe1xuICAgIGlkLFxuICAgIHByb3ZpZGVyXG4gIH0pIHtcbiAgICB0aGlzLnByb3ZpZGVyc1tpZF0gPSBwcm92aWRlcjtcbiAgfVxuICBnZXRQcm92aWRlcihpZCkge1xuICAgIGNvbnN0IHByb3ZpZGVyID0gdGhpcy5wcm92aWRlcnNbaWRdO1xuICAgIGlmIChwcm92aWRlciA9PSBudWxsKSB7XG4gICAgICB0aHJvdyBuZXcgTm9TdWNoUHJvdmlkZXJFcnJvcih7XG4gICAgICAgIHByb3ZpZGVySWQ6IGlkLFxuICAgICAgICBhdmFpbGFibGVQcm92aWRlcnM6IE9iamVjdC5rZXlzKHRoaXMucHJvdmlkZXJzKVxuICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiBwcm92aWRlcjtcbiAgfVxuICBzcGxpdElkKGlkKSB7XG4gICAgY29uc3QgaW5kZXggPSBpZC5pbmRleE9mKFwiOlwiKTtcbiAgICBpZiAoaW5kZXggPT09IC0xKSB7XG4gICAgICB0aHJvdyBuZXcgSW52YWxpZE1vZGVsSWRFcnJvcih7IGlkIH0pO1xuICAgIH1cbiAgICByZXR1cm4gW2lkLnNsaWNlKDAsIGluZGV4KSwgaWQuc2xpY2UoaW5kZXggKyAxKV07XG4gIH1cbiAgbGFuZ3VhZ2VNb2RlbChpZCkge1xuICAgIHZhciBfYTEyLCBfYjtcbiAgICBjb25zdCBbcHJvdmlkZXJJZCwgbW9kZWxJZF0gPSB0aGlzLnNwbGl0SWQoaWQpO1xuICAgIGNvbnN0IG1vZGVsID0gKF9iID0gKF9hMTIgPSB0aGlzLmdldFByb3ZpZGVyKHByb3ZpZGVySWQpKS5sYW5ndWFnZU1vZGVsKSA9PSBudWxsID8gdm9pZCAwIDogX2IuY2FsbChfYTEyLCBtb2RlbElkKTtcbiAgICBpZiAobW9kZWwgPT0gbnVsbCkge1xuICAgICAgdGhyb3cgbmV3IE5vU3VjaE1vZGVsRXJyb3IoeyBtb2RlbElkOiBpZCwgbW9kZWxUeXBlOiBcImxhbmd1YWdlTW9kZWxcIiB9KTtcbiAgICB9XG4gICAgcmV0dXJuIG1vZGVsO1xuICB9XG4gIHRleHRFbWJlZGRpbmdNb2RlbChpZCkge1xuICAgIHZhciBfYTEyLCBfYiwgX2M7XG4gICAgY29uc3QgW3Byb3ZpZGVySWQsIG1vZGVsSWRdID0gdGhpcy5zcGxpdElkKGlkKTtcbiAgICBjb25zdCBwcm92aWRlciA9IHRoaXMuZ2V0UHJvdmlkZXIocHJvdmlkZXJJZCk7XG4gICAgY29uc3QgbW9kZWwgPSAoX2MgPSAoX2ExMiA9IHByb3ZpZGVyLnRleHRFbWJlZGRpbmdNb2RlbCkgPT0gbnVsbCA/IHZvaWQgMCA6IF9hMTIuY2FsbChwcm92aWRlciwgbW9kZWxJZCkpICE9IG51bGwgPyBfYyA6IChfYiA9IHByb3ZpZGVyLnRleHRFbWJlZGRpbmcpID09IG51bGwgPyB2b2lkIDAgOiBfYi5jYWxsKHByb3ZpZGVyLCBtb2RlbElkKTtcbiAgICBpZiAobW9kZWwgPT0gbnVsbCkge1xuICAgICAgdGhyb3cgbmV3IE5vU3VjaE1vZGVsRXJyb3Ioe1xuICAgICAgICBtb2RlbElkOiBpZCxcbiAgICAgICAgbW9kZWxUeXBlOiBcInRleHRFbWJlZGRpbmdNb2RlbFwiXG4gICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIG1vZGVsO1xuICB9XG4gIC8qKlxuICAgKiBAZGVwcmVjYXRlZCBVc2UgYHRleHRFbWJlZGRpbmdNb2RlbGAgaW5zdGVhZC5cbiAgICovXG4gIHRleHRFbWJlZGRpbmcoaWQpIHtcbiAgICByZXR1cm4gdGhpcy50ZXh0RW1iZWRkaW5nTW9kZWwoaWQpO1xuICB9XG59O1xuXG4vLyBjb3JlL3Rvb2wvdG9vbC50c1xuZnVuY3Rpb24gdG9vbCh0b29sMikge1xuICByZXR1cm4gdG9vbDI7XG59XG5cbi8vIGNvcmUvdXRpbC9jb3NpbmUtc2ltaWxhcml0eS50c1xuZnVuY3Rpb24gY29zaW5lU2ltaWxhcml0eSh2ZWN0b3IxLCB2ZWN0b3IyKSB7XG4gIGlmICh2ZWN0b3IxLmxlbmd0aCAhPT0gdmVjdG9yMi5sZW5ndGgpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICBgVmVjdG9ycyBtdXN0IGhhdmUgdGhlIHNhbWUgbGVuZ3RoICh2ZWN0b3IxOiAke3ZlY3RvcjEubGVuZ3RofSBlbGVtZW50cywgdmVjdG9yMjogJHt2ZWN0b3IyLmxlbmd0aH0gZWxlbWVudHMpYFxuICAgICk7XG4gIH1cbiAgcmV0dXJuIGRvdFByb2R1Y3QodmVjdG9yMSwgdmVjdG9yMikgLyAobWFnbml0dWRlKHZlY3RvcjEpICogbWFnbml0dWRlKHZlY3RvcjIpKTtcbn1cbmZ1bmN0aW9uIGRvdFByb2R1Y3QodmVjdG9yMSwgdmVjdG9yMikge1xuICByZXR1cm4gdmVjdG9yMS5yZWR1Y2UoXG4gICAgKGFjY3VtdWxhdG9yLCB2YWx1ZSwgaW5kZXgpID0+IGFjY3VtdWxhdG9yICsgdmFsdWUgKiB2ZWN0b3IyW2luZGV4XSxcbiAgICAwXG4gICk7XG59XG5mdW5jdGlvbiBtYWduaXR1ZGUodmVjdG9yKSB7XG4gIHJldHVybiBNYXRoLnNxcnQoZG90UHJvZHVjdCh2ZWN0b3IsIHZlY3RvcikpO1xufVxuXG4vLyBlcnJvcnMvaW5kZXgudHNcbmltcG9ydCB7XG4gIEFJU0RLRXJyb3IgYXMgQUlTREtFcnJvcjEyLFxuICBBUElDYWxsRXJyb3IgYXMgQVBJQ2FsbEVycm9yMixcbiAgRW1wdHlSZXNwb25zZUJvZHlFcnJvcixcbiAgSW52YWxpZFByb21wdEVycm9yIGFzIEludmFsaWRQcm9tcHRFcnJvcjIsXG4gIEludmFsaWRSZXNwb25zZURhdGFFcnJvcixcbiAgSlNPTlBhcnNlRXJyb3IsXG4gIExvYWRBUElLZXlFcnJvcixcbiAgVHlwZVZhbGlkYXRpb25FcnJvcixcbiAgVW5zdXBwb3J0ZWRGdW5jdGlvbmFsaXR5RXJyb3Jcbn0gZnJvbSBcIkBhaS1zZGsvcHJvdmlkZXJcIjtcblxuLy8gc3RyZWFtcy9haS1zdHJlYW0udHNcbmltcG9ydCB7XG4gIGNyZWF0ZVBhcnNlclxufSBmcm9tIFwiZXZlbnRzb3VyY2UtcGFyc2VyXCI7XG5mdW5jdGlvbiBjcmVhdGVFdmVudFN0cmVhbVRyYW5zZm9ybWVyKGN1c3RvbVBhcnNlcikge1xuICBjb25zdCB0ZXh0RGVjb2RlciA9IG5ldyBUZXh0RGVjb2RlcigpO1xuICBsZXQgZXZlbnRTb3VyY2VQYXJzZXI7XG4gIHJldHVybiBuZXcgVHJhbnNmb3JtU3RyZWFtKHtcbiAgICBhc3luYyBzdGFydChjb250cm9sbGVyKSB7XG4gICAgICBldmVudFNvdXJjZVBhcnNlciA9IGNyZWF0ZVBhcnNlcihcbiAgICAgICAgKGV2ZW50KSA9PiB7XG4gICAgICAgICAgaWYgKFwiZGF0YVwiIGluIGV2ZW50ICYmIGV2ZW50LnR5cGUgPT09IFwiZXZlbnRcIiAmJiBldmVudC5kYXRhID09PSBcIltET05FXVwiIHx8IC8vIFJlcGxpY2F0ZSBkb2Vzbid0IHNlbmQgW0RPTkVdIGJ1dCBkb2VzIHNlbmQgYSAnZG9uZScgZXZlbnRcbiAgICAgICAgICAvLyBAc2VlIGh0dHBzOi8vcmVwbGljYXRlLmNvbS9kb2NzL3N0cmVhbWluZ1xuICAgICAgICAgIGV2ZW50LmV2ZW50ID09PSBcImRvbmVcIikge1xuICAgICAgICAgICAgY29udHJvbGxlci50ZXJtaW5hdGUoKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKFwiZGF0YVwiIGluIGV2ZW50KSB7XG4gICAgICAgICAgICBjb25zdCBwYXJzZWRNZXNzYWdlID0gY3VzdG9tUGFyc2VyID8gY3VzdG9tUGFyc2VyKGV2ZW50LmRhdGEsIHtcbiAgICAgICAgICAgICAgZXZlbnQ6IGV2ZW50LmV2ZW50XG4gICAgICAgICAgICB9KSA6IGV2ZW50LmRhdGE7XG4gICAgICAgICAgICBpZiAocGFyc2VkTWVzc2FnZSlcbiAgICAgICAgICAgICAgY29udHJvbGxlci5lbnF1ZXVlKHBhcnNlZE1lc3NhZ2UpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgKTtcbiAgICB9LFxuICAgIHRyYW5zZm9ybShjaHVuaykge1xuICAgICAgZXZlbnRTb3VyY2VQYXJzZXIuZmVlZCh0ZXh0RGVjb2Rlci5kZWNvZGUoY2h1bmspKTtcbiAgICB9XG4gIH0pO1xufVxuZnVuY3Rpb24gY3JlYXRlQ2FsbGJhY2tzVHJhbnNmb3JtZXIoY2IpIHtcbiAgY29uc3QgdGV4dEVuY29kZXIgPSBuZXcgVGV4dEVuY29kZXIoKTtcbiAgbGV0IGFnZ3JlZ2F0ZWRSZXNwb25zZSA9IFwiXCI7XG4gIGNvbnN0IGNhbGxiYWNrcyA9IGNiIHx8IHt9O1xuICByZXR1cm4gbmV3IFRyYW5zZm9ybVN0cmVhbSh7XG4gICAgYXN5bmMgc3RhcnQoKSB7XG4gICAgICBpZiAoY2FsbGJhY2tzLm9uU3RhcnQpXG4gICAgICAgIGF3YWl0IGNhbGxiYWNrcy5vblN0YXJ0KCk7XG4gICAgfSxcbiAgICBhc3luYyB0cmFuc2Zvcm0obWVzc2FnZSwgY29udHJvbGxlcikge1xuICAgICAgY29uc3QgY29udGVudCA9IHR5cGVvZiBtZXNzYWdlID09PSBcInN0cmluZ1wiID8gbWVzc2FnZSA6IG1lc3NhZ2UuY29udGVudDtcbiAgICAgIGNvbnRyb2xsZXIuZW5xdWV1ZSh0ZXh0RW5jb2Rlci5lbmNvZGUoY29udGVudCkpO1xuICAgICAgYWdncmVnYXRlZFJlc3BvbnNlICs9IGNvbnRlbnQ7XG4gICAgICBpZiAoY2FsbGJhY2tzLm9uVG9rZW4pXG4gICAgICAgIGF3YWl0IGNhbGxiYWNrcy5vblRva2VuKGNvbnRlbnQpO1xuICAgICAgaWYgKGNhbGxiYWNrcy5vblRleHQgJiYgdHlwZW9mIG1lc3NhZ2UgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgYXdhaXQgY2FsbGJhY2tzLm9uVGV4dChtZXNzYWdlKTtcbiAgICAgIH1cbiAgICB9LFxuICAgIGFzeW5jIGZsdXNoKCkge1xuICAgICAgY29uc3QgaXNPcGVuQUlDYWxsYmFja3MgPSBpc09mVHlwZU9wZW5BSVN0cmVhbUNhbGxiYWNrcyhjYWxsYmFja3MpO1xuICAgICAgaWYgKGNhbGxiYWNrcy5vbkNvbXBsZXRpb24pIHtcbiAgICAgICAgYXdhaXQgY2FsbGJhY2tzLm9uQ29tcGxldGlvbihhZ2dyZWdhdGVkUmVzcG9uc2UpO1xuICAgICAgfVxuICAgICAgaWYgKGNhbGxiYWNrcy5vbkZpbmFsICYmICFpc09wZW5BSUNhbGxiYWNrcykge1xuICAgICAgICBhd2FpdCBjYWxsYmFja3Mub25GaW5hbChhZ2dyZWdhdGVkUmVzcG9uc2UpO1xuICAgICAgfVxuICAgIH1cbiAgfSk7XG59XG5mdW5jdGlvbiBpc09mVHlwZU9wZW5BSVN0cmVhbUNhbGxiYWNrcyhjYWxsYmFja3MpIHtcbiAgcmV0dXJuIFwiZXhwZXJpbWVudGFsX29uRnVuY3Rpb25DYWxsXCIgaW4gY2FsbGJhY2tzO1xufVxuZnVuY3Rpb24gdHJpbVN0YXJ0T2ZTdHJlYW1IZWxwZXIoKSB7XG4gIGxldCBpc1N0cmVhbVN0YXJ0ID0gdHJ1ZTtcbiAgcmV0dXJuICh0ZXh0KSA9PiB7XG4gICAgaWYgKGlzU3RyZWFtU3RhcnQpIHtcbiAgICAgIHRleHQgPSB0ZXh0LnRyaW1TdGFydCgpO1xuICAgICAgaWYgKHRleHQpXG4gICAgICAgIGlzU3RyZWFtU3RhcnQgPSBmYWxzZTtcbiAgICB9XG4gICAgcmV0dXJuIHRleHQ7XG4gIH07XG59XG5mdW5jdGlvbiBBSVN0cmVhbShyZXNwb25zZSwgY3VzdG9tUGFyc2VyLCBjYWxsYmFja3MpIHtcbiAgaWYgKCFyZXNwb25zZS5vaykge1xuICAgIGlmIChyZXNwb25zZS5ib2R5KSB7XG4gICAgICBjb25zdCByZWFkZXIgPSByZXNwb25zZS5ib2R5LmdldFJlYWRlcigpO1xuICAgICAgcmV0dXJuIG5ldyBSZWFkYWJsZVN0cmVhbSh7XG4gICAgICAgIGFzeW5jIHN0YXJ0KGNvbnRyb2xsZXIpIHtcbiAgICAgICAgICBjb25zdCB7IGRvbmUsIHZhbHVlIH0gPSBhd2FpdCByZWFkZXIucmVhZCgpO1xuICAgICAgICAgIGlmICghZG9uZSkge1xuICAgICAgICAgICAgY29uc3QgZXJyb3JUZXh0ID0gbmV3IFRleHREZWNvZGVyKCkuZGVjb2RlKHZhbHVlKTtcbiAgICAgICAgICAgIGNvbnRyb2xsZXIuZXJyb3IobmV3IEVycm9yKGBSZXNwb25zZSBlcnJvcjogJHtlcnJvclRleHR9YCkpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBuZXcgUmVhZGFibGVTdHJlYW0oe1xuICAgICAgICBzdGFydChjb250cm9sbGVyKSB7XG4gICAgICAgICAgY29udHJvbGxlci5lcnJvcihuZXcgRXJyb3IoXCJSZXNwb25zZSBlcnJvcjogTm8gcmVzcG9uc2UgYm9keVwiKSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuICBjb25zdCByZXNwb25zZUJvZHlTdHJlYW0gPSByZXNwb25zZS5ib2R5IHx8IGNyZWF0ZUVtcHR5UmVhZGFibGVTdHJlYW0oKTtcbiAgcmV0dXJuIHJlc3BvbnNlQm9keVN0cmVhbS5waXBlVGhyb3VnaChjcmVhdGVFdmVudFN0cmVhbVRyYW5zZm9ybWVyKGN1c3RvbVBhcnNlcikpLnBpcGVUaHJvdWdoKGNyZWF0ZUNhbGxiYWNrc1RyYW5zZm9ybWVyKGNhbGxiYWNrcykpO1xufVxuZnVuY3Rpb24gY3JlYXRlRW1wdHlSZWFkYWJsZVN0cmVhbSgpIHtcbiAgcmV0dXJuIG5ldyBSZWFkYWJsZVN0cmVhbSh7XG4gICAgc3RhcnQoY29udHJvbGxlcikge1xuICAgICAgY29udHJvbGxlci5jbG9zZSgpO1xuICAgIH1cbiAgfSk7XG59XG5mdW5jdGlvbiByZWFkYWJsZUZyb21Bc3luY0l0ZXJhYmxlKGl0ZXJhYmxlKSB7XG4gIGxldCBpdCA9IGl0ZXJhYmxlW1N5bWJvbC5hc3luY0l0ZXJhdG9yXSgpO1xuICByZXR1cm4gbmV3IFJlYWRhYmxlU3RyZWFtKHtcbiAgICBhc3luYyBwdWxsKGNvbnRyb2xsZXIpIHtcbiAgICAgIGNvbnN0IHsgZG9uZSwgdmFsdWUgfSA9IGF3YWl0IGl0Lm5leHQoKTtcbiAgICAgIGlmIChkb25lKVxuICAgICAgICBjb250cm9sbGVyLmNsb3NlKCk7XG4gICAgICBlbHNlXG4gICAgICAgIGNvbnRyb2xsZXIuZW5xdWV1ZSh2YWx1ZSk7XG4gICAgfSxcbiAgICBhc3luYyBjYW5jZWwocmVhc29uKSB7XG4gICAgICB2YXIgX2ExMjtcbiAgICAgIGF3YWl0ICgoX2ExMiA9IGl0LnJldHVybikgPT0gbnVsbCA/IHZvaWQgMCA6IF9hMTIuY2FsbChpdCwgcmVhc29uKSk7XG4gICAgfVxuICB9KTtcbn1cblxuLy8gc3RyZWFtcy9zdHJlYW0tZGF0YS50c1xuaW1wb3J0IHsgZm9ybWF0U3RyZWFtUGFydCBhcyBmb3JtYXRTdHJlYW1QYXJ0MiB9IGZyb20gXCJAYWktc2RrL3VpLXV0aWxzXCI7XG5cbi8vIHV0aWwvY29uc3RhbnRzLnRzXG52YXIgSEFOR0lOR19TVFJFQU1fV0FSTklOR19USU1FX01TID0gMTUgKiAxZTM7XG5cbi8vIHN0cmVhbXMvc3RyZWFtLWRhdGEudHNcbnZhciBTdHJlYW1EYXRhMiA9IGNsYXNzIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgdGhpcy5lbmNvZGVyID0gbmV3IFRleHRFbmNvZGVyKCk7XG4gICAgdGhpcy5jb250cm9sbGVyID0gbnVsbDtcbiAgICB0aGlzLmlzQ2xvc2VkID0gZmFsc2U7XG4gICAgdGhpcy53YXJuaW5nVGltZW91dCA9IG51bGw7XG4gICAgY29uc3Qgc2VsZiA9IHRoaXM7XG4gICAgdGhpcy5zdHJlYW0gPSBuZXcgUmVhZGFibGVTdHJlYW0oe1xuICAgICAgc3RhcnQ6IGFzeW5jIChjb250cm9sbGVyKSA9PiB7XG4gICAgICAgIHNlbGYuY29udHJvbGxlciA9IGNvbnRyb2xsZXI7XG4gICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gXCJkZXZlbG9wbWVudFwiKSB7XG4gICAgICAgICAgc2VsZi53YXJuaW5nVGltZW91dCA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgY29uc29sZS53YXJuKFxuICAgICAgICAgICAgICBcIlRoZSBkYXRhIHN0cmVhbSBpcyBoYW5naW5nLiBEaWQgeW91IGZvcmdldCB0byBjbG9zZSBpdCB3aXRoIGBkYXRhLmNsb3NlKClgP1wiXG4gICAgICAgICAgICApO1xuICAgICAgICAgIH0sIEhBTkdJTkdfU1RSRUFNX1dBUk5JTkdfVElNRV9NUyk7XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBwdWxsOiAoY29udHJvbGxlcikgPT4ge1xuICAgICAgfSxcbiAgICAgIGNhbmNlbDogKHJlYXNvbikgPT4ge1xuICAgICAgICB0aGlzLmlzQ2xvc2VkID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuICBhc3luYyBjbG9zZSgpIHtcbiAgICBpZiAodGhpcy5pc0Nsb3NlZCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRGF0YSBTdHJlYW0gaGFzIGFscmVhZHkgYmVlbiBjbG9zZWQuXCIpO1xuICAgIH1cbiAgICBpZiAoIXRoaXMuY29udHJvbGxlcikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiU3RyZWFtIGNvbnRyb2xsZXIgaXMgbm90IGluaXRpYWxpemVkLlwiKTtcbiAgICB9XG4gICAgdGhpcy5jb250cm9sbGVyLmNsb3NlKCk7XG4gICAgdGhpcy5pc0Nsb3NlZCA9IHRydWU7XG4gICAgaWYgKHRoaXMud2FybmluZ1RpbWVvdXQpIHtcbiAgICAgIGNsZWFyVGltZW91dCh0aGlzLndhcm5pbmdUaW1lb3V0KTtcbiAgICB9XG4gIH1cbiAgYXBwZW5kKHZhbHVlKSB7XG4gICAgaWYgKHRoaXMuaXNDbG9zZWQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkRhdGEgU3RyZWFtIGhhcyBhbHJlYWR5IGJlZW4gY2xvc2VkLlwiKTtcbiAgICB9XG4gICAgaWYgKCF0aGlzLmNvbnRyb2xsZXIpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIlN0cmVhbSBjb250cm9sbGVyIGlzIG5vdCBpbml0aWFsaXplZC5cIik7XG4gICAgfVxuICAgIHRoaXMuY29udHJvbGxlci5lbnF1ZXVlKFxuICAgICAgdGhpcy5lbmNvZGVyLmVuY29kZShmb3JtYXRTdHJlYW1QYXJ0MihcImRhdGFcIiwgW3ZhbHVlXSkpXG4gICAgKTtcbiAgfVxuICBhcHBlbmRNZXNzYWdlQW5ub3RhdGlvbih2YWx1ZSkge1xuICAgIGlmICh0aGlzLmlzQ2xvc2VkKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJEYXRhIFN0cmVhbSBoYXMgYWxyZWFkeSBiZWVuIGNsb3NlZC5cIik7XG4gICAgfVxuICAgIGlmICghdGhpcy5jb250cm9sbGVyKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJTdHJlYW0gY29udHJvbGxlciBpcyBub3QgaW5pdGlhbGl6ZWQuXCIpO1xuICAgIH1cbiAgICB0aGlzLmNvbnRyb2xsZXIuZW5xdWV1ZShcbiAgICAgIHRoaXMuZW5jb2Rlci5lbmNvZGUoZm9ybWF0U3RyZWFtUGFydDIoXCJtZXNzYWdlX2Fubm90YXRpb25zXCIsIFt2YWx1ZV0pKVxuICAgICk7XG4gIH1cbn07XG5mdW5jdGlvbiBjcmVhdGVTdHJlYW1EYXRhVHJhbnNmb3JtZXIoKSB7XG4gIGNvbnN0IGVuY29kZXIgPSBuZXcgVGV4dEVuY29kZXIoKTtcbiAgY29uc3QgZGVjb2RlciA9IG5ldyBUZXh0RGVjb2RlcigpO1xuICByZXR1cm4gbmV3IFRyYW5zZm9ybVN0cmVhbSh7XG4gICAgdHJhbnNmb3JtOiBhc3luYyAoY2h1bmssIGNvbnRyb2xsZXIpID0+IHtcbiAgICAgIGNvbnN0IG1lc3NhZ2UgPSBkZWNvZGVyLmRlY29kZShjaHVuayk7XG4gICAgICBjb250cm9sbGVyLmVucXVldWUoZW5jb2Rlci5lbmNvZGUoZm9ybWF0U3RyZWFtUGFydDIoXCJ0ZXh0XCIsIG1lc3NhZ2UpKSk7XG4gICAgfVxuICB9KTtcbn1cbnZhciBleHBlcmltZW50YWxfU3RyZWFtRGF0YSA9IGNsYXNzIGV4dGVuZHMgU3RyZWFtRGF0YTIge1xufTtcblxuLy8gc3RyZWFtcy9hbnRocm9waWMtc3RyZWFtLnRzXG5mdW5jdGlvbiBwYXJzZUFudGhyb3BpY1N0cmVhbSgpIHtcbiAgbGV0IHByZXZpb3VzID0gXCJcIjtcbiAgcmV0dXJuIChkYXRhKSA9PiB7XG4gICAgY29uc3QganNvbiA9IEpTT04ucGFyc2UoZGF0YSk7XG4gICAgaWYgKFwiZXJyb3JcIiBpbiBqc29uKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYCR7anNvbi5lcnJvci50eXBlfTogJHtqc29uLmVycm9yLm1lc3NhZ2V9YCk7XG4gICAgfVxuICAgIGlmICghKFwiY29tcGxldGlvblwiIGluIGpzb24pKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IHRleHQgPSBqc29uLmNvbXBsZXRpb247XG4gICAgaWYgKCFwcmV2aW91cyB8fCB0ZXh0Lmxlbmd0aCA+IHByZXZpb3VzLmxlbmd0aCAmJiB0ZXh0LnN0YXJ0c1dpdGgocHJldmlvdXMpKSB7XG4gICAgICBjb25zdCBkZWx0YSA9IHRleHQuc2xpY2UocHJldmlvdXMubGVuZ3RoKTtcbiAgICAgIHByZXZpb3VzID0gdGV4dDtcbiAgICAgIHJldHVybiBkZWx0YTtcbiAgICB9XG4gICAgcmV0dXJuIHRleHQ7XG4gIH07XG59XG5hc3luYyBmdW5jdGlvbiogc3RyZWFtYWJsZShzdHJlYW0pIHtcbiAgZm9yIGF3YWl0IChjb25zdCBjaHVuayBvZiBzdHJlYW0pIHtcbiAgICBpZiAoXCJjb21wbGV0aW9uXCIgaW4gY2h1bmspIHtcbiAgICAgIGNvbnN0IHRleHQgPSBjaHVuay5jb21wbGV0aW9uO1xuICAgICAgaWYgKHRleHQpXG4gICAgICAgIHlpZWxkIHRleHQ7XG4gICAgfSBlbHNlIGlmIChcImRlbHRhXCIgaW4gY2h1bmspIHtcbiAgICAgIGNvbnN0IHsgZGVsdGEgfSA9IGNodW5rO1xuICAgICAgaWYgKFwidGV4dFwiIGluIGRlbHRhKSB7XG4gICAgICAgIGNvbnN0IHRleHQgPSBkZWx0YS50ZXh0O1xuICAgICAgICBpZiAodGV4dClcbiAgICAgICAgICB5aWVsZCB0ZXh0O1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuZnVuY3Rpb24gQW50aHJvcGljU3RyZWFtKHJlcywgY2IpIHtcbiAgaWYgKFN5bWJvbC5hc3luY0l0ZXJhdG9yIGluIHJlcykge1xuICAgIHJldHVybiByZWFkYWJsZUZyb21Bc3luY0l0ZXJhYmxlKHN0cmVhbWFibGUocmVzKSkucGlwZVRocm91Z2goY3JlYXRlQ2FsbGJhY2tzVHJhbnNmb3JtZXIoY2IpKS5waXBlVGhyb3VnaChjcmVhdGVTdHJlYW1EYXRhVHJhbnNmb3JtZXIoKSk7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIEFJU3RyZWFtKHJlcywgcGFyc2VBbnRocm9waWNTdHJlYW0oKSwgY2IpLnBpcGVUaHJvdWdoKFxuICAgICAgY3JlYXRlU3RyZWFtRGF0YVRyYW5zZm9ybWVyKClcbiAgICApO1xuICB9XG59XG5cbi8vIHN0cmVhbXMvYXNzaXN0YW50LXJlc3BvbnNlLnRzXG5pbXBvcnQge1xuICBmb3JtYXRTdHJlYW1QYXJ0IGFzIGZvcm1hdFN0cmVhbVBhcnQzXG59IGZyb20gXCJAYWktc2RrL3VpLXV0aWxzXCI7XG5mdW5jdGlvbiBBc3Npc3RhbnRSZXNwb25zZSh7IHRocmVhZElkLCBtZXNzYWdlSWQgfSwgcHJvY2VzczIpIHtcbiAgY29uc3Qgc3RyZWFtID0gbmV3IFJlYWRhYmxlU3RyZWFtKHtcbiAgICBhc3luYyBzdGFydChjb250cm9sbGVyKSB7XG4gICAgICB2YXIgX2ExMjtcbiAgICAgIGNvbnN0IHRleHRFbmNvZGVyID0gbmV3IFRleHRFbmNvZGVyKCk7XG4gICAgICBjb25zdCBzZW5kTWVzc2FnZSA9IChtZXNzYWdlKSA9PiB7XG4gICAgICAgIGNvbnRyb2xsZXIuZW5xdWV1ZShcbiAgICAgICAgICB0ZXh0RW5jb2Rlci5lbmNvZGUoZm9ybWF0U3RyZWFtUGFydDMoXCJhc3Npc3RhbnRfbWVzc2FnZVwiLCBtZXNzYWdlKSlcbiAgICAgICAgKTtcbiAgICAgIH07XG4gICAgICBjb25zdCBzZW5kRGF0YU1lc3NhZ2UgPSAobWVzc2FnZSkgPT4ge1xuICAgICAgICBjb250cm9sbGVyLmVucXVldWUoXG4gICAgICAgICAgdGV4dEVuY29kZXIuZW5jb2RlKGZvcm1hdFN0cmVhbVBhcnQzKFwiZGF0YV9tZXNzYWdlXCIsIG1lc3NhZ2UpKVxuICAgICAgICApO1xuICAgICAgfTtcbiAgICAgIGNvbnN0IHNlbmRFcnJvciA9IChlcnJvck1lc3NhZ2UpID0+IHtcbiAgICAgICAgY29udHJvbGxlci5lbnF1ZXVlKFxuICAgICAgICAgIHRleHRFbmNvZGVyLmVuY29kZShmb3JtYXRTdHJlYW1QYXJ0MyhcImVycm9yXCIsIGVycm9yTWVzc2FnZSkpXG4gICAgICAgICk7XG4gICAgICB9O1xuICAgICAgY29uc3QgZm9yd2FyZFN0cmVhbSA9IGFzeW5jIChzdHJlYW0yKSA9PiB7XG4gICAgICAgIHZhciBfYTEzLCBfYjtcbiAgICAgICAgbGV0IHJlc3VsdCA9IHZvaWQgMDtcbiAgICAgICAgZm9yIGF3YWl0IChjb25zdCB2YWx1ZSBvZiBzdHJlYW0yKSB7XG4gICAgICAgICAgc3dpdGNoICh2YWx1ZS5ldmVudCkge1xuICAgICAgICAgICAgY2FzZSBcInRocmVhZC5tZXNzYWdlLmNyZWF0ZWRcIjoge1xuICAgICAgICAgICAgICBjb250cm9sbGVyLmVucXVldWUoXG4gICAgICAgICAgICAgICAgdGV4dEVuY29kZXIuZW5jb2RlKFxuICAgICAgICAgICAgICAgICAgZm9ybWF0U3RyZWFtUGFydDMoXCJhc3Npc3RhbnRfbWVzc2FnZVwiLCB7XG4gICAgICAgICAgICAgICAgICAgIGlkOiB2YWx1ZS5kYXRhLmlkLFxuICAgICAgICAgICAgICAgICAgICByb2xlOiBcImFzc2lzdGFudFwiLFxuICAgICAgICAgICAgICAgICAgICBjb250ZW50OiBbeyB0eXBlOiBcInRleHRcIiwgdGV4dDogeyB2YWx1ZTogXCJcIiB9IH1dXG4gICAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXNlIFwidGhyZWFkLm1lc3NhZ2UuZGVsdGFcIjoge1xuICAgICAgICAgICAgICBjb25zdCBjb250ZW50ID0gKF9hMTMgPSB2YWx1ZS5kYXRhLmRlbHRhLmNvbnRlbnQpID09IG51bGwgPyB2b2lkIDAgOiBfYTEzWzBdO1xuICAgICAgICAgICAgICBpZiAoKGNvbnRlbnQgPT0gbnVsbCA/IHZvaWQgMCA6IGNvbnRlbnQudHlwZSkgPT09IFwidGV4dFwiICYmICgoX2IgPSBjb250ZW50LnRleHQpID09IG51bGwgPyB2b2lkIDAgOiBfYi52YWx1ZSkgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGNvbnRyb2xsZXIuZW5xdWV1ZShcbiAgICAgICAgICAgICAgICAgIHRleHRFbmNvZGVyLmVuY29kZShcbiAgICAgICAgICAgICAgICAgICAgZm9ybWF0U3RyZWFtUGFydDMoXCJ0ZXh0XCIsIGNvbnRlbnQudGV4dC52YWx1ZSlcbiAgICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FzZSBcInRocmVhZC5ydW4uY29tcGxldGVkXCI6XG4gICAgICAgICAgICBjYXNlIFwidGhyZWFkLnJ1bi5yZXF1aXJlc19hY3Rpb25cIjoge1xuICAgICAgICAgICAgICByZXN1bHQgPSB2YWx1ZS5kYXRhO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgIH07XG4gICAgICBjb250cm9sbGVyLmVucXVldWUoXG4gICAgICAgIHRleHRFbmNvZGVyLmVuY29kZShcbiAgICAgICAgICBmb3JtYXRTdHJlYW1QYXJ0MyhcImFzc2lzdGFudF9jb250cm9sX2RhdGFcIiwge1xuICAgICAgICAgICAgdGhyZWFkSWQsXG4gICAgICAgICAgICBtZXNzYWdlSWRcbiAgICAgICAgICB9KVxuICAgICAgICApXG4gICAgICApO1xuICAgICAgdHJ5IHtcbiAgICAgICAgYXdhaXQgcHJvY2VzczIoe1xuICAgICAgICAgIHRocmVhZElkLFxuICAgICAgICAgIG1lc3NhZ2VJZCxcbiAgICAgICAgICBzZW5kTWVzc2FnZSxcbiAgICAgICAgICBzZW5kRGF0YU1lc3NhZ2UsXG4gICAgICAgICAgZm9yd2FyZFN0cmVhbVxuICAgICAgICB9KTtcbiAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIHNlbmRFcnJvcigoX2ExMiA9IGVycm9yLm1lc3NhZ2UpICE9IG51bGwgPyBfYTEyIDogYCR7ZXJyb3J9YCk7XG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICBjb250cm9sbGVyLmNsb3NlKCk7XG4gICAgICB9XG4gICAgfSxcbiAgICBwdWxsKGNvbnRyb2xsZXIpIHtcbiAgICB9LFxuICAgIGNhbmNlbCgpIHtcbiAgICB9XG4gIH0pO1xuICByZXR1cm4gbmV3IFJlc3BvbnNlKHN0cmVhbSwge1xuICAgIHN0YXR1czogMjAwLFxuICAgIGhlYWRlcnM6IHtcbiAgICAgIFwiQ29udGVudC1UeXBlXCI6IFwidGV4dC9wbGFpbjsgY2hhcnNldD11dGYtOFwiXG4gICAgfVxuICB9KTtcbn1cbnZhciBleHBlcmltZW50YWxfQXNzaXN0YW50UmVzcG9uc2UgPSBBc3Npc3RhbnRSZXNwb25zZTtcblxuLy8gc3RyZWFtcy9hd3MtYmVkcm9jay1zdHJlYW0udHNcbmFzeW5jIGZ1bmN0aW9uKiBhc0RlbHRhSXRlcmFibGUocmVzcG9uc2UsIGV4dHJhY3RUZXh0RGVsdGFGcm9tQ2h1bmspIHtcbiAgdmFyIF9hMTIsIF9iO1xuICBjb25zdCBkZWNvZGVyID0gbmV3IFRleHREZWNvZGVyKCk7XG4gIGZvciBhd2FpdCAoY29uc3QgY2h1bmsgb2YgKF9hMTIgPSByZXNwb25zZS5ib2R5KSAhPSBudWxsID8gX2ExMiA6IFtdKSB7XG4gICAgY29uc3QgYnl0ZXMgPSAoX2IgPSBjaHVuay5jaHVuaykgPT0gbnVsbCA/IHZvaWQgMCA6IF9iLmJ5dGVzO1xuICAgIGlmIChieXRlcyAhPSBudWxsKSB7XG4gICAgICBjb25zdCBjaHVua1RleHQgPSBkZWNvZGVyLmRlY29kZShieXRlcyk7XG4gICAgICBjb25zdCBjaHVua0pTT04gPSBKU09OLnBhcnNlKGNodW5rVGV4dCk7XG4gICAgICBjb25zdCBkZWx0YSA9IGV4dHJhY3RUZXh0RGVsdGFGcm9tQ2h1bmsoY2h1bmtKU09OKTtcbiAgICAgIGlmIChkZWx0YSAhPSBudWxsKSB7XG4gICAgICAgIHlpZWxkIGRlbHRhO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuZnVuY3Rpb24gQVdTQmVkcm9ja0FudGhyb3BpY01lc3NhZ2VzU3RyZWFtKHJlc3BvbnNlLCBjYWxsYmFja3MpIHtcbiAgcmV0dXJuIEFXU0JlZHJvY2tTdHJlYW0ocmVzcG9uc2UsIGNhbGxiYWNrcywgKGNodW5rKSA9PiB7XG4gICAgdmFyIF9hMTI7XG4gICAgcmV0dXJuIChfYTEyID0gY2h1bmsuZGVsdGEpID09IG51bGwgPyB2b2lkIDAgOiBfYTEyLnRleHQ7XG4gIH0pO1xufVxuZnVuY3Rpb24gQVdTQmVkcm9ja0FudGhyb3BpY1N0cmVhbShyZXNwb25zZSwgY2FsbGJhY2tzKSB7XG4gIHJldHVybiBBV1NCZWRyb2NrU3RyZWFtKHJlc3BvbnNlLCBjYWxsYmFja3MsIChjaHVuaykgPT4gY2h1bmsuY29tcGxldGlvbik7XG59XG5mdW5jdGlvbiBBV1NCZWRyb2NrQ29oZXJlU3RyZWFtKHJlc3BvbnNlLCBjYWxsYmFja3MpIHtcbiAgcmV0dXJuIEFXU0JlZHJvY2tTdHJlYW0ocmVzcG9uc2UsIGNhbGxiYWNrcywgKGNodW5rKSA9PiBjaHVuayA9PSBudWxsID8gdm9pZCAwIDogY2h1bmsudGV4dCk7XG59XG5mdW5jdGlvbiBBV1NCZWRyb2NrTGxhbWEyU3RyZWFtKHJlc3BvbnNlLCBjYWxsYmFja3MpIHtcbiAgcmV0dXJuIEFXU0JlZHJvY2tTdHJlYW0ocmVzcG9uc2UsIGNhbGxiYWNrcywgKGNodW5rKSA9PiBjaHVuay5nZW5lcmF0aW9uKTtcbn1cbmZ1bmN0aW9uIEFXU0JlZHJvY2tTdHJlYW0ocmVzcG9uc2UsIGNhbGxiYWNrcywgZXh0cmFjdFRleHREZWx0YUZyb21DaHVuaykge1xuICByZXR1cm4gcmVhZGFibGVGcm9tQXN5bmNJdGVyYWJsZShcbiAgICBhc0RlbHRhSXRlcmFibGUocmVzcG9uc2UsIGV4dHJhY3RUZXh0RGVsdGFGcm9tQ2h1bmspXG4gICkucGlwZVRocm91Z2goY3JlYXRlQ2FsbGJhY2tzVHJhbnNmb3JtZXIoY2FsbGJhY2tzKSkucGlwZVRocm91Z2goY3JlYXRlU3RyZWFtRGF0YVRyYW5zZm9ybWVyKCkpO1xufVxuXG4vLyBzdHJlYW1zL2NvaGVyZS1zdHJlYW0udHNcbnZhciB1dGY4RGVjb2RlciA9IG5ldyBUZXh0RGVjb2RlcihcInV0Zi04XCIpO1xuYXN5bmMgZnVuY3Rpb24gcHJvY2Vzc0xpbmVzKGxpbmVzLCBjb250cm9sbGVyKSB7XG4gIGZvciAoY29uc3QgbGluZSBvZiBsaW5lcykge1xuICAgIGNvbnN0IHsgdGV4dCwgaXNfZmluaXNoZWQgfSA9IEpTT04ucGFyc2UobGluZSk7XG4gICAgaWYgKCFpc19maW5pc2hlZCkge1xuICAgICAgY29udHJvbGxlci5lbnF1ZXVlKHRleHQpO1xuICAgIH1cbiAgfVxufVxuYXN5bmMgZnVuY3Rpb24gcmVhZEFuZFByb2Nlc3NMaW5lcyhyZWFkZXIsIGNvbnRyb2xsZXIpIHtcbiAgbGV0IHNlZ21lbnQgPSBcIlwiO1xuICB3aGlsZSAodHJ1ZSkge1xuICAgIGNvbnN0IHsgdmFsdWU6IGNodW5rLCBkb25lIH0gPSBhd2FpdCByZWFkZXIucmVhZCgpO1xuICAgIGlmIChkb25lKSB7XG4gICAgICBicmVhaztcbiAgICB9XG4gICAgc2VnbWVudCArPSB1dGY4RGVjb2Rlci5kZWNvZGUoY2h1bmssIHsgc3RyZWFtOiB0cnVlIH0pO1xuICAgIGNvbnN0IGxpbmVzQXJyYXkgPSBzZWdtZW50LnNwbGl0KC9cXHJcXG58XFxufFxcci9nKTtcbiAgICBzZWdtZW50ID0gbGluZXNBcnJheS5wb3AoKSB8fCBcIlwiO1xuICAgIGF3YWl0IHByb2Nlc3NMaW5lcyhsaW5lc0FycmF5LCBjb250cm9sbGVyKTtcbiAgfVxuICBpZiAoc2VnbWVudCkge1xuICAgIGNvbnN0IGxpbmVzQXJyYXkgPSBbc2VnbWVudF07XG4gICAgYXdhaXQgcHJvY2Vzc0xpbmVzKGxpbmVzQXJyYXksIGNvbnRyb2xsZXIpO1xuICB9XG4gIGNvbnRyb2xsZXIuY2xvc2UoKTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZVBhcnNlcjIocmVzKSB7XG4gIHZhciBfYTEyO1xuICBjb25zdCByZWFkZXIgPSAoX2ExMiA9IHJlcy5ib2R5KSA9PSBudWxsID8gdm9pZCAwIDogX2ExMi5nZXRSZWFkZXIoKTtcbiAgcmV0dXJuIG5ldyBSZWFkYWJsZVN0cmVhbSh7XG4gICAgYXN5bmMgc3RhcnQoY29udHJvbGxlcikge1xuICAgICAgaWYgKCFyZWFkZXIpIHtcbiAgICAgICAgY29udHJvbGxlci5jbG9zZSgpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBhd2FpdCByZWFkQW5kUHJvY2Vzc0xpbmVzKHJlYWRlciwgY29udHJvbGxlcik7XG4gICAgfVxuICB9KTtcbn1cbmFzeW5jIGZ1bmN0aW9uKiBzdHJlYW1hYmxlMihzdHJlYW0pIHtcbiAgZm9yIGF3YWl0IChjb25zdCBjaHVuayBvZiBzdHJlYW0pIHtcbiAgICBpZiAoY2h1bmsuZXZlbnRUeXBlID09PSBcInRleHQtZ2VuZXJhdGlvblwiKSB7XG4gICAgICBjb25zdCB0ZXh0ID0gY2h1bmsudGV4dDtcbiAgICAgIGlmICh0ZXh0KVxuICAgICAgICB5aWVsZCB0ZXh0O1xuICAgIH1cbiAgfVxufVxuZnVuY3Rpb24gQ29oZXJlU3RyZWFtKHJlYWRlciwgY2FsbGJhY2tzKSB7XG4gIGlmIChTeW1ib2wuYXN5bmNJdGVyYXRvciBpbiByZWFkZXIpIHtcbiAgICByZXR1cm4gcmVhZGFibGVGcm9tQXN5bmNJdGVyYWJsZShzdHJlYW1hYmxlMihyZWFkZXIpKS5waXBlVGhyb3VnaChjcmVhdGVDYWxsYmFja3NUcmFuc2Zvcm1lcihjYWxsYmFja3MpKS5waXBlVGhyb3VnaChjcmVhdGVTdHJlYW1EYXRhVHJhbnNmb3JtZXIoKSk7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGNyZWF0ZVBhcnNlcjIocmVhZGVyKS5waXBlVGhyb3VnaChjcmVhdGVDYWxsYmFja3NUcmFuc2Zvcm1lcihjYWxsYmFja3MpKS5waXBlVGhyb3VnaChjcmVhdGVTdHJlYW1EYXRhVHJhbnNmb3JtZXIoKSk7XG4gIH1cbn1cblxuLy8gc3RyZWFtcy9nb29nbGUtZ2VuZXJhdGl2ZS1haS1zdHJlYW0udHNcbmFzeW5jIGZ1bmN0aW9uKiBzdHJlYW1hYmxlMyhyZXNwb25zZSkge1xuICB2YXIgX2ExMiwgX2IsIF9jO1xuICBmb3IgYXdhaXQgKGNvbnN0IGNodW5rIG9mIHJlc3BvbnNlLnN0cmVhbSkge1xuICAgIGNvbnN0IHBhcnRzID0gKF9jID0gKF9iID0gKF9hMTIgPSBjaHVuay5jYW5kaWRhdGVzKSA9PSBudWxsID8gdm9pZCAwIDogX2ExMlswXSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9iLmNvbnRlbnQpID09IG51bGwgPyB2b2lkIDAgOiBfYy5wYXJ0cztcbiAgICBpZiAocGFydHMgPT09IHZvaWQgMCkge1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIGNvbnN0IGZpcnN0UGFydCA9IHBhcnRzWzBdO1xuICAgIGlmICh0eXBlb2YgZmlyc3RQYXJ0LnRleHQgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgIHlpZWxkIGZpcnN0UGFydC50ZXh0O1xuICAgIH1cbiAgfVxufVxuZnVuY3Rpb24gR29vZ2xlR2VuZXJhdGl2ZUFJU3RyZWFtKHJlc3BvbnNlLCBjYikge1xuICByZXR1cm4gcmVhZGFibGVGcm9tQXN5bmNJdGVyYWJsZShzdHJlYW1hYmxlMyhyZXNwb25zZSkpLnBpcGVUaHJvdWdoKGNyZWF0ZUNhbGxiYWNrc1RyYW5zZm9ybWVyKGNiKSkucGlwZVRocm91Z2goY3JlYXRlU3RyZWFtRGF0YVRyYW5zZm9ybWVyKCkpO1xufVxuXG4vLyBzdHJlYW1zL2h1Z2dpbmdmYWNlLXN0cmVhbS50c1xuZnVuY3Rpb24gY3JlYXRlUGFyc2VyMyhyZXMpIHtcbiAgY29uc3QgdHJpbVN0YXJ0T2ZTdHJlYW0gPSB0cmltU3RhcnRPZlN0cmVhbUhlbHBlcigpO1xuICByZXR1cm4gbmV3IFJlYWRhYmxlU3RyZWFtKHtcbiAgICBhc3luYyBwdWxsKGNvbnRyb2xsZXIpIHtcbiAgICAgIHZhciBfYTEyLCBfYjtcbiAgICAgIGNvbnN0IHsgdmFsdWUsIGRvbmUgfSA9IGF3YWl0IHJlcy5uZXh0KCk7XG4gICAgICBpZiAoZG9uZSkge1xuICAgICAgICBjb250cm9sbGVyLmNsb3NlKCk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHRleHQgPSB0cmltU3RhcnRPZlN0cmVhbSgoX2IgPSAoX2ExMiA9IHZhbHVlLnRva2VuKSA9PSBudWxsID8gdm9pZCAwIDogX2ExMi50ZXh0KSAhPSBudWxsID8gX2IgOiBcIlwiKTtcbiAgICAgIGlmICghdGV4dClcbiAgICAgICAgcmV0dXJuO1xuICAgICAgaWYgKHZhbHVlLmdlbmVyYXRlZF90ZXh0ICE9IG51bGwgJiYgdmFsdWUuZ2VuZXJhdGVkX3RleHQubGVuZ3RoID4gMCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBpZiAodGV4dCA9PT0gXCI8L3M+XCIgfHwgdGV4dCA9PT0gXCI8fGVuZG9mdGV4dHw+XCIgfHwgdGV4dCA9PT0gXCI8fGVuZHw+XCIpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgY29udHJvbGxlci5lbnF1ZXVlKHRleHQpO1xuICAgIH1cbiAgfSk7XG59XG5mdW5jdGlvbiBIdWdnaW5nRmFjZVN0cmVhbShyZXMsIGNhbGxiYWNrcykge1xuICByZXR1cm4gY3JlYXRlUGFyc2VyMyhyZXMpLnBpcGVUaHJvdWdoKGNyZWF0ZUNhbGxiYWNrc1RyYW5zZm9ybWVyKGNhbGxiYWNrcykpLnBpcGVUaHJvdWdoKGNyZWF0ZVN0cmVhbURhdGFUcmFuc2Zvcm1lcigpKTtcbn1cblxuLy8gc3RyZWFtcy9pbmtlZXAtc3RyZWFtLnRzXG5mdW5jdGlvbiBJbmtlZXBTdHJlYW0ocmVzLCBjYWxsYmFja3MpIHtcbiAgaWYgKCFyZXMuYm9keSkge1xuICAgIHRocm93IG5ldyBFcnJvcihcIlJlc3BvbnNlIGJvZHkgaXMgbnVsbFwiKTtcbiAgfVxuICBsZXQgY2hhdF9zZXNzaW9uX2lkID0gXCJcIjtcbiAgbGV0IHJlY29yZHNfY2l0ZWQ7XG4gIGNvbnN0IGlua2VlcEV2ZW50UGFyc2VyID0gKGRhdGEsIG9wdGlvbnMpID0+IHtcbiAgICB2YXIgX2ExMiwgX2I7XG4gICAgY29uc3QgeyBldmVudCB9ID0gb3B0aW9ucztcbiAgICBpZiAoZXZlbnQgPT09IFwicmVjb3Jkc19jaXRlZFwiKSB7XG4gICAgICByZWNvcmRzX2NpdGVkID0gSlNPTi5wYXJzZShkYXRhKTtcbiAgICAgIChfYTEyID0gY2FsbGJhY2tzID09IG51bGwgPyB2b2lkIDAgOiBjYWxsYmFja3Mub25SZWNvcmRzQ2l0ZWQpID09IG51bGwgPyB2b2lkIDAgOiBfYTEyLmNhbGwoY2FsbGJhY2tzLCByZWNvcmRzX2NpdGVkKTtcbiAgICB9XG4gICAgaWYgKGV2ZW50ID09PSBcIm1lc3NhZ2VfY2h1bmtcIikge1xuICAgICAgY29uc3QgaW5rZWVwTWVzc2FnZUNodW5rID0gSlNPTi5wYXJzZShkYXRhKTtcbiAgICAgIGNoYXRfc2Vzc2lvbl9pZCA9IChfYiA9IGlua2VlcE1lc3NhZ2VDaHVuay5jaGF0X3Nlc3Npb25faWQpICE9IG51bGwgPyBfYiA6IGNoYXRfc2Vzc2lvbl9pZDtcbiAgICAgIHJldHVybiBpbmtlZXBNZXNzYWdlQ2h1bmsuY29udGVudF9jaHVuaztcbiAgICB9XG4gICAgcmV0dXJuO1xuICB9O1xuICBsZXQgeyBvblJlY29yZHNDaXRlZCwgLi4ucGFzc1Rocm91Z2hDYWxsYmFja3MgfSA9IGNhbGxiYWNrcyB8fCB7fTtcbiAgcGFzc1Rocm91Z2hDYWxsYmFja3MgPSB7XG4gICAgLi4ucGFzc1Rocm91Z2hDYWxsYmFja3MsXG4gICAgb25GaW5hbDogKGNvbXBsZXRpb24pID0+IHtcbiAgICAgIHZhciBfYTEyO1xuICAgICAgY29uc3QgaW5rZWVwT25GaW5hbE1ldGFkYXRhID0ge1xuICAgICAgICBjaGF0X3Nlc3Npb25faWQsXG4gICAgICAgIHJlY29yZHNfY2l0ZWRcbiAgICAgIH07XG4gICAgICAoX2ExMiA9IGNhbGxiYWNrcyA9PSBudWxsID8gdm9pZCAwIDogY2FsbGJhY2tzLm9uRmluYWwpID09IG51bGwgPyB2b2lkIDAgOiBfYTEyLmNhbGwoY2FsbGJhY2tzLCBjb21wbGV0aW9uLCBpbmtlZXBPbkZpbmFsTWV0YWRhdGEpO1xuICAgIH1cbiAgfTtcbiAgcmV0dXJuIEFJU3RyZWFtKHJlcywgaW5rZWVwRXZlbnRQYXJzZXIsIHBhc3NUaHJvdWdoQ2FsbGJhY2tzKS5waXBlVGhyb3VnaChcbiAgICBjcmVhdGVTdHJlYW1EYXRhVHJhbnNmb3JtZXIoKVxuICApO1xufVxuXG4vLyBzdHJlYW1zL2xhbmdjaGFpbi1hZGFwdGVyLnRzXG52YXIgbGFuZ2NoYWluX2FkYXB0ZXJfZXhwb3J0cyA9IHt9O1xuX19leHBvcnQobGFuZ2NoYWluX2FkYXB0ZXJfZXhwb3J0cywge1xuICB0b0FJU3RyZWFtOiAoKSA9PiB0b0FJU3RyZWFtLFxuICB0b0RhdGFTdHJlYW06ICgpID0+IHRvRGF0YVN0cmVhbSxcbiAgdG9EYXRhU3RyZWFtUmVzcG9uc2U6ICgpID0+IHRvRGF0YVN0cmVhbVJlc3BvbnNlXG59KTtcbmZ1bmN0aW9uIHRvQUlTdHJlYW0oc3RyZWFtLCBjYWxsYmFja3MpIHtcbiAgcmV0dXJuIHRvRGF0YVN0cmVhbShzdHJlYW0sIGNhbGxiYWNrcyk7XG59XG5mdW5jdGlvbiB0b0RhdGFTdHJlYW0oc3RyZWFtLCBjYWxsYmFja3MpIHtcbiAgcmV0dXJuIHN0cmVhbS5waXBlVGhyb3VnaChcbiAgICBuZXcgVHJhbnNmb3JtU3RyZWFtKHtcbiAgICAgIHRyYW5zZm9ybTogYXN5bmMgKHZhbHVlLCBjb250cm9sbGVyKSA9PiB7XG4gICAgICAgIHZhciBfYTEyO1xuICAgICAgICBpZiAodHlwZW9mIHZhbHVlID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgY29udHJvbGxlci5lbnF1ZXVlKHZhbHVlKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKFwiZXZlbnRcIiBpbiB2YWx1ZSkge1xuICAgICAgICAgIGlmICh2YWx1ZS5ldmVudCA9PT0gXCJvbl9jaGF0X21vZGVsX3N0cmVhbVwiKSB7XG4gICAgICAgICAgICBmb3J3YXJkQUlNZXNzYWdlQ2h1bmsoXG4gICAgICAgICAgICAgIChfYTEyID0gdmFsdWUuZGF0YSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9hMTIuY2h1bmssXG4gICAgICAgICAgICAgIGNvbnRyb2xsZXJcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBmb3J3YXJkQUlNZXNzYWdlQ2h1bmsodmFsdWUsIGNvbnRyb2xsZXIpO1xuICAgICAgfVxuICAgIH0pXG4gICkucGlwZVRocm91Z2goY3JlYXRlQ2FsbGJhY2tzVHJhbnNmb3JtZXIoY2FsbGJhY2tzKSkucGlwZVRocm91Z2goY3JlYXRlU3RyZWFtRGF0YVRyYW5zZm9ybWVyKCkpO1xufVxuZnVuY3Rpb24gdG9EYXRhU3RyZWFtUmVzcG9uc2Uoc3RyZWFtLCBvcHRpb25zKSB7XG4gIHZhciBfYTEyO1xuICBjb25zdCBkYXRhU3RyZWFtID0gdG9EYXRhU3RyZWFtKHN0cmVhbSwgb3B0aW9ucyA9PSBudWxsID8gdm9pZCAwIDogb3B0aW9ucy5jYWxsYmFja3MpO1xuICBjb25zdCBkYXRhID0gb3B0aW9ucyA9PSBudWxsID8gdm9pZCAwIDogb3B0aW9ucy5kYXRhO1xuICBjb25zdCBpbml0ID0gb3B0aW9ucyA9PSBudWxsID8gdm9pZCAwIDogb3B0aW9ucy5pbml0O1xuICBjb25zdCByZXNwb25zZVN0cmVhbSA9IGRhdGEgPyBtZXJnZVN0cmVhbXMoZGF0YS5zdHJlYW0sIGRhdGFTdHJlYW0pIDogZGF0YVN0cmVhbTtcbiAgcmV0dXJuIG5ldyBSZXNwb25zZShyZXNwb25zZVN0cmVhbSwge1xuICAgIHN0YXR1czogKF9hMTIgPSBpbml0ID09IG51bGwgPyB2b2lkIDAgOiBpbml0LnN0YXR1cykgIT0gbnVsbCA/IF9hMTIgOiAyMDAsXG4gICAgc3RhdHVzVGV4dDogaW5pdCA9PSBudWxsID8gdm9pZCAwIDogaW5pdC5zdGF0dXNUZXh0LFxuICAgIGhlYWRlcnM6IHByZXBhcmVSZXNwb25zZUhlYWRlcnMoaW5pdCwge1xuICAgICAgY29udGVudFR5cGU6IFwidGV4dC9wbGFpbjsgY2hhcnNldD11dGYtOFwiLFxuICAgICAgZGF0YVN0cmVhbVZlcnNpb246IFwidjFcIlxuICAgIH0pXG4gIH0pO1xufVxuZnVuY3Rpb24gZm9yd2FyZEFJTWVzc2FnZUNodW5rKGNodW5rLCBjb250cm9sbGVyKSB7XG4gIGlmICh0eXBlb2YgY2h1bmsuY29udGVudCA9PT0gXCJzdHJpbmdcIikge1xuICAgIGNvbnRyb2xsZXIuZW5xdWV1ZShjaHVuay5jb250ZW50KTtcbiAgfSBlbHNlIHtcbiAgICBjb25zdCBjb250ZW50ID0gY2h1bmsuY29udGVudDtcbiAgICBmb3IgKGNvbnN0IGl0ZW0gb2YgY29udGVudCkge1xuICAgICAgaWYgKGl0ZW0udHlwZSA9PT0gXCJ0ZXh0XCIpIHtcbiAgICAgICAgY29udHJvbGxlci5lbnF1ZXVlKGl0ZW0udGV4dCk7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbi8vIHN0cmVhbXMvbGFuZ2NoYWluLXN0cmVhbS50c1xuZnVuY3Rpb24gTGFuZ0NoYWluU3RyZWFtKGNhbGxiYWNrcykge1xuICBjb25zdCBzdHJlYW0gPSBuZXcgVHJhbnNmb3JtU3RyZWFtKCk7XG4gIGNvbnN0IHdyaXRlciA9IHN0cmVhbS53cml0YWJsZS5nZXRXcml0ZXIoKTtcbiAgY29uc3QgcnVucyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KCk7XG4gIGNvbnN0IGhhbmRsZUVycm9yID0gYXN5bmMgKGUsIHJ1bklkKSA9PiB7XG4gICAgcnVucy5kZWxldGUocnVuSWQpO1xuICAgIGF3YWl0IHdyaXRlci5yZWFkeTtcbiAgICBhd2FpdCB3cml0ZXIuYWJvcnQoZSk7XG4gIH07XG4gIGNvbnN0IGhhbmRsZVN0YXJ0ID0gYXN5bmMgKHJ1bklkKSA9PiB7XG4gICAgcnVucy5hZGQocnVuSWQpO1xuICB9O1xuICBjb25zdCBoYW5kbGVFbmQgPSBhc3luYyAocnVuSWQpID0+IHtcbiAgICBydW5zLmRlbGV0ZShydW5JZCk7XG4gICAgaWYgKHJ1bnMuc2l6ZSA9PT0gMCkge1xuICAgICAgYXdhaXQgd3JpdGVyLnJlYWR5O1xuICAgICAgYXdhaXQgd3JpdGVyLmNsb3NlKCk7XG4gICAgfVxuICB9O1xuICByZXR1cm4ge1xuICAgIHN0cmVhbTogc3RyZWFtLnJlYWRhYmxlLnBpcGVUaHJvdWdoKGNyZWF0ZUNhbGxiYWNrc1RyYW5zZm9ybWVyKGNhbGxiYWNrcykpLnBpcGVUaHJvdWdoKGNyZWF0ZVN0cmVhbURhdGFUcmFuc2Zvcm1lcigpKSxcbiAgICB3cml0ZXIsXG4gICAgaGFuZGxlcnM6IHtcbiAgICAgIGhhbmRsZUxMTU5ld1Rva2VuOiBhc3luYyAodG9rZW4pID0+IHtcbiAgICAgICAgYXdhaXQgd3JpdGVyLnJlYWR5O1xuICAgICAgICBhd2FpdCB3cml0ZXIud3JpdGUodG9rZW4pO1xuICAgICAgfSxcbiAgICAgIGhhbmRsZUxMTVN0YXJ0OiBhc3luYyAoX2xsbSwgX3Byb21wdHMsIHJ1bklkKSA9PiB7XG4gICAgICAgIGhhbmRsZVN0YXJ0KHJ1bklkKTtcbiAgICAgIH0sXG4gICAgICBoYW5kbGVMTE1FbmQ6IGFzeW5jIChfb3V0cHV0LCBydW5JZCkgPT4ge1xuICAgICAgICBhd2FpdCBoYW5kbGVFbmQocnVuSWQpO1xuICAgICAgfSxcbiAgICAgIGhhbmRsZUxMTUVycm9yOiBhc3luYyAoZSwgcnVuSWQpID0+IHtcbiAgICAgICAgYXdhaXQgaGFuZGxlRXJyb3IoZSwgcnVuSWQpO1xuICAgICAgfSxcbiAgICAgIGhhbmRsZUNoYWluU3RhcnQ6IGFzeW5jIChfY2hhaW4sIF9pbnB1dHMsIHJ1bklkKSA9PiB7XG4gICAgICAgIGhhbmRsZVN0YXJ0KHJ1bklkKTtcbiAgICAgIH0sXG4gICAgICBoYW5kbGVDaGFpbkVuZDogYXN5bmMgKF9vdXRwdXRzLCBydW5JZCkgPT4ge1xuICAgICAgICBhd2FpdCBoYW5kbGVFbmQocnVuSWQpO1xuICAgICAgfSxcbiAgICAgIGhhbmRsZUNoYWluRXJyb3I6IGFzeW5jIChlLCBydW5JZCkgPT4ge1xuICAgICAgICBhd2FpdCBoYW5kbGVFcnJvcihlLCBydW5JZCk7XG4gICAgICB9LFxuICAgICAgaGFuZGxlVG9vbFN0YXJ0OiBhc3luYyAoX3Rvb2wsIF9pbnB1dCwgcnVuSWQpID0+IHtcbiAgICAgICAgaGFuZGxlU3RhcnQocnVuSWQpO1xuICAgICAgfSxcbiAgICAgIGhhbmRsZVRvb2xFbmQ6IGFzeW5jIChfb3V0cHV0LCBydW5JZCkgPT4ge1xuICAgICAgICBhd2FpdCBoYW5kbGVFbmQocnVuSWQpO1xuICAgICAgfSxcbiAgICAgIGhhbmRsZVRvb2xFcnJvcjogYXN5bmMgKGUsIHJ1bklkKSA9PiB7XG4gICAgICAgIGF3YWl0IGhhbmRsZUVycm9yKGUsIHJ1bklkKTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG59XG5cbi8vIHN0cmVhbXMvbWlzdHJhbC1zdHJlYW0udHNcbmFzeW5jIGZ1bmN0aW9uKiBzdHJlYW1hYmxlNChzdHJlYW0pIHtcbiAgdmFyIF9hMTIsIF9iO1xuICBmb3IgYXdhaXQgKGNvbnN0IGNodW5rIG9mIHN0cmVhbSkge1xuICAgIGNvbnN0IGNvbnRlbnQgPSAoX2IgPSAoX2ExMiA9IGNodW5rLmNob2ljZXNbMF0pID09IG51bGwgPyB2b2lkIDAgOiBfYTEyLmRlbHRhKSA9PSBudWxsID8gdm9pZCAwIDogX2IuY29udGVudDtcbiAgICBpZiAoY29udGVudCA9PT0gdm9pZCAwIHx8IGNvbnRlbnQgPT09IFwiXCIpIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICB5aWVsZCBjb250ZW50O1xuICB9XG59XG5mdW5jdGlvbiBNaXN0cmFsU3RyZWFtKHJlc3BvbnNlLCBjYWxsYmFja3MpIHtcbiAgY29uc3Qgc3RyZWFtID0gcmVhZGFibGVGcm9tQXN5bmNJdGVyYWJsZShzdHJlYW1hYmxlNChyZXNwb25zZSkpO1xuICByZXR1cm4gc3RyZWFtLnBpcGVUaHJvdWdoKGNyZWF0ZUNhbGxiYWNrc1RyYW5zZm9ybWVyKGNhbGxiYWNrcykpLnBpcGVUaHJvdWdoKGNyZWF0ZVN0cmVhbURhdGFUcmFuc2Zvcm1lcigpKTtcbn1cblxuLy8gc3RyZWFtcy9vcGVuYWktc3RyZWFtLnRzXG5pbXBvcnQge1xuICBjcmVhdGVDaHVua0RlY29kZXIsXG4gIGZvcm1hdFN0cmVhbVBhcnQgYXMgZm9ybWF0U3RyZWFtUGFydDRcbn0gZnJvbSBcIkBhaS1zZGsvdWktdXRpbHNcIjtcbmZ1bmN0aW9uIHBhcnNlT3BlbkFJU3RyZWFtKCkge1xuICBjb25zdCBleHRyYWN0ID0gY2h1bmtUb1RleHQoKTtcbiAgcmV0dXJuIChkYXRhKSA9PiBleHRyYWN0KEpTT04ucGFyc2UoZGF0YSkpO1xufVxuYXN5bmMgZnVuY3Rpb24qIHN0cmVhbWFibGU1KHN0cmVhbSkge1xuICBjb25zdCBleHRyYWN0ID0gY2h1bmtUb1RleHQoKTtcbiAgZm9yIGF3YWl0IChsZXQgY2h1bmsgb2Ygc3RyZWFtKSB7XG4gICAgaWYgKFwicHJvbXB0RmlsdGVyUmVzdWx0c1wiIGluIGNodW5rKSB7XG4gICAgICBjaHVuayA9IHtcbiAgICAgICAgaWQ6IGNodW5rLmlkLFxuICAgICAgICBjcmVhdGVkOiBjaHVuay5jcmVhdGVkLmdldERhdGUoKSxcbiAgICAgICAgb2JqZWN0OiBjaHVuay5vYmplY3QsXG4gICAgICAgIC8vIG5vdCBleHBvc2VkIGJ5IEF6dXJlIEFQSVxuICAgICAgICBtb2RlbDogY2h1bmsubW9kZWwsXG4gICAgICAgIC8vIG5vdCBleHBvc2VkIGJ5IEF6dXJlIEFQSVxuICAgICAgICBjaG9pY2VzOiBjaHVuay5jaG9pY2VzLm1hcCgoY2hvaWNlKSA9PiB7XG4gICAgICAgICAgdmFyIF9hMTIsIF9iLCBfYywgX2QsIF9lLCBfZiwgX2c7XG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGRlbHRhOiB7XG4gICAgICAgICAgICAgIGNvbnRlbnQ6IChfYTEyID0gY2hvaWNlLmRlbHRhKSA9PSBudWxsID8gdm9pZCAwIDogX2ExMi5jb250ZW50LFxuICAgICAgICAgICAgICBmdW5jdGlvbl9jYWxsOiAoX2IgPSBjaG9pY2UuZGVsdGEpID09IG51bGwgPyB2b2lkIDAgOiBfYi5mdW5jdGlvbkNhbGwsXG4gICAgICAgICAgICAgIHJvbGU6IChfYyA9IGNob2ljZS5kZWx0YSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9jLnJvbGUsXG4gICAgICAgICAgICAgIHRvb2xfY2FsbHM6ICgoX2UgPSAoX2QgPSBjaG9pY2UuZGVsdGEpID09IG51bGwgPyB2b2lkIDAgOiBfZC50b29sQ2FsbHMpID09IG51bGwgPyB2b2lkIDAgOiBfZS5sZW5ndGgpID8gKF9nID0gKF9mID0gY2hvaWNlLmRlbHRhKSA9PSBudWxsID8gdm9pZCAwIDogX2YudG9vbENhbGxzKSA9PSBudWxsID8gdm9pZCAwIDogX2cubWFwKCh0b29sQ2FsbCwgaW5kZXgpID0+ICh7XG4gICAgICAgICAgICAgICAgaW5kZXgsXG4gICAgICAgICAgICAgICAgaWQ6IHRvb2xDYWxsLmlkLFxuICAgICAgICAgICAgICAgIGZ1bmN0aW9uOiB0b29sQ2FsbC5mdW5jdGlvbixcbiAgICAgICAgICAgICAgICB0eXBlOiB0b29sQ2FsbC50eXBlXG4gICAgICAgICAgICAgIH0pKSA6IHZvaWQgMFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGZpbmlzaF9yZWFzb246IGNob2ljZS5maW5pc2hSZWFzb24sXG4gICAgICAgICAgICBpbmRleDogY2hvaWNlLmluZGV4XG4gICAgICAgICAgfTtcbiAgICAgICAgfSlcbiAgICAgIH07XG4gICAgfVxuICAgIGNvbnN0IHRleHQgPSBleHRyYWN0KGNodW5rKTtcbiAgICBpZiAodGV4dClcbiAgICAgIHlpZWxkIHRleHQ7XG4gIH1cbn1cbmZ1bmN0aW9uIGNodW5rVG9UZXh0KCkge1xuICBjb25zdCB0cmltU3RhcnRPZlN0cmVhbSA9IHRyaW1TdGFydE9mU3RyZWFtSGVscGVyKCk7XG4gIGxldCBpc0Z1bmN0aW9uU3RyZWFtaW5nSW47XG4gIHJldHVybiAoanNvbikgPT4ge1xuICAgIHZhciBfYTEyLCBfYiwgX2MsIF9kLCBfZSwgX2YsIF9nLCBfaCwgX2ksIF9qLCBfaywgX2wsIF9tLCBfbiwgX28sIF9wLCBfcSwgX3I7XG4gICAgaWYgKGlzQ2hhdENvbXBsZXRpb25DaHVuayhqc29uKSkge1xuICAgICAgY29uc3QgZGVsdGEgPSAoX2ExMiA9IGpzb24uY2hvaWNlc1swXSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9hMTIuZGVsdGE7XG4gICAgICBpZiAoKF9iID0gZGVsdGEuZnVuY3Rpb25fY2FsbCkgPT0gbnVsbCA/IHZvaWQgMCA6IF9iLm5hbWUpIHtcbiAgICAgICAgaXNGdW5jdGlvblN0cmVhbWluZ0luID0gdHJ1ZTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBpc1RleHQ6IGZhbHNlLFxuICAgICAgICAgIGNvbnRlbnQ6IGB7XCJmdW5jdGlvbl9jYWxsXCI6IHtcIm5hbWVcIjogXCIke2RlbHRhLmZ1bmN0aW9uX2NhbGwubmFtZX1cIiwgXCJhcmd1bWVudHNcIjogXCJgXG4gICAgICAgIH07XG4gICAgICB9IGVsc2UgaWYgKChfZSA9IChfZCA9IChfYyA9IGRlbHRhLnRvb2xfY2FsbHMpID09IG51bGwgPyB2b2lkIDAgOiBfY1swXSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9kLmZ1bmN0aW9uKSA9PSBudWxsID8gdm9pZCAwIDogX2UubmFtZSkge1xuICAgICAgICBpc0Z1bmN0aW9uU3RyZWFtaW5nSW4gPSB0cnVlO1xuICAgICAgICBjb25zdCB0b29sQ2FsbCA9IGRlbHRhLnRvb2xfY2FsbHNbMF07XG4gICAgICAgIGlmICh0b29sQ2FsbC5pbmRleCA9PT0gMCkge1xuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBpc1RleHQ6IGZhbHNlLFxuICAgICAgICAgICAgY29udGVudDogYHtcInRvb2xfY2FsbHNcIjpbIHtcImlkXCI6IFwiJHt0b29sQ2FsbC5pZH1cIiwgXCJ0eXBlXCI6IFwiZnVuY3Rpb25cIiwgXCJmdW5jdGlvblwiOiB7XCJuYW1lXCI6IFwiJHsoX2YgPSB0b29sQ2FsbC5mdW5jdGlvbikgPT0gbnVsbCA/IHZvaWQgMCA6IF9mLm5hbWV9XCIsIFwiYXJndW1lbnRzXCI6IFwiYFxuICAgICAgICAgIH07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGlzVGV4dDogZmFsc2UsXG4gICAgICAgICAgICBjb250ZW50OiBgXCJ9fSwge1wiaWRcIjogXCIke3Rvb2xDYWxsLmlkfVwiLCBcInR5cGVcIjogXCJmdW5jdGlvblwiLCBcImZ1bmN0aW9uXCI6IHtcIm5hbWVcIjogXCIkeyhfZyA9IHRvb2xDYWxsLmZ1bmN0aW9uKSA9PSBudWxsID8gdm9pZCAwIDogX2cubmFtZX1cIiwgXCJhcmd1bWVudHNcIjogXCJgXG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmICgoX2ggPSBkZWx0YS5mdW5jdGlvbl9jYWxsKSA9PSBudWxsID8gdm9pZCAwIDogX2guYXJndW1lbnRzKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgaXNUZXh0OiBmYWxzZSxcbiAgICAgICAgICBjb250ZW50OiBjbGVhbnVwQXJndW1lbnRzKChfaSA9IGRlbHRhLmZ1bmN0aW9uX2NhbGwpID09IG51bGwgPyB2b2lkIDAgOiBfaS5hcmd1bWVudHMpXG4gICAgICAgIH07XG4gICAgICB9IGVsc2UgaWYgKChfbCA9IChfayA9IChfaiA9IGRlbHRhLnRvb2xfY2FsbHMpID09IG51bGwgPyB2b2lkIDAgOiBfalswXSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9rLmZ1bmN0aW9uKSA9PSBudWxsID8gdm9pZCAwIDogX2wuYXJndW1lbnRzKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgaXNUZXh0OiBmYWxzZSxcbiAgICAgICAgICBjb250ZW50OiBjbGVhbnVwQXJndW1lbnRzKChfbyA9IChfbiA9IChfbSA9IGRlbHRhLnRvb2xfY2FsbHMpID09IG51bGwgPyB2b2lkIDAgOiBfbVswXSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9uLmZ1bmN0aW9uKSA9PSBudWxsID8gdm9pZCAwIDogX28uYXJndW1lbnRzKVxuICAgICAgICB9O1xuICAgICAgfSBlbHNlIGlmIChpc0Z1bmN0aW9uU3RyZWFtaW5nSW4gJiYgKCgoX3AgPSBqc29uLmNob2ljZXNbMF0pID09IG51bGwgPyB2b2lkIDAgOiBfcC5maW5pc2hfcmVhc29uKSA9PT0gXCJmdW5jdGlvbl9jYWxsXCIgfHwgKChfcSA9IGpzb24uY2hvaWNlc1swXSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9xLmZpbmlzaF9yZWFzb24pID09PSBcInN0b3BcIikpIHtcbiAgICAgICAgaXNGdW5jdGlvblN0cmVhbWluZ0luID0gZmFsc2U7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgaXNUZXh0OiBmYWxzZSxcbiAgICAgICAgICBjb250ZW50OiAnXCJ9fSdcbiAgICAgICAgfTtcbiAgICAgIH0gZWxzZSBpZiAoaXNGdW5jdGlvblN0cmVhbWluZ0luICYmICgoX3IgPSBqc29uLmNob2ljZXNbMF0pID09IG51bGwgPyB2b2lkIDAgOiBfci5maW5pc2hfcmVhc29uKSA9PT0gXCJ0b29sX2NhbGxzXCIpIHtcbiAgICAgICAgaXNGdW5jdGlvblN0cmVhbWluZ0luID0gZmFsc2U7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgaXNUZXh0OiBmYWxzZSxcbiAgICAgICAgICBjb250ZW50OiAnXCJ9fV19J1xuICAgICAgICB9O1xuICAgICAgfVxuICAgIH1cbiAgICBjb25zdCB0ZXh0ID0gdHJpbVN0YXJ0T2ZTdHJlYW0oXG4gICAgICBpc0NoYXRDb21wbGV0aW9uQ2h1bmsoanNvbikgJiYganNvbi5jaG9pY2VzWzBdLmRlbHRhLmNvbnRlbnQgPyBqc29uLmNob2ljZXNbMF0uZGVsdGEuY29udGVudCA6IGlzQ29tcGxldGlvbihqc29uKSA/IGpzb24uY2hvaWNlc1swXS50ZXh0IDogXCJcIlxuICAgICk7XG4gICAgcmV0dXJuIHRleHQ7XG4gIH07XG4gIGZ1bmN0aW9uIGNsZWFudXBBcmd1bWVudHMoYXJndW1lbnRDaHVuaykge1xuICAgIGxldCBlc2NhcGVkUGFydGlhbEpzb24gPSBhcmd1bWVudENodW5rLnJlcGxhY2UoL1xcXFwvZywgXCJcXFxcXFxcXFwiKS5yZXBsYWNlKC9cXC8vZywgXCJcXFxcL1wiKS5yZXBsYWNlKC9cIi9nLCAnXFxcXFwiJykucmVwbGFjZSgvXFxuL2csIFwiXFxcXG5cIikucmVwbGFjZSgvXFxyL2csIFwiXFxcXHJcIikucmVwbGFjZSgvXFx0L2csIFwiXFxcXHRcIikucmVwbGFjZSgvXFxmL2csIFwiXFxcXGZcIik7XG4gICAgcmV0dXJuIGAke2VzY2FwZWRQYXJ0aWFsSnNvbn1gO1xuICB9XG59XG52YXIgX19pbnRlcm5hbF9fT3BlbkFJRm5NZXNzYWdlc1N5bWJvbCA9IFN5bWJvbChcbiAgXCJpbnRlcm5hbF9vcGVuYWlfZm5fbWVzc2FnZXNcIlxuKTtcbmZ1bmN0aW9uIGlzQ2hhdENvbXBsZXRpb25DaHVuayhkYXRhKSB7XG4gIHJldHVybiBcImNob2ljZXNcIiBpbiBkYXRhICYmIGRhdGEuY2hvaWNlcyAmJiBkYXRhLmNob2ljZXNbMF0gJiYgXCJkZWx0YVwiIGluIGRhdGEuY2hvaWNlc1swXTtcbn1cbmZ1bmN0aW9uIGlzQ29tcGxldGlvbihkYXRhKSB7XG4gIHJldHVybiBcImNob2ljZXNcIiBpbiBkYXRhICYmIGRhdGEuY2hvaWNlcyAmJiBkYXRhLmNob2ljZXNbMF0gJiYgXCJ0ZXh0XCIgaW4gZGF0YS5jaG9pY2VzWzBdO1xufVxuZnVuY3Rpb24gT3BlbkFJU3RyZWFtKHJlcywgY2FsbGJhY2tzKSB7XG4gIGNvbnN0IGNiID0gY2FsbGJhY2tzO1xuICBsZXQgc3RyZWFtO1xuICBpZiAoU3ltYm9sLmFzeW5jSXRlcmF0b3IgaW4gcmVzKSB7XG4gICAgc3RyZWFtID0gcmVhZGFibGVGcm9tQXN5bmNJdGVyYWJsZShzdHJlYW1hYmxlNShyZXMpKS5waXBlVGhyb3VnaChcbiAgICAgIGNyZWF0ZUNhbGxiYWNrc1RyYW5zZm9ybWVyKFxuICAgICAgICAoY2IgPT0gbnVsbCA/IHZvaWQgMCA6IGNiLmV4cGVyaW1lbnRhbF9vbkZ1bmN0aW9uQ2FsbCkgfHwgKGNiID09IG51bGwgPyB2b2lkIDAgOiBjYi5leHBlcmltZW50YWxfb25Ub29sQ2FsbCkgPyB7XG4gICAgICAgICAgLi4uY2IsXG4gICAgICAgICAgb25GaW5hbDogdm9pZCAwXG4gICAgICAgIH0gOiB7XG4gICAgICAgICAgLi4uY2JcbiAgICAgICAgfVxuICAgICAgKVxuICAgICk7XG4gIH0gZWxzZSB7XG4gICAgc3RyZWFtID0gQUlTdHJlYW0oXG4gICAgICByZXMsXG4gICAgICBwYXJzZU9wZW5BSVN0cmVhbSgpLFxuICAgICAgKGNiID09IG51bGwgPyB2b2lkIDAgOiBjYi5leHBlcmltZW50YWxfb25GdW5jdGlvbkNhbGwpIHx8IChjYiA9PSBudWxsID8gdm9pZCAwIDogY2IuZXhwZXJpbWVudGFsX29uVG9vbENhbGwpID8ge1xuICAgICAgICAuLi5jYixcbiAgICAgICAgb25GaW5hbDogdm9pZCAwXG4gICAgICB9IDoge1xuICAgICAgICAuLi5jYlxuICAgICAgfVxuICAgICk7XG4gIH1cbiAgaWYgKGNiICYmIChjYi5leHBlcmltZW50YWxfb25GdW5jdGlvbkNhbGwgfHwgY2IuZXhwZXJpbWVudGFsX29uVG9vbENhbGwpKSB7XG4gICAgY29uc3QgZnVuY3Rpb25DYWxsVHJhbnNmb3JtZXIgPSBjcmVhdGVGdW5jdGlvbkNhbGxUcmFuc2Zvcm1lcihjYik7XG4gICAgcmV0dXJuIHN0cmVhbS5waXBlVGhyb3VnaChmdW5jdGlvbkNhbGxUcmFuc2Zvcm1lcik7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIHN0cmVhbS5waXBlVGhyb3VnaChjcmVhdGVTdHJlYW1EYXRhVHJhbnNmb3JtZXIoKSk7XG4gIH1cbn1cbmZ1bmN0aW9uIGNyZWF0ZUZ1bmN0aW9uQ2FsbFRyYW5zZm9ybWVyKGNhbGxiYWNrcykge1xuICBjb25zdCB0ZXh0RW5jb2RlciA9IG5ldyBUZXh0RW5jb2RlcigpO1xuICBsZXQgaXNGaXJzdENodW5rID0gdHJ1ZTtcbiAgbGV0IGFnZ3JlZ2F0ZWRSZXNwb25zZSA9IFwiXCI7XG4gIGxldCBhZ2dyZWdhdGVkRmluYWxDb21wbGV0aW9uUmVzcG9uc2UgPSBcIlwiO1xuICBsZXQgaXNGdW5jdGlvblN0cmVhbWluZ0luID0gZmFsc2U7XG4gIGxldCBmdW5jdGlvbkNhbGxNZXNzYWdlcyA9IGNhbGxiYWNrc1tfX2ludGVybmFsX19PcGVuQUlGbk1lc3NhZ2VzU3ltYm9sXSB8fCBbXTtcbiAgY29uc3QgZGVjb2RlID0gY3JlYXRlQ2h1bmtEZWNvZGVyKCk7XG4gIHJldHVybiBuZXcgVHJhbnNmb3JtU3RyZWFtKHtcbiAgICBhc3luYyB0cmFuc2Zvcm0oY2h1bmssIGNvbnRyb2xsZXIpIHtcbiAgICAgIGNvbnN0IG1lc3NhZ2UgPSBkZWNvZGUoY2h1bmspO1xuICAgICAgYWdncmVnYXRlZEZpbmFsQ29tcGxldGlvblJlc3BvbnNlICs9IG1lc3NhZ2U7XG4gICAgICBjb25zdCBzaG91bGRIYW5kbGVBc0Z1bmN0aW9uID0gaXNGaXJzdENodW5rICYmIChtZXNzYWdlLnN0YXJ0c1dpdGgoJ3tcImZ1bmN0aW9uX2NhbGxcIjonKSB8fCBtZXNzYWdlLnN0YXJ0c1dpdGgoJ3tcInRvb2xfY2FsbHNcIjonKSk7XG4gICAgICBpZiAoc2hvdWxkSGFuZGxlQXNGdW5jdGlvbikge1xuICAgICAgICBpc0Z1bmN0aW9uU3RyZWFtaW5nSW4gPSB0cnVlO1xuICAgICAgICBhZ2dyZWdhdGVkUmVzcG9uc2UgKz0gbWVzc2FnZTtcbiAgICAgICAgaXNGaXJzdENodW5rID0gZmFsc2U7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGlmICghaXNGdW5jdGlvblN0cmVhbWluZ0luKSB7XG4gICAgICAgIGNvbnRyb2xsZXIuZW5xdWV1ZShcbiAgICAgICAgICB0ZXh0RW5jb2Rlci5lbmNvZGUoZm9ybWF0U3RyZWFtUGFydDQoXCJ0ZXh0XCIsIG1lc3NhZ2UpKVxuICAgICAgICApO1xuICAgICAgICByZXR1cm47XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBhZ2dyZWdhdGVkUmVzcG9uc2UgKz0gbWVzc2FnZTtcbiAgICAgIH1cbiAgICB9LFxuICAgIGFzeW5jIGZsdXNoKGNvbnRyb2xsZXIpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGlmICghaXNGaXJzdENodW5rICYmIGlzRnVuY3Rpb25TdHJlYW1pbmdJbiAmJiAoY2FsbGJhY2tzLmV4cGVyaW1lbnRhbF9vbkZ1bmN0aW9uQ2FsbCB8fCBjYWxsYmFja3MuZXhwZXJpbWVudGFsX29uVG9vbENhbGwpKSB7XG4gICAgICAgICAgaXNGdW5jdGlvblN0cmVhbWluZ0luID0gZmFsc2U7XG4gICAgICAgICAgY29uc3QgcGF5bG9hZCA9IEpTT04ucGFyc2UoYWdncmVnYXRlZFJlc3BvbnNlKTtcbiAgICAgICAgICBsZXQgbmV3RnVuY3Rpb25DYWxsTWVzc2FnZXMgPSBbXG4gICAgICAgICAgICAuLi5mdW5jdGlvbkNhbGxNZXNzYWdlc1xuICAgICAgICAgIF07XG4gICAgICAgICAgbGV0IGZ1bmN0aW9uUmVzcG9uc2UgPSB2b2lkIDA7XG4gICAgICAgICAgaWYgKGNhbGxiYWNrcy5leHBlcmltZW50YWxfb25GdW5jdGlvbkNhbGwpIHtcbiAgICAgICAgICAgIGlmIChwYXlsb2FkLmZ1bmN0aW9uX2NhbGwgPT09IHZvaWQgMCkge1xuICAgICAgICAgICAgICBjb25zb2xlLndhcm4oXG4gICAgICAgICAgICAgICAgXCJleHBlcmltZW50YWxfb25GdW5jdGlvbkNhbGwgc2hvdWxkIG5vdCBiZSBkZWZpbmVkIHdoZW4gdXNpbmcgdG9vbHNcIlxuICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgYXJndW1lbnRzUGF5bG9hZCA9IEpTT04ucGFyc2UoXG4gICAgICAgICAgICAgIHBheWxvYWQuZnVuY3Rpb25fY2FsbC5hcmd1bWVudHNcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICBmdW5jdGlvblJlc3BvbnNlID0gYXdhaXQgY2FsbGJhY2tzLmV4cGVyaW1lbnRhbF9vbkZ1bmN0aW9uQ2FsbChcbiAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIG5hbWU6IHBheWxvYWQuZnVuY3Rpb25fY2FsbC5uYW1lLFxuICAgICAgICAgICAgICAgIGFyZ3VtZW50czogYXJndW1lbnRzUGF5bG9hZFxuICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAocmVzdWx0KSA9PiB7XG4gICAgICAgICAgICAgICAgbmV3RnVuY3Rpb25DYWxsTWVzc2FnZXMgPSBbXG4gICAgICAgICAgICAgICAgICAuLi5mdW5jdGlvbkNhbGxNZXNzYWdlcyxcbiAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgcm9sZTogXCJhc3Npc3RhbnRcIixcbiAgICAgICAgICAgICAgICAgICAgY29udGVudDogXCJcIixcbiAgICAgICAgICAgICAgICAgICAgZnVuY3Rpb25fY2FsbDogcGF5bG9hZC5mdW5jdGlvbl9jYWxsXG4gICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICByb2xlOiBcImZ1bmN0aW9uXCIsXG4gICAgICAgICAgICAgICAgICAgIG5hbWU6IHBheWxvYWQuZnVuY3Rpb25fY2FsbC5uYW1lLFxuICAgICAgICAgICAgICAgICAgICBjb250ZW50OiBKU09OLnN0cmluZ2lmeShyZXN1bHQpXG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgXTtcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3RnVuY3Rpb25DYWxsTWVzc2FnZXM7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChjYWxsYmFja3MuZXhwZXJpbWVudGFsX29uVG9vbENhbGwpIHtcbiAgICAgICAgICAgIGNvbnN0IHRvb2xDYWxscyA9IHtcbiAgICAgICAgICAgICAgdG9vbHM6IFtdXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgZm9yIChjb25zdCB0b29sMiBvZiBwYXlsb2FkLnRvb2xfY2FsbHMpIHtcbiAgICAgICAgICAgICAgdG9vbENhbGxzLnRvb2xzLnB1c2goe1xuICAgICAgICAgICAgICAgIGlkOiB0b29sMi5pZCxcbiAgICAgICAgICAgICAgICB0eXBlOiBcImZ1bmN0aW9uXCIsXG4gICAgICAgICAgICAgICAgZnVuYzoge1xuICAgICAgICAgICAgICAgICAgbmFtZTogdG9vbDIuZnVuY3Rpb24ubmFtZSxcbiAgICAgICAgICAgICAgICAgIGFyZ3VtZW50czogSlNPTi5wYXJzZSh0b29sMi5mdW5jdGlvbi5hcmd1bWVudHMpXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxldCByZXNwb25zZUluZGV4ID0gMDtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgIGZ1bmN0aW9uUmVzcG9uc2UgPSBhd2FpdCBjYWxsYmFja3MuZXhwZXJpbWVudGFsX29uVG9vbENhbGwoXG4gICAgICAgICAgICAgICAgdG9vbENhbGxzLFxuICAgICAgICAgICAgICAgIChyZXN1bHQpID0+IHtcbiAgICAgICAgICAgICAgICAgIGlmIChyZXN1bHQpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgeyB0b29sX2NhbGxfaWQsIGZ1bmN0aW9uX25hbWUsIHRvb2xfY2FsbF9yZXN1bHQgfSA9IHJlc3VsdDtcbiAgICAgICAgICAgICAgICAgICAgbmV3RnVuY3Rpb25DYWxsTWVzc2FnZXMgPSBbXG4gICAgICAgICAgICAgICAgICAgICAgLi4ubmV3RnVuY3Rpb25DYWxsTWVzc2FnZXMsXG4gICAgICAgICAgICAgICAgICAgICAgLy8gT25seSBhcHBlbmQgdGhlIGFzc2lzdGFudCBtZXNzYWdlIGlmIGl0J3MgdGhlIGZpcnN0IHJlc3BvbnNlXG4gICAgICAgICAgICAgICAgICAgICAgLi4ucmVzcG9uc2VJbmRleCA9PT0gMCA/IFtcbiAgICAgICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgcm9sZTogXCJhc3Npc3RhbnRcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGVudDogXCJcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgdG9vbF9jYWxsczogcGF5bG9hZC50b29sX2NhbGxzLm1hcChcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAodGMpID0+ICh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZDogdGMuaWQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiBcImZ1bmN0aW9uXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmdW5jdGlvbjoge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuYW1lOiB0Yy5mdW5jdGlvbi5uYW1lLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyB3ZSBzZW5kIHRoZSBhcmd1bWVudHMgYW4gb2JqZWN0IHRvIHRoZSB1c2VyLCBidXQgYXMgdGhlIEFQSSBleHBlY3RzIGEgc3RyaW5nLCB3ZSBuZWVkIHRvIHN0cmluZ2lmeSBpdFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhcmd1bWVudHM6IEpTT04uc3RyaW5naWZ5KFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRjLmZ1bmN0aW9uLmFyZ3VtZW50c1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgIF0gOiBbXSxcbiAgICAgICAgICAgICAgICAgICAgICAvLyBBcHBlbmQgdGhlIGZ1bmN0aW9uIGNhbGwgcmVzdWx0IG1lc3NhZ2VcbiAgICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICByb2xlOiBcInRvb2xcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIHRvb2xfY2FsbF9pZCxcbiAgICAgICAgICAgICAgICAgICAgICAgIG5hbWU6IGZ1bmN0aW9uX25hbWUsXG4gICAgICAgICAgICAgICAgICAgICAgICBjb250ZW50OiBKU09OLnN0cmluZ2lmeSh0b29sX2NhbGxfcmVzdWx0KVxuICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgXTtcbiAgICAgICAgICAgICAgICAgICAgcmVzcG9uc2VJbmRleCsrO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ld0Z1bmN0aW9uQ2FsbE1lc3NhZ2VzO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihcIkVycm9yIGNhbGxpbmcgZXhwZXJpbWVudGFsX29uVG9vbENhbGw6XCIsIGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoIWZ1bmN0aW9uUmVzcG9uc2UpIHtcbiAgICAgICAgICAgIGNvbnRyb2xsZXIuZW5xdWV1ZShcbiAgICAgICAgICAgICAgdGV4dEVuY29kZXIuZW5jb2RlKFxuICAgICAgICAgICAgICAgIGZvcm1hdFN0cmVhbVBhcnQ0KFxuICAgICAgICAgICAgICAgICAgcGF5bG9hZC5mdW5jdGlvbl9jYWxsID8gXCJmdW5jdGlvbl9jYWxsXCIgOiBcInRvb2xfY2FsbHNcIixcbiAgICAgICAgICAgICAgICAgIC8vIHBhcnNlIHRvIHByZXZlbnQgZG91YmxlLWVuY29kaW5nOlxuICAgICAgICAgICAgICAgICAgSlNPTi5wYXJzZShhZ2dyZWdhdGVkUmVzcG9uc2UpXG4gICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICApXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIGZ1bmN0aW9uUmVzcG9uc2UgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgIGNvbnRyb2xsZXIuZW5xdWV1ZShcbiAgICAgICAgICAgICAgdGV4dEVuY29kZXIuZW5jb2RlKGZvcm1hdFN0cmVhbVBhcnQ0KFwidGV4dFwiLCBmdW5jdGlvblJlc3BvbnNlKSlcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICBhZ2dyZWdhdGVkRmluYWxDb21wbGV0aW9uUmVzcG9uc2UgPSBmdW5jdGlvblJlc3BvbnNlO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjb25zdCBmaWx0ZXJlZENhbGxiYWNrcyA9IHtcbiAgICAgICAgICAgIC4uLmNhbGxiYWNrcyxcbiAgICAgICAgICAgIG9uU3RhcnQ6IHZvaWQgMFxuICAgICAgICAgIH07XG4gICAgICAgICAgY2FsbGJhY2tzLm9uRmluYWwgPSB2b2lkIDA7XG4gICAgICAgICAgY29uc3Qgb3BlbkFJU3RyZWFtID0gT3BlbkFJU3RyZWFtKGZ1bmN0aW9uUmVzcG9uc2UsIHtcbiAgICAgICAgICAgIC4uLmZpbHRlcmVkQ2FsbGJhY2tzLFxuICAgICAgICAgICAgW19faW50ZXJuYWxfX09wZW5BSUZuTWVzc2FnZXNTeW1ib2xdOiBuZXdGdW5jdGlvbkNhbGxNZXNzYWdlc1xuICAgICAgICAgIH0pO1xuICAgICAgICAgIGNvbnN0IHJlYWRlciA9IG9wZW5BSVN0cmVhbS5nZXRSZWFkZXIoKTtcbiAgICAgICAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgICAgICAgY29uc3QgeyBkb25lLCB2YWx1ZSB9ID0gYXdhaXQgcmVhZGVyLnJlYWQoKTtcbiAgICAgICAgICAgIGlmIChkb25lKSB7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29udHJvbGxlci5lbnF1ZXVlKHZhbHVlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIGlmIChjYWxsYmFja3Mub25GaW5hbCAmJiBhZ2dyZWdhdGVkRmluYWxDb21wbGV0aW9uUmVzcG9uc2UpIHtcbiAgICAgICAgICBhd2FpdCBjYWxsYmFja3Mub25GaW5hbChhZ2dyZWdhdGVkRmluYWxDb21wbGV0aW9uUmVzcG9uc2UpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9KTtcbn1cblxuLy8gc3RyZWFtcy9yZXBsaWNhdGUtc3RyZWFtLnRzXG5hc3luYyBmdW5jdGlvbiBSZXBsaWNhdGVTdHJlYW0ocmVzLCBjYiwgb3B0aW9ucykge1xuICB2YXIgX2ExMjtcbiAgY29uc3QgdXJsID0gKF9hMTIgPSByZXMudXJscykgPT0gbnVsbCA/IHZvaWQgMCA6IF9hMTIuc3RyZWFtO1xuICBpZiAoIXVybCkge1xuICAgIGlmIChyZXMuZXJyb3IpXG4gICAgICB0aHJvdyBuZXcgRXJyb3IocmVzLmVycm9yKTtcbiAgICBlbHNlXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJNaXNzaW5nIHN0cmVhbSBVUkwgaW4gUmVwbGljYXRlIHJlc3BvbnNlXCIpO1xuICB9XG4gIGNvbnN0IGV2ZW50U3RyZWFtID0gYXdhaXQgZmV0Y2godXJsLCB7XG4gICAgbWV0aG9kOiBcIkdFVFwiLFxuICAgIGhlYWRlcnM6IHtcbiAgICAgIEFjY2VwdDogXCJ0ZXh0L2V2ZW50LXN0cmVhbVwiLFxuICAgICAgLi4ub3B0aW9ucyA9PSBudWxsID8gdm9pZCAwIDogb3B0aW9ucy5oZWFkZXJzXG4gICAgfVxuICB9KTtcbiAgcmV0dXJuIEFJU3RyZWFtKGV2ZW50U3RyZWFtLCB2b2lkIDAsIGNiKS5waXBlVGhyb3VnaChcbiAgICBjcmVhdGVTdHJlYW1EYXRhVHJhbnNmb3JtZXIoKVxuICApO1xufVxuXG4vLyBzdHJlYW1zL3N0cmVhbS10by1yZXNwb25zZS50c1xuZnVuY3Rpb24gc3RyZWFtVG9SZXNwb25zZShyZXMsIHJlc3BvbnNlLCBpbml0LCBkYXRhKSB7XG4gIHZhciBfYTEyO1xuICByZXNwb25zZS53cml0ZUhlYWQoKF9hMTIgPSBpbml0ID09IG51bGwgPyB2b2lkIDAgOiBpbml0LnN0YXR1cykgIT0gbnVsbCA/IF9hMTIgOiAyMDAsIHtcbiAgICBcIkNvbnRlbnQtVHlwZVwiOiBcInRleHQvcGxhaW47IGNoYXJzZXQ9dXRmLThcIixcbiAgICAuLi5pbml0ID09IG51bGwgPyB2b2lkIDAgOiBpbml0LmhlYWRlcnNcbiAgfSk7XG4gIGxldCBwcm9jZXNzZWRTdHJlYW0gPSByZXM7XG4gIGlmIChkYXRhKSB7XG4gICAgcHJvY2Vzc2VkU3RyZWFtID0gbWVyZ2VTdHJlYW1zKGRhdGEuc3RyZWFtLCByZXMpO1xuICB9XG4gIGNvbnN0IHJlYWRlciA9IHByb2Nlc3NlZFN0cmVhbS5nZXRSZWFkZXIoKTtcbiAgZnVuY3Rpb24gcmVhZCgpIHtcbiAgICByZWFkZXIucmVhZCgpLnRoZW4oKHsgZG9uZSwgdmFsdWUgfSkgPT4ge1xuICAgICAgaWYgKGRvbmUpIHtcbiAgICAgICAgcmVzcG9uc2UuZW5kKCk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHJlc3BvbnNlLndyaXRlKHZhbHVlKTtcbiAgICAgIHJlYWQoKTtcbiAgICB9KTtcbiAgfVxuICByZWFkKCk7XG59XG5cbi8vIHN0cmVhbXMvc3RyZWFtaW5nLXRleHQtcmVzcG9uc2UudHNcbnZhciBTdHJlYW1pbmdUZXh0UmVzcG9uc2UgPSBjbGFzcyBleHRlbmRzIFJlc3BvbnNlIHtcbiAgY29uc3RydWN0b3IocmVzLCBpbml0LCBkYXRhKSB7XG4gICAgbGV0IHByb2Nlc3NlZFN0cmVhbSA9IHJlcztcbiAgICBpZiAoZGF0YSkge1xuICAgICAgcHJvY2Vzc2VkU3RyZWFtID0gbWVyZ2VTdHJlYW1zKGRhdGEuc3RyZWFtLCByZXMpO1xuICAgIH1cbiAgICBzdXBlcihwcm9jZXNzZWRTdHJlYW0sIHtcbiAgICAgIC4uLmluaXQsXG4gICAgICBzdGF0dXM6IDIwMCxcbiAgICAgIGhlYWRlcnM6IHByZXBhcmVSZXNwb25zZUhlYWRlcnMoaW5pdCwge1xuICAgICAgICBjb250ZW50VHlwZTogXCJ0ZXh0L3BsYWluOyBjaGFyc2V0PXV0Zi04XCJcbiAgICAgIH0pXG4gICAgfSk7XG4gIH1cbn07XG5cbi8vIHN0cmVhbXMvaW5kZXgudHNcbnZhciBnZW5lcmF0ZUlkMiA9IGdlbmVyYXRlSWRJbXBsO1xudmFyIG5hbm9pZCA9IGdlbmVyYXRlSWRJbXBsO1xuZXhwb3J0IHtcbiAgQUlTREtFcnJvcjEyIGFzIEFJU0RLRXJyb3IsXG4gIEFJU3RyZWFtLFxuICBBUElDYWxsRXJyb3IyIGFzIEFQSUNhbGxFcnJvcixcbiAgQVdTQmVkcm9ja0FudGhyb3BpY01lc3NhZ2VzU3RyZWFtLFxuICBBV1NCZWRyb2NrQW50aHJvcGljU3RyZWFtLFxuICBBV1NCZWRyb2NrQ29oZXJlU3RyZWFtLFxuICBBV1NCZWRyb2NrTGxhbWEyU3RyZWFtLFxuICBBV1NCZWRyb2NrU3RyZWFtLFxuICBBbnRocm9waWNTdHJlYW0sXG4gIEFzc2lzdGFudFJlc3BvbnNlLFxuICBDb2hlcmVTdHJlYW0sXG4gIERvd25sb2FkRXJyb3IsXG4gIEVtcHR5UmVzcG9uc2VCb2R5RXJyb3IsXG4gIEdvb2dsZUdlbmVyYXRpdmVBSVN0cmVhbSxcbiAgSHVnZ2luZ0ZhY2VTdHJlYW0sXG4gIElua2VlcFN0cmVhbSxcbiAgSW52YWxpZEFyZ3VtZW50RXJyb3IsXG4gIEludmFsaWREYXRhQ29udGVudEVycm9yLFxuICBJbnZhbGlkTWVzc2FnZVJvbGVFcnJvcixcbiAgSW52YWxpZE1vZGVsSWRFcnJvcixcbiAgSW52YWxpZFByb21wdEVycm9yMiBhcyBJbnZhbGlkUHJvbXB0RXJyb3IsXG4gIEludmFsaWRSZXNwb25zZURhdGFFcnJvcixcbiAgSW52YWxpZFRvb2xBcmd1bWVudHNFcnJvcixcbiAgSlNPTlBhcnNlRXJyb3IsXG4gIGxhbmdjaGFpbl9hZGFwdGVyX2V4cG9ydHMgYXMgTGFuZ0NoYWluQWRhcHRlcixcbiAgTGFuZ0NoYWluU3RyZWFtLFxuICBMb2FkQVBJS2V5RXJyb3IsXG4gIE1pc3RyYWxTdHJlYW0sXG4gIE5vT2JqZWN0R2VuZXJhdGVkRXJyb3IsXG4gIE5vU3VjaE1vZGVsRXJyb3IsXG4gIE5vU3VjaFByb3ZpZGVyRXJyb3IsXG4gIE5vU3VjaFRvb2xFcnJvcixcbiAgT3BlbkFJU3RyZWFtLFxuICBSZXBsaWNhdGVTdHJlYW0sXG4gIFJldHJ5RXJyb3IsXG4gIFN0cmVhbURhdGEyIGFzIFN0cmVhbURhdGEsXG4gIFN0cmVhbWluZ1RleHRSZXNwb25zZSxcbiAgVHlwZVZhbGlkYXRpb25FcnJvcixcbiAgVW5zdXBwb3J0ZWRGdW5jdGlvbmFsaXR5RXJyb3IsXG4gIGNvbnZlcnREYXRhQ29udGVudFRvQmFzZTY0U3RyaW5nLFxuICBjb252ZXJ0RGF0YUNvbnRlbnRUb1VpbnQ4QXJyYXksXG4gIGNvbnZlcnRUb0NvcmVNZXNzYWdlcyxcbiAgY29udmVydFVpbnQ4QXJyYXlUb1RleHQsXG4gIGNvc2luZVNpbWlsYXJpdHksXG4gIGNyZWF0ZUNhbGxiYWNrc1RyYW5zZm9ybWVyLFxuICBjcmVhdGVFdmVudFN0cmVhbVRyYW5zZm9ybWVyLFxuICBjcmVhdGVTdHJlYW1EYXRhVHJhbnNmb3JtZXIsXG4gIGVtYmVkLFxuICBlbWJlZE1hbnksXG4gIGV4cGVyaW1lbnRhbF9Bc3Npc3RhbnRSZXNwb25zZSxcbiAgZXhwZXJpbWVudGFsX1N0cmVhbURhdGEsXG4gIGV4cGVyaW1lbnRhbF9jcmVhdGVNb2RlbFJlZ2lzdHJ5LFxuICBleHBlcmltZW50YWxfY3JlYXRlUHJvdmlkZXJSZWdpc3RyeSxcbiAgZXhwZXJpbWVudGFsX2dlbmVyYXRlT2JqZWN0LFxuICBleHBlcmltZW50YWxfZ2VuZXJhdGVUZXh0LFxuICBleHBlcmltZW50YWxfc3RyZWFtT2JqZWN0LFxuICBleHBlcmltZW50YWxfc3RyZWFtVGV4dCxcbiAgZm9ybWF0U3RyZWFtUGFydCxcbiAgZ2VuZXJhdGVJZDIgYXMgZ2VuZXJhdGVJZCxcbiAgZ2VuZXJhdGVPYmplY3QsXG4gIGdlbmVyYXRlVGV4dCxcbiAganNvblNjaGVtYSxcbiAgbmFub2lkLFxuICBwYXJzZUNvbXBsZXhSZXNwb25zZSxcbiAgcGFyc2VTdHJlYW1QYXJ0LFxuICByZWFkRGF0YVN0cmVhbSxcbiAgcmVhZGFibGVGcm9tQXN5bmNJdGVyYWJsZSxcbiAgc3RyZWFtT2JqZWN0LFxuICBzdHJlYW1UZXh0LFxuICBzdHJlYW1Ub1Jlc3BvbnNlLFxuICB0b29sLFxuICB0cmltU3RhcnRPZlN0cmVhbUhlbHBlclxufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4Lm1qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(action-browser)/./node_modules/ai/dist/index.mjs\n");

/***/ }),

/***/ "(action-browser)/./node_modules/ai/rsc/dist/rsc-server.mjs":
/*!*************************************************!*\
  !*** ./node_modules/ai/rsc/dist/rsc-server.mjs ***!
  \*************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("var react__WEBPACK_IMPORTED_MODULE_4___namespace_cache;\n__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   $$ACTION_0: () => (/* binding */ $$ACTION_0),\n/* harmony export */   createAI: () => (/* binding */ createAI),\n/* harmony export */   createStreamableUI: () => (/* binding */ createStreamableUI),\n/* harmony export */   createStreamableValue: () => (/* binding */ createStreamableValue),\n/* harmony export */   getAIState: () => (/* binding */ getAIState),\n/* harmony export */   getMutableAIState: () => (/* binding */ getMutableAIState),\n/* harmony export */   render: () => (/* binding */ render),\n/* harmony export */   streamUI: () => (/* binding */ streamUI)\n/* harmony export */ });\n/* harmony import */ var private_next_rsc_server_reference__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! private-next-rsc-server-reference */ \"(action-browser)/./node_modules/next/dist/build/webpack/loaders/next-flight-loader/server-reference.js\");\n/* harmony import */ var private_next_rsc_action_encryption__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! private-next-rsc-action-encryption */ \"(action-browser)/./node_modules/next/dist/server/app-render/encryption.js\");\n/* harmony import */ var jsondiffpatch__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! jsondiffpatch */ \"(action-browser)/./node_modules/jsondiffpatch/lib/index.js\");\n/* harmony import */ var async_hooks__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! async_hooks */ \"async_hooks\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! react */ \"(action-browser)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/rsc/react.js\");\n/* harmony import */ var _rsc_shared_mjs__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./rsc-shared.mjs */ \"(action-browser)/./node_modules/ai/rsc/dist/rsc-shared.mjs\");\n/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! react/jsx-runtime */ \"(action-browser)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/rsc/react-jsx-runtime.js\");\n/* harmony import */ var _ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! @ai-sdk/provider-utils */ \"(action-browser)/./node_modules/@ai-sdk/provider-utils/dist/index.mjs\");\n/* harmony import */ var _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! @ai-sdk/provider */ \"(action-browser)/./node_modules/@ai-sdk/provider/dist/index.mjs\");\n/* harmony import */ var _ai_sdk_ui_utils__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! @ai-sdk/ui-utils */ \"(action-browser)/./node_modules/@ai-sdk/ui-utils/dist/index.mjs\");\n/* harmony import */ var zod_to_json_schema__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! zod-to-json-schema */ \"(action-browser)/./node_modules/zod-to-json-schema/dist/esm/index.js\");\n/* harmony import */ var eventsource_parser__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! eventsource-parser */ \"(action-browser)/./node_modules/eventsource-parser/dist/index.js\");\n// rsc/ai-state.tsx\n/* __next_internal_action_entry_do_not_use__ {\"d8e4d357cb012f09c7fa33d93d8ebed85524c200\":\"$$ACTION_0\"} */ \n\n\n\n// util/create-resolvable-promise.ts\nfunction createResolvablePromise() {\n    let resolve;\n    let reject;\n    const promise = new Promise((res, rej)=>{\n        resolve = res;\n        reject = rej;\n    });\n    return {\n        promise,\n        resolve,\n        reject\n    };\n}\n// util/is-function.ts\nvar isFunction = (value)=>typeof value === \"function\";\n// rsc/ai-state.tsx\nvar asyncAIStateStorage = new async_hooks__WEBPACK_IMPORTED_MODULE_2__.AsyncLocalStorage();\nfunction getAIStateStoreOrThrow(message) {\n    const store = asyncAIStateStorage.getStore();\n    if (!store) {\n        throw new Error(message);\n    }\n    return store;\n}\nfunction withAIState({ state: state1, options }, fn) {\n    return asyncAIStateStorage.run({\n        currentState: state1,\n        originalState: state1,\n        sealed: false,\n        options\n    }, fn);\n}\nfunction getAIStateDeltaPromise() {\n    const store = getAIStateStoreOrThrow(\"Internal error occurred.\");\n    return store.mutationDeltaPromise;\n}\nfunction sealMutableAIState() {\n    const store = getAIStateStoreOrThrow(\"Internal error occurred.\");\n    store.sealed = true;\n}\nfunction getAIState(...args) {\n    const store = getAIStateStoreOrThrow(\"`getAIState` must be called within an AI Action.\");\n    if (args.length > 0) {\n        const key = args[0];\n        if (typeof store.currentState !== \"object\") {\n            throw new Error(`You can't get the \"${String(key)}\" field from the AI state because it's not an object.`);\n        }\n        return store.currentState[key];\n    }\n    return store.currentState;\n}\nfunction getMutableAIState(...args) {\n    const store = getAIStateStoreOrThrow(\"`getMutableAIState` must be called within an AI Action.\");\n    if (store.sealed) {\n        throw new Error(\"`getMutableAIState` must be called before returning from an AI Action. Please move it to the top level of the Action's function body.\");\n    }\n    if (!store.mutationDeltaPromise) {\n        const { promise, resolve } = createResolvablePromise();\n        store.mutationDeltaPromise = promise;\n        store.mutationDeltaResolve = resolve;\n    }\n    function doUpdate(newState, done) {\n        var _a8, _b;\n        if (args.length > 0) {\n            if (typeof store.currentState !== \"object\") {\n                const key = args[0];\n                throw new Error(`You can't modify the \"${String(key)}\" field of the AI state because it's not an object.`);\n            }\n        }\n        if (isFunction(newState)) {\n            if (args.length > 0) {\n                store.currentState[args[0]] = newState(store.currentState[args[0]]);\n            } else {\n                store.currentState = newState(store.currentState);\n            }\n        } else {\n            if (args.length > 0) {\n                store.currentState[args[0]] = newState;\n            } else {\n                store.currentState = newState;\n            }\n        }\n        (_b = (_a8 = store.options).onSetAIState) == null ? void 0 : _b.call(_a8, {\n            key: args.length > 0 ? args[0] : void 0,\n            state: store.currentState,\n            done\n        });\n    }\n    const mutableState = {\n        get: ()=>{\n            if (args.length > 0) {\n                const key = args[0];\n                if (typeof store.currentState !== \"object\") {\n                    throw new Error(`You can't get the \"${String(key)}\" field from the AI state because it's not an object.`);\n                }\n                return store.currentState[key];\n            }\n            return store.currentState;\n        },\n        update: function update(newAIState) {\n            doUpdate(newAIState, false);\n        },\n        done: function done(...doneArgs) {\n            if (doneArgs.length > 0) {\n                doUpdate(doneArgs[0], true);\n            }\n            const delta = jsondiffpatch__WEBPACK_IMPORTED_MODULE_3__.diff(store.originalState, store.currentState);\n            store.mutationDeltaResolve(delta);\n        }\n    };\n    return mutableState;\n}\n// rsc/provider.tsx\n\n\n\nvar innerAction = (0,private_next_rsc_server_reference__WEBPACK_IMPORTED_MODULE_0__.registerServerReference)(\"d8e4d357cb012f09c7fa33d93d8ebed85524c200\", $$ACTION_0);\nasync function $$ACTION_0({ action, options }, state1, ...args) {\n    return await withAIState({\n        state: state1,\n        options\n    }, async ()=>{\n        const result = await action(...args);\n        sealMutableAIState();\n        return [\n            getAIStateDeltaPromise(),\n            result\n        ];\n    });\n}\nfunction wrapAction(action, options) {\n    return innerAction.bind(null, {\n        action,\n        options\n    });\n}\nfunction createAI({ actions, initialAIState, initialUIState, onSetAIState, onGetUIState }) {\n    const wrappedActions = {};\n    for(const name8 in actions){\n        wrappedActions[name8] = wrapAction(actions[name8], {\n            onSetAIState\n        });\n    }\n    const wrappedSyncUIState = onGetUIState ? wrapAction(onGetUIState, {}) : void 0;\n    const AI = async (props)=>{\n        var _a8, _b;\n        if (\"useState\" in /*#__PURE__*/ (react__WEBPACK_IMPORTED_MODULE_4___namespace_cache || (react__WEBPACK_IMPORTED_MODULE_4___namespace_cache = __webpack_require__.t(react__WEBPACK_IMPORTED_MODULE_4__, 2)))) {\n            throw new Error(\"This component can only be used inside Server Components.\");\n        }\n        let uiState = (_a8 = props.initialUIState) != null ? _a8 : initialUIState;\n        let aiState = (_b = props.initialAIState) != null ? _b : initialAIState;\n        let aiStateDelta = void 0;\n        if (wrappedSyncUIState) {\n            const [newAIStateDelta, newUIState] = await wrappedSyncUIState(aiState);\n            if (newUIState !== void 0) {\n                aiStateDelta = newAIStateDelta;\n                uiState = newUIState;\n            }\n        }\n        return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_5__.jsx)(_rsc_shared_mjs__WEBPACK_IMPORTED_MODULE_6__.InternalAIProvider, {\n            wrappedActions,\n            wrappedSyncUIState,\n            initialUIState: uiState,\n            initialAIState: aiState,\n            initialAIStatePatch: aiStateDelta,\n            children: props.children\n        });\n    };\n    return AI;\n}\n// rsc/stream-ui/stream-ui.tsx\n\n// core/prompt/convert-to-language-model-prompt.ts\n\n// util/download-error.ts\n\nvar name = \"AI_DownloadError\";\nvar marker = `vercel.ai.error.${name}`;\nvar symbol = Symbol.for(marker);\nvar _a;\nvar DownloadError = class extends _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_7__.AISDKError {\n    constructor({ url, statusCode, statusText, cause, message = cause == null ? `Failed to download ${url}: ${statusCode} ${statusText}` : `Failed to download ${url}: ${cause}` }){\n        super({\n            name,\n            message,\n            cause\n        });\n        this[_a] = true;\n        this.url = url;\n        this.statusCode = statusCode;\n        this.statusText = statusText;\n    }\n    static isInstance(error) {\n        return _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_7__.AISDKError.hasMarker(error, marker);\n    }\n    /**\n   * @deprecated use `isInstance` instead\n   */ static isDownloadError(error) {\n        return error instanceof Error && error.name === name && typeof error.url === \"string\" && (error.statusCode == null || typeof error.statusCode === \"number\") && (error.statusText == null || typeof error.statusText === \"string\");\n    }\n    /**\n   * @deprecated Do not use this method. It will be removed in the next major version.\n   */ toJSON() {\n        return {\n            name: this.name,\n            message: this.message,\n            url: this.url,\n            statusCode: this.statusCode,\n            statusText: this.statusText,\n            cause: this.cause\n        };\n    }\n};\n_a = symbol;\n// util/download.ts\nasync function download({ url, fetchImplementation = fetch }) {\n    var _a8;\n    const urlText = url.toString();\n    try {\n        const response = await fetchImplementation(urlText);\n        if (!response.ok) {\n            throw new DownloadError({\n                url: urlText,\n                statusCode: response.status,\n                statusText: response.statusText\n            });\n        }\n        return {\n            data: new Uint8Array(await response.arrayBuffer()),\n            mimeType: (_a8 = response.headers.get(\"content-type\")) != null ? _a8 : void 0\n        };\n    } catch (error) {\n        if (DownloadError.isInstance(error)) {\n            throw error;\n        }\n        throw new DownloadError({\n            url: urlText,\n            cause: error\n        });\n    }\n}\n// core/util/detect-image-mimetype.ts\nvar mimeTypeSignatures = [\n    {\n        mimeType: \"image/gif\",\n        bytes: [\n            71,\n            73,\n            70\n        ]\n    },\n    {\n        mimeType: \"image/png\",\n        bytes: [\n            137,\n            80,\n            78,\n            71\n        ]\n    },\n    {\n        mimeType: \"image/jpeg\",\n        bytes: [\n            255,\n            216\n        ]\n    },\n    {\n        mimeType: \"image/webp\",\n        bytes: [\n            82,\n            73,\n            70,\n            70\n        ]\n    }\n];\nfunction detectImageMimeType(image) {\n    for (const { bytes, mimeType } of mimeTypeSignatures){\n        if (image.length >= bytes.length && bytes.every((byte, index)=>image[index] === byte)) {\n            return mimeType;\n        }\n    }\n    return void 0;\n}\n// core/prompt/data-content.ts\n\n// core/prompt/invalid-data-content-error.ts\n\nvar name2 = \"AI_InvalidDataContentError\";\nvar marker2 = `vercel.ai.error.${name2}`;\nvar symbol2 = Symbol.for(marker2);\nvar _a2;\nvar InvalidDataContentError = class extends _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_7__.AISDKError {\n    constructor({ content, cause, message = `Invalid data content. Expected a base64 string, Uint8Array, ArrayBuffer, or Buffer, but got ${typeof content}.` }){\n        super({\n            name: name2,\n            message,\n            cause\n        });\n        this[_a2] = true;\n        this.content = content;\n    }\n    static isInstance(error) {\n        return _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_7__.AISDKError.hasMarker(error, marker2);\n    }\n    /**\n   * @deprecated use `isInstance` instead\n   */ static isInvalidDataContentError(error) {\n        return error instanceof Error && error.name === name2 && error.content != null;\n    }\n    /**\n   * @deprecated Do not use this method. It will be removed in the next major version.\n   */ toJSON() {\n        return {\n            name: this.name,\n            message: this.message,\n            stack: this.stack,\n            cause: this.cause,\n            content: this.content\n        };\n    }\n};\n_a2 = symbol2;\n// core/prompt/data-content.ts\nfunction convertDataContentToUint8Array(content) {\n    if (content instanceof Uint8Array) {\n        return content;\n    }\n    if (typeof content === \"string\") {\n        try {\n            return (0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_8__.convertBase64ToUint8Array)(content);\n        } catch (error) {\n            throw new InvalidDataContentError({\n                message: \"Invalid data content. Content string is not a base64-encoded media.\",\n                content,\n                cause: error\n            });\n        }\n    }\n    if (content instanceof ArrayBuffer) {\n        return new Uint8Array(content);\n    }\n    throw new InvalidDataContentError({\n        content\n    });\n}\n// core/prompt/invalid-message-role-error.ts\n\nvar name3 = \"AI_InvalidMessageRoleError\";\nvar marker3 = `vercel.ai.error.${name3}`;\nvar symbol3 = Symbol.for(marker3);\nvar _a3;\nvar InvalidMessageRoleError = class extends _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_7__.AISDKError {\n    constructor({ role, message = `Invalid message role: '${role}'. Must be one of: \"system\", \"user\", \"assistant\", \"tool\".` }){\n        super({\n            name: name3,\n            message\n        });\n        this[_a3] = true;\n        this.role = role;\n    }\n    static isInstance(error) {\n        return _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_7__.AISDKError.hasMarker(error, marker3);\n    }\n    /**\n   * @deprecated use `isInstance` instead\n   */ static isInvalidMessageRoleError(error) {\n        return error instanceof Error && error.name === name3 && typeof error.role === \"string\";\n    }\n    /**\n   * @deprecated Do not use this method. It will be removed in the next major version.\n   */ toJSON() {\n        return {\n            name: this.name,\n            message: this.message,\n            stack: this.stack,\n            role: this.role\n        };\n    }\n};\n_a3 = symbol3;\n// core/prompt/convert-to-language-model-prompt.ts\nasync function convertToLanguageModelPrompt({ prompt, modelSupportsImageUrls = true, downloadImplementation = download }) {\n    const languageModelMessages = [];\n    if (prompt.system != null) {\n        languageModelMessages.push({\n            role: \"system\",\n            content: prompt.system\n        });\n    }\n    const downloadedImages = modelSupportsImageUrls || prompt.messages == null ? null : await downloadImages(prompt.messages, downloadImplementation);\n    const promptType = prompt.type;\n    switch(promptType){\n        case \"prompt\":\n            {\n                languageModelMessages.push({\n                    role: \"user\",\n                    content: [\n                        {\n                            type: \"text\",\n                            text: prompt.prompt\n                        }\n                    ]\n                });\n                break;\n            }\n        case \"messages\":\n            {\n                languageModelMessages.push(...prompt.messages.map((message)=>convertToLanguageModelMessage(message, downloadedImages)));\n                break;\n            }\n        default:\n            {\n                const _exhaustiveCheck = promptType;\n                throw new Error(`Unsupported prompt type: ${_exhaustiveCheck}`);\n            }\n    }\n    return languageModelMessages;\n}\nfunction convertToLanguageModelMessage(message, downloadedImages) {\n    const role = message.role;\n    switch(role){\n        case \"system\":\n            {\n                return {\n                    role: \"system\",\n                    content: message.content,\n                    providerMetadata: message.experimental_providerMetadata\n                };\n            }\n        case \"user\":\n            {\n                if (typeof message.content === \"string\") {\n                    return {\n                        role: \"user\",\n                        content: [\n                            {\n                                type: \"text\",\n                                text: message.content\n                            }\n                        ],\n                        providerMetadata: message.experimental_providerMetadata\n                    };\n                }\n                return {\n                    role: \"user\",\n                    content: message.content.map((part)=>{\n                        var _a8, _b, _c;\n                        switch(part.type){\n                            case \"text\":\n                                {\n                                    return {\n                                        type: \"text\",\n                                        text: part.text,\n                                        providerMetadata: part.experimental_providerMetadata\n                                    };\n                                }\n                            case \"image\":\n                                {\n                                    if (part.image instanceof URL) {\n                                        if (downloadedImages == null) {\n                                            return {\n                                                type: \"image\",\n                                                image: part.image,\n                                                mimeType: part.mimeType,\n                                                providerMetadata: part.experimental_providerMetadata\n                                            };\n                                        } else {\n                                            const downloadedImage = downloadedImages[part.image.toString()];\n                                            return {\n                                                type: \"image\",\n                                                image: downloadedImage.data,\n                                                mimeType: (_a8 = part.mimeType) != null ? _a8 : downloadedImage.mimeType,\n                                                providerMetadata: part.experimental_providerMetadata\n                                            };\n                                        }\n                                    }\n                                    if (typeof part.image === \"string\") {\n                                        try {\n                                            const url = new URL(part.image);\n                                            switch(url.protocol){\n                                                case \"http:\":\n                                                case \"https:\":\n                                                    {\n                                                        if (downloadedImages == null) {\n                                                            return {\n                                                                type: \"image\",\n                                                                image: url,\n                                                                mimeType: part.mimeType,\n                                                                providerMetadata: part.experimental_providerMetadata\n                                                            };\n                                                        } else {\n                                                            const downloadedImage = downloadedImages[part.image];\n                                                            return {\n                                                                type: \"image\",\n                                                                image: downloadedImage.data,\n                                                                mimeType: (_b = part.mimeType) != null ? _b : downloadedImage.mimeType,\n                                                                providerMetadata: part.experimental_providerMetadata\n                                                            };\n                                                        }\n                                                    }\n                                                case \"data:\":\n                                                    {\n                                                        try {\n                                                            const [header, base64Content] = part.image.split(\",\");\n                                                            const mimeType = header.split(\";\")[0].split(\":\")[1];\n                                                            if (mimeType == null || base64Content == null) {\n                                                                throw new Error(\"Invalid data URL format\");\n                                                            }\n                                                            return {\n                                                                type: \"image\",\n                                                                image: convertDataContentToUint8Array(base64Content),\n                                                                mimeType,\n                                                                providerMetadata: part.experimental_providerMetadata\n                                                            };\n                                                        } catch (error) {\n                                                            throw new Error(`Error processing data URL: ${(0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_8__.getErrorMessage)(message)}`);\n                                                        }\n                                                    }\n                                                default:\n                                                    {\n                                                        throw new Error(`Unsupported URL protocol: ${url.protocol}`);\n                                                    }\n                                            }\n                                        } catch (_ignored) {}\n                                    }\n                                    const imageUint8 = convertDataContentToUint8Array(part.image);\n                                    return {\n                                        type: \"image\",\n                                        image: imageUint8,\n                                        mimeType: (_c = part.mimeType) != null ? _c : detectImageMimeType(imageUint8),\n                                        providerMetadata: part.experimental_providerMetadata\n                                    };\n                                }\n                        }\n                    }),\n                    providerMetadata: message.experimental_providerMetadata\n                };\n            }\n        case \"assistant\":\n            {\n                if (typeof message.content === \"string\") {\n                    return {\n                        role: \"assistant\",\n                        content: [\n                            {\n                                type: \"text\",\n                                text: message.content\n                            }\n                        ],\n                        providerMetadata: message.experimental_providerMetadata\n                    };\n                }\n                return {\n                    role: \"assistant\",\n                    content: message.content.filter(// remove empty text parts:\n                    (part)=>part.type !== \"text\" || part.text !== \"\"),\n                    providerMetadata: message.experimental_providerMetadata\n                };\n            }\n        case \"tool\":\n            {\n                return {\n                    role: \"tool\",\n                    content: message.content.map((part)=>({\n                            type: \"tool-result\",\n                            toolCallId: part.toolCallId,\n                            toolName: part.toolName,\n                            result: part.result,\n                            providerMetadata: part.experimental_providerMetadata\n                        })),\n                    providerMetadata: message.experimental_providerMetadata\n                };\n            }\n        default:\n            {\n                const _exhaustiveCheck = role;\n                throw new InvalidMessageRoleError({\n                    role: _exhaustiveCheck\n                });\n            }\n    }\n}\nasync function downloadImages(messages, downloadImplementation) {\n    const urls = messages.filter((message)=>message.role === \"user\").map((message)=>message.content).filter((content)=>Array.isArray(content)).flat().filter((part)=>part.type === \"image\").map((part)=>part.image).map((part)=>// support string urls in image parts:\n        typeof part === \"string\" && (part.startsWith(\"http:\") || part.startsWith(\"https:\")) ? new URL(part) : part).filter((image)=>image instanceof URL);\n    const downloadedImages = await Promise.all(urls.map(async (url)=>({\n            url,\n            data: await downloadImplementation({\n                url\n            })\n        })));\n    return Object.fromEntries(downloadedImages.map(({ url, data })=>[\n            url.toString(),\n            data\n        ]));\n}\n// core/prompt/get-validated-prompt.ts\n\nfunction getValidatedPrompt(prompt) {\n    if (prompt.prompt == null && prompt.messages == null) {\n        throw new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_7__.InvalidPromptError({\n            prompt,\n            message: \"prompt or messages must be defined\"\n        });\n    }\n    if (prompt.prompt != null && prompt.messages != null) {\n        throw new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_7__.InvalidPromptError({\n            prompt,\n            message: \"prompt and messages cannot be defined at the same time\"\n        });\n    }\n    if (prompt.messages != null) {\n        for (const message of prompt.messages){\n            if (message.role === \"system\" && typeof message.content !== \"string\") {\n                throw new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_7__.InvalidPromptError({\n                    prompt,\n                    message: \"system message content must be a string\"\n                });\n            }\n        }\n    }\n    return prompt.prompt != null ? {\n        type: \"prompt\",\n        prompt: prompt.prompt,\n        messages: void 0,\n        system: prompt.system\n    } : {\n        type: \"messages\",\n        prompt: void 0,\n        messages: prompt.messages,\n        // only possible case bc of checks above\n        system: prompt.system\n    };\n}\n// errors/invalid-argument-error.ts\n\nvar name4 = \"AI_InvalidArgumentError\";\nvar marker4 = `vercel.ai.error.${name4}`;\nvar symbol4 = Symbol.for(marker4);\nvar _a4;\nvar InvalidArgumentError = class extends _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_7__.AISDKError {\n    constructor({ parameter, value, message }){\n        super({\n            name: name4,\n            message: `Invalid argument for parameter ${parameter}: ${message}`\n        });\n        this[_a4] = true;\n        this.parameter = parameter;\n        this.value = value;\n    }\n    static isInstance(error) {\n        return _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_7__.AISDKError.hasMarker(error, marker4);\n    }\n    /**\n   * @deprecated use `isInstance` instead\n   */ static isInvalidArgumentError(error) {\n        return error instanceof Error && error.name === name4 && typeof error.parameter === \"string\" && typeof error.value === \"string\";\n    }\n    toJSON() {\n        return {\n            name: this.name,\n            message: this.message,\n            stack: this.stack,\n            parameter: this.parameter,\n            value: this.value\n        };\n    }\n};\n_a4 = symbol4;\n// core/prompt/prepare-call-settings.ts\nfunction prepareCallSettings({ maxTokens, temperature, topP, presencePenalty, frequencyPenalty, stopSequences, seed, maxRetries }) {\n    if (maxTokens != null) {\n        if (!Number.isInteger(maxTokens)) {\n            throw new InvalidArgumentError({\n                parameter: \"maxTokens\",\n                value: maxTokens,\n                message: \"maxTokens must be an integer\"\n            });\n        }\n        if (maxTokens < 1) {\n            throw new InvalidArgumentError({\n                parameter: \"maxTokens\",\n                value: maxTokens,\n                message: \"maxTokens must be >= 1\"\n            });\n        }\n    }\n    if (temperature != null) {\n        if (typeof temperature !== \"number\") {\n            throw new InvalidArgumentError({\n                parameter: \"temperature\",\n                value: temperature,\n                message: \"temperature must be a number\"\n            });\n        }\n    }\n    if (topP != null) {\n        if (typeof topP !== \"number\") {\n            throw new InvalidArgumentError({\n                parameter: \"topP\",\n                value: topP,\n                message: \"topP must be a number\"\n            });\n        }\n    }\n    if (presencePenalty != null) {\n        if (typeof presencePenalty !== \"number\") {\n            throw new InvalidArgumentError({\n                parameter: \"presencePenalty\",\n                value: presencePenalty,\n                message: \"presencePenalty must be a number\"\n            });\n        }\n    }\n    if (frequencyPenalty != null) {\n        if (typeof frequencyPenalty !== \"number\") {\n            throw new InvalidArgumentError({\n                parameter: \"frequencyPenalty\",\n                value: frequencyPenalty,\n                message: \"frequencyPenalty must be a number\"\n            });\n        }\n    }\n    if (seed != null) {\n        if (!Number.isInteger(seed)) {\n            throw new InvalidArgumentError({\n                parameter: \"seed\",\n                value: seed,\n                message: \"seed must be an integer\"\n            });\n        }\n    }\n    if (maxRetries != null) {\n        if (!Number.isInteger(maxRetries)) {\n            throw new InvalidArgumentError({\n                parameter: \"maxRetries\",\n                value: maxRetries,\n                message: \"maxRetries must be an integer\"\n            });\n        }\n        if (maxRetries < 0) {\n            throw new InvalidArgumentError({\n                parameter: \"maxRetries\",\n                value: maxRetries,\n                message: \"maxRetries must be >= 0\"\n            });\n        }\n    }\n    return {\n        maxTokens,\n        temperature: temperature != null ? temperature : 0,\n        topP,\n        presencePenalty,\n        frequencyPenalty,\n        stopSequences: stopSequences != null && stopSequences.length > 0 ? stopSequences : void 0,\n        seed,\n        maxRetries: maxRetries != null ? maxRetries : 2\n    };\n}\n// core/prompt/prepare-tools-and-tool-choice.ts\n\n// core/util/is-non-empty-object.ts\nfunction isNonEmptyObject(object) {\n    return object != null && Object.keys(object).length > 0;\n}\n// core/prompt/prepare-tools-and-tool-choice.ts\nfunction prepareToolsAndToolChoice({ tools, toolChoice }) {\n    if (!isNonEmptyObject(tools)) {\n        return {\n            tools: void 0,\n            toolChoice: void 0\n        };\n    }\n    return {\n        tools: Object.entries(tools).map(([name8, tool])=>({\n                type: \"function\",\n                name: name8,\n                description: tool.description,\n                parameters: (0,_ai_sdk_ui_utils__WEBPACK_IMPORTED_MODULE_9__.asSchema)(tool.parameters).jsonSchema\n            })),\n        toolChoice: toolChoice == null ? {\n            type: \"auto\"\n        } : typeof toolChoice === \"string\" ? {\n            type: toolChoice\n        } : {\n            type: \"tool\",\n            toolName: toolChoice.toolName\n        }\n    };\n}\n// core/types/token-usage.ts\nfunction calculateCompletionTokenUsage(usage) {\n    return {\n        promptTokens: usage.promptTokens,\n        completionTokens: usage.completionTokens,\n        totalTokens: usage.promptTokens + usage.completionTokens\n    };\n}\n// errors/invalid-tool-arguments-error.ts\n\nvar name5 = \"AI_InvalidToolArgumentsError\";\nvar marker5 = `vercel.ai.error.${name5}`;\nvar symbol5 = Symbol.for(marker5);\nvar _a5;\nvar InvalidToolArgumentsError = class extends _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_7__.AISDKError {\n    constructor({ toolArgs, toolName, cause, message = `Invalid arguments for tool ${toolName}: ${(0,_ai_sdk_provider__WEBPACK_IMPORTED_MODULE_7__.getErrorMessage)(cause)}` }){\n        super({\n            name: name5,\n            message,\n            cause\n        });\n        this[_a5] = true;\n        this.toolArgs = toolArgs;\n        this.toolName = toolName;\n    }\n    static isInstance(error) {\n        return _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_7__.AISDKError.hasMarker(error, marker5);\n    }\n    /**\n   * @deprecated use `isInstance` instead\n   */ static isInvalidToolArgumentsError(error) {\n        return error instanceof Error && error.name === name5 && typeof error.toolName === \"string\" && typeof error.toolArgs === \"string\";\n    }\n    /**\n   * @deprecated Do not use this method. It will be removed in the next major version.\n   */ toJSON() {\n        return {\n            name: this.name,\n            message: this.message,\n            cause: this.cause,\n            stack: this.stack,\n            toolName: this.toolName,\n            toolArgs: this.toolArgs\n        };\n    }\n};\n_a5 = symbol5;\n// errors/no-such-tool-error.ts\n\nvar name6 = \"AI_NoSuchToolError\";\nvar marker6 = `vercel.ai.error.${name6}`;\nvar symbol6 = Symbol.for(marker6);\nvar _a6;\nvar NoSuchToolError = class extends _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_7__.AISDKError {\n    constructor({ toolName, availableTools = void 0, message = `Model tried to call unavailable tool '${toolName}'. ${availableTools === void 0 ? \"No tools are available.\" : `Available tools: ${availableTools.join(\", \")}.`}` }){\n        super({\n            name: name6,\n            message\n        });\n        this[_a6] = true;\n        this.toolName = toolName;\n        this.availableTools = availableTools;\n    }\n    static isInstance(error) {\n        return _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_7__.AISDKError.hasMarker(error, marker6);\n    }\n    /**\n   * @deprecated use `isInstance` instead\n   */ static isNoSuchToolError(error) {\n        return error instanceof Error && error.name === name6 && \"toolName\" in error && error.toolName != void 0 && typeof error.name === \"string\";\n    }\n    /**\n   * @deprecated Do not use this method. It will be removed in the next major version.\n   */ toJSON() {\n        return {\n            name: this.name,\n            message: this.message,\n            stack: this.stack,\n            toolName: this.toolName,\n            availableTools: this.availableTools\n        };\n    }\n};\n_a6 = symbol6;\n// util/is-async-generator.ts\nfunction isAsyncGenerator(value) {\n    return value != null && typeof value === \"object\" && Symbol.asyncIterator in value;\n}\n// util/is-generator.ts\nfunction isGenerator(value) {\n    return value != null && typeof value === \"object\" && Symbol.iterator in value;\n}\n// util/retry-with-exponential-backoff.ts\n\n\n// util/delay.ts\nasync function delay(delayInMs) {\n    return delayInMs === void 0 ? Promise.resolve() : new Promise((resolve)=>setTimeout(resolve, delayInMs));\n}\n// util/retry-error.ts\n\nvar name7 = \"AI_RetryError\";\nvar marker7 = `vercel.ai.error.${name7}`;\nvar symbol7 = Symbol.for(marker7);\nvar _a7;\nvar RetryError = class extends _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_7__.AISDKError {\n    constructor({ message, reason, errors }){\n        super({\n            name: name7,\n            message\n        });\n        this[_a7] = true;\n        this.reason = reason;\n        this.errors = errors;\n        this.lastError = errors[errors.length - 1];\n    }\n    static isInstance(error) {\n        return _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_7__.AISDKError.hasMarker(error, marker7);\n    }\n    /**\n   * @deprecated use `isInstance` instead\n   */ static isRetryError(error) {\n        return error instanceof Error && error.name === name7 && typeof error.reason === \"string\" && Array.isArray(error.errors);\n    }\n    /**\n   * @deprecated Do not use this method. It will be removed in the next major version.\n   */ toJSON() {\n        return {\n            name: this.name,\n            message: this.message,\n            reason: this.reason,\n            lastError: this.lastError,\n            errors: this.errors\n        };\n    }\n};\n_a7 = symbol7;\n// util/retry-with-exponential-backoff.ts\nvar retryWithExponentialBackoff = ({ maxRetries = 2, initialDelayInMs = 2e3, backoffFactor = 2 } = {})=>async (f)=>_retryWithExponentialBackoff(f, {\n            maxRetries,\n            delayInMs: initialDelayInMs,\n            backoffFactor\n        });\nasync function _retryWithExponentialBackoff(f, { maxRetries, delayInMs, backoffFactor }, errors = []) {\n    try {\n        return await f();\n    } catch (error) {\n        if ((0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_8__.isAbortError)(error)) {\n            throw error;\n        }\n        if (maxRetries === 0) {\n            throw error;\n        }\n        const errorMessage = (0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_8__.getErrorMessage)(error);\n        const newErrors = [\n            ...errors,\n            error\n        ];\n        const tryNumber = newErrors.length;\n        if (tryNumber > maxRetries) {\n            throw new RetryError({\n                message: `Failed after ${tryNumber} attempts. Last error: ${errorMessage}`,\n                reason: \"maxRetriesExceeded\",\n                errors: newErrors\n            });\n        }\n        if (error instanceof Error && _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_7__.APICallError.isAPICallError(error) && error.isRetryable === true && tryNumber <= maxRetries) {\n            await delay(delayInMs);\n            return _retryWithExponentialBackoff(f, {\n                maxRetries,\n                delayInMs: backoffFactor * delayInMs,\n                backoffFactor\n            }, newErrors);\n        }\n        if (tryNumber === 1) {\n            throw error;\n        }\n        throw new RetryError({\n            message: `Failed after ${tryNumber} attempts with non-retryable error: '${errorMessage}'`,\n            reason: \"errorNotRetryable\",\n            errors: newErrors\n        });\n    }\n}\n// util/constants.ts\nvar HANGING_STREAM_WARNING_TIME_MS = 15 * 1e3;\n// rsc/streamable-ui/create-suspended-chunk.tsx\n\n\nvar R = [\n    async ({ c: current, n: next })=>{\n        const chunk = await next;\n        if (chunk.done) {\n            return chunk.value;\n        }\n        if (chunk.append) {\n            return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_5__.jsxs)(react_jsx_runtime__WEBPACK_IMPORTED_MODULE_5__.Fragment, {\n                children: [\n                    current,\n                    /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_5__.jsx)(react__WEBPACK_IMPORTED_MODULE_4__.Suspense, {\n                        fallback: chunk.value,\n                        children: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_5__.jsx)(R, {\n                            c: chunk.value,\n                            n: chunk.next\n                        })\n                    })\n                ]\n            });\n        }\n        return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_5__.jsx)(react__WEBPACK_IMPORTED_MODULE_4__.Suspense, {\n            fallback: chunk.value,\n            children: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_5__.jsx)(R, {\n                c: chunk.value,\n                n: chunk.next\n            })\n        });\n    }\n][0];\nfunction createSuspendedChunk(initialValue) {\n    const { promise, resolve, reject } = createResolvablePromise();\n    return {\n        row: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_5__.jsx)(react__WEBPACK_IMPORTED_MODULE_4__.Suspense, {\n            fallback: initialValue,\n            children: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_5__.jsx)(R, {\n                c: initialValue,\n                n: promise\n            })\n        }),\n        resolve,\n        reject\n    };\n}\n// rsc/streamable-ui/create-streamable-ui.tsx\nfunction createStreamableUI(initialValue) {\n    let currentValue = initialValue;\n    let closed = false;\n    let { row, resolve, reject } = createSuspendedChunk(initialValue);\n    function assertStream(method) {\n        if (closed) {\n            throw new Error(method + \": UI stream is already closed.\");\n        }\n    }\n    let warningTimeout;\n    function warnUnclosedStream() {\n        if (true) {\n            if (warningTimeout) {\n                clearTimeout(warningTimeout);\n            }\n            warningTimeout = setTimeout(()=>{\n                console.warn(\"The streamable UI has been slow to update. This may be a bug or a performance issue or you forgot to call `.done()`.\");\n            }, HANGING_STREAM_WARNING_TIME_MS);\n        }\n    }\n    warnUnclosedStream();\n    const streamable2 = {\n        value: row,\n        update (value) {\n            assertStream(\".update()\");\n            if (value === currentValue) {\n                warnUnclosedStream();\n                return streamable2;\n            }\n            const resolvable = createResolvablePromise();\n            currentValue = value;\n            resolve({\n                value: currentValue,\n                done: false,\n                next: resolvable.promise\n            });\n            resolve = resolvable.resolve;\n            reject = resolvable.reject;\n            warnUnclosedStream();\n            return streamable2;\n        },\n        append (value) {\n            assertStream(\".append()\");\n            const resolvable = createResolvablePromise();\n            currentValue = value;\n            resolve({\n                value,\n                done: false,\n                append: true,\n                next: resolvable.promise\n            });\n            resolve = resolvable.resolve;\n            reject = resolvable.reject;\n            warnUnclosedStream();\n            return streamable2;\n        },\n        error (error) {\n            assertStream(\".error()\");\n            if (warningTimeout) {\n                clearTimeout(warningTimeout);\n            }\n            closed = true;\n            reject(error);\n            return streamable2;\n        },\n        done (...args) {\n            assertStream(\".done()\");\n            if (warningTimeout) {\n                clearTimeout(warningTimeout);\n            }\n            closed = true;\n            if (args.length) {\n                resolve({\n                    value: args[0],\n                    done: true\n                });\n                return streamable2;\n            }\n            resolve({\n                value: currentValue,\n                done: true\n            });\n            return streamable2;\n        }\n    };\n    return streamable2;\n}\n// rsc/stream-ui/stream-ui.tsx\nvar defaultTextRenderer = ({ content })=>content;\nasync function streamUI({ model, tools, toolChoice, system, prompt, messages, maxRetries, abortSignal, headers, initial, text, onFinish, ...settings }) {\n    if (typeof model === \"string\") {\n        throw new Error(\"`model` cannot be a string in `streamUI`. Use the actual model instance instead.\");\n    }\n    if (\"functions\" in settings) {\n        throw new Error(\"`functions` is not supported in `streamUI`, use `tools` instead.\");\n    }\n    if (\"provider\" in settings) {\n        throw new Error(\"`provider` is no longer needed in `streamUI`. Use `model` instead.\");\n    }\n    if (tools) {\n        for (const [name8, tool] of Object.entries(tools)){\n            if (\"render\" in tool) {\n                throw new Error(\"Tool definition in `streamUI` should not have `render` property. Use `generate` instead. Found in tool: \" + name8);\n            }\n        }\n    }\n    const ui = createStreamableUI(initial);\n    const textRender = text || defaultTextRenderer;\n    let finished;\n    async function render2({ args, renderer, streamableUI, isLastCall = false }) {\n        if (!renderer) return;\n        const renderFinished = createResolvablePromise();\n        finished = finished ? finished.then(()=>renderFinished.promise) : renderFinished.promise;\n        const rendererResult = renderer(...args);\n        if (isAsyncGenerator(rendererResult) || isGenerator(rendererResult)) {\n            while(true){\n                const { done, value } = await rendererResult.next();\n                const node = await value;\n                if (isLastCall && done) {\n                    streamableUI.done(node);\n                } else {\n                    streamableUI.update(node);\n                }\n                if (done) break;\n            }\n        } else {\n            const node = await rendererResult;\n            if (isLastCall) {\n                streamableUI.done(node);\n            } else {\n                streamableUI.update(node);\n            }\n        }\n        renderFinished.resolve(void 0);\n    }\n    const retry = retryWithExponentialBackoff({\n        maxRetries\n    });\n    const validatedPrompt = getValidatedPrompt({\n        system,\n        prompt,\n        messages\n    });\n    const result = await retry(async ()=>model.doStream({\n            mode: {\n                type: \"regular\",\n                ...prepareToolsAndToolChoice({\n                    tools,\n                    toolChoice\n                })\n            },\n            ...prepareCallSettings(settings),\n            inputFormat: validatedPrompt.type,\n            prompt: await convertToLanguageModelPrompt({\n                prompt: validatedPrompt,\n                modelSupportsImageUrls: model.supportsImageUrls\n            }),\n            abortSignal,\n            headers\n        }));\n    const [stream, forkedStream] = result.stream.tee();\n    (async ()=>{\n        try {\n            let content = \"\";\n            let hasToolCall = false;\n            const reader = forkedStream.getReader();\n            while(true){\n                const { done, value } = await reader.read();\n                if (done) break;\n                switch(value.type){\n                    case \"text-delta\":\n                        {\n                            content += value.textDelta;\n                            render2({\n                                renderer: textRender,\n                                args: [\n                                    {\n                                        content,\n                                        done: false,\n                                        delta: value.textDelta\n                                    }\n                                ],\n                                streamableUI: ui\n                            });\n                            break;\n                        }\n                    case \"tool-call-delta\":\n                        {\n                            hasToolCall = true;\n                            break;\n                        }\n                    case \"tool-call\":\n                        {\n                            const toolName = value.toolName;\n                            if (!tools) {\n                                throw new NoSuchToolError({\n                                    toolName\n                                });\n                            }\n                            const tool = tools[toolName];\n                            if (!tool) {\n                                throw new NoSuchToolError({\n                                    toolName,\n                                    availableTools: Object.keys(tools)\n                                });\n                            }\n                            hasToolCall = true;\n                            const parseResult = (0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_8__.safeParseJSON)({\n                                text: value.args,\n                                schema: tool.parameters\n                            });\n                            if (parseResult.success === false) {\n                                throw new InvalidToolArgumentsError({\n                                    toolName,\n                                    toolArgs: value.args,\n                                    cause: parseResult.error\n                                });\n                            }\n                            render2({\n                                renderer: tool.generate,\n                                args: [\n                                    parseResult.value,\n                                    {\n                                        toolName,\n                                        toolCallId: value.toolCallId\n                                    }\n                                ],\n                                streamableUI: ui,\n                                isLastCall: true\n                            });\n                            break;\n                        }\n                    case \"error\":\n                        {\n                            throw value.error;\n                        }\n                    case \"finish\":\n                        {\n                            onFinish == null ? void 0 : onFinish({\n                                finishReason: value.finishReason,\n                                usage: calculateCompletionTokenUsage(value.usage),\n                                value: ui.value,\n                                warnings: result.warnings,\n                                rawResponse: result.rawResponse\n                            });\n                        }\n                }\n            }\n            if (!hasToolCall) {\n                render2({\n                    renderer: textRender,\n                    args: [\n                        {\n                            content,\n                            done: true\n                        }\n                    ],\n                    streamableUI: ui,\n                    isLastCall: true\n                });\n            }\n            await finished;\n        } catch (error) {\n            ui.error(error);\n        }\n    })();\n    return {\n        ...result,\n        stream,\n        value: ui.value\n    };\n}\n// rsc/stream-ui/render.ts\n\n// streams/ai-stream.ts\n\nfunction createEventStreamTransformer(customParser) {\n    const textDecoder = new TextDecoder();\n    let eventSourceParser;\n    return new TransformStream({\n        async start (controller) {\n            eventSourceParser = (0,eventsource_parser__WEBPACK_IMPORTED_MODULE_11__.createParser)((event)=>{\n                if (\"data\" in event && event.type === \"event\" && event.data === \"[DONE]\" || // Replicate doesn't send [DONE] but does send a 'done' event\n                // @see https://replicate.com/docs/streaming\n                event.event === \"done\") {\n                    controller.terminate();\n                    return;\n                }\n                if (\"data\" in event) {\n                    const parsedMessage = customParser ? customParser(event.data, {\n                        event: event.event\n                    }) : event.data;\n                    if (parsedMessage) controller.enqueue(parsedMessage);\n                }\n            });\n        },\n        transform (chunk) {\n            eventSourceParser.feed(textDecoder.decode(chunk));\n        }\n    });\n}\nfunction createCallbacksTransformer(cb) {\n    const textEncoder = new TextEncoder();\n    let aggregatedResponse = \"\";\n    const callbacks = cb || {};\n    return new TransformStream({\n        async start () {\n            if (callbacks.onStart) await callbacks.onStart();\n        },\n        async transform (message, controller) {\n            const content = typeof message === \"string\" ? message : message.content;\n            controller.enqueue(textEncoder.encode(content));\n            aggregatedResponse += content;\n            if (callbacks.onToken) await callbacks.onToken(content);\n            if (callbacks.onText && typeof message === \"string\") {\n                await callbacks.onText(message);\n            }\n        },\n        async flush () {\n            const isOpenAICallbacks = isOfTypeOpenAIStreamCallbacks(callbacks);\n            if (callbacks.onCompletion) {\n                await callbacks.onCompletion(aggregatedResponse);\n            }\n            if (callbacks.onFinal && !isOpenAICallbacks) {\n                await callbacks.onFinal(aggregatedResponse);\n            }\n        }\n    });\n}\nfunction isOfTypeOpenAIStreamCallbacks(callbacks) {\n    return \"experimental_onFunctionCall\" in callbacks;\n}\nfunction trimStartOfStreamHelper() {\n    let isStreamStart = true;\n    return (text)=>{\n        if (isStreamStart) {\n            text = text.trimStart();\n            if (text) isStreamStart = false;\n        }\n        return text;\n    };\n}\nfunction AIStream(response, customParser, callbacks) {\n    if (!response.ok) {\n        if (response.body) {\n            const reader = response.body.getReader();\n            return new ReadableStream({\n                async start (controller) {\n                    const { done, value } = await reader.read();\n                    if (!done) {\n                        const errorText = new TextDecoder().decode(value);\n                        controller.error(new Error(`Response error: ${errorText}`));\n                    }\n                }\n            });\n        } else {\n            return new ReadableStream({\n                start (controller) {\n                    controller.error(new Error(\"Response error: No response body\"));\n                }\n            });\n        }\n    }\n    const responseBodyStream = response.body || createEmptyReadableStream();\n    return responseBodyStream.pipeThrough(createEventStreamTransformer(customParser)).pipeThrough(createCallbacksTransformer(callbacks));\n}\nfunction createEmptyReadableStream() {\n    return new ReadableStream({\n        start (controller) {\n            controller.close();\n        }\n    });\n}\nfunction readableFromAsyncIterable(iterable) {\n    let it = iterable[Symbol.asyncIterator]();\n    return new ReadableStream({\n        async pull (controller) {\n            const { done, value } = await it.next();\n            if (done) controller.close();\n            else controller.enqueue(value);\n        },\n        async cancel (reason) {\n            var _a8;\n            await ((_a8 = it.return) == null ? void 0 : _a8.call(it, reason));\n        }\n    });\n}\n// streams/stream-data.ts\n\nfunction createStreamDataTransformer() {\n    const encoder = new TextEncoder();\n    const decoder = new TextDecoder();\n    return new TransformStream({\n        transform: async (chunk, controller)=>{\n            const message = decoder.decode(chunk);\n            controller.enqueue(encoder.encode((0,_ai_sdk_ui_utils__WEBPACK_IMPORTED_MODULE_9__.formatStreamPart)(\"text\", message)));\n        }\n    });\n}\n// streams/openai-stream.ts\n\nfunction parseOpenAIStream() {\n    const extract = chunkToText();\n    return (data)=>extract(JSON.parse(data));\n}\nasync function* streamable(stream) {\n    const extract = chunkToText();\n    for await (let chunk of stream){\n        if (\"promptFilterResults\" in chunk) {\n            chunk = {\n                id: chunk.id,\n                created: chunk.created.getDate(),\n                object: chunk.object,\n                // not exposed by Azure API\n                model: chunk.model,\n                // not exposed by Azure API\n                choices: chunk.choices.map((choice)=>{\n                    var _a8, _b, _c, _d, _e, _f, _g;\n                    return {\n                        delta: {\n                            content: (_a8 = choice.delta) == null ? void 0 : _a8.content,\n                            function_call: (_b = choice.delta) == null ? void 0 : _b.functionCall,\n                            role: (_c = choice.delta) == null ? void 0 : _c.role,\n                            tool_calls: ((_e = (_d = choice.delta) == null ? void 0 : _d.toolCalls) == null ? void 0 : _e.length) ? (_g = (_f = choice.delta) == null ? void 0 : _f.toolCalls) == null ? void 0 : _g.map((toolCall, index)=>({\n                                    index,\n                                    id: toolCall.id,\n                                    function: toolCall.function,\n                                    type: toolCall.type\n                                })) : void 0\n                        },\n                        finish_reason: choice.finishReason,\n                        index: choice.index\n                    };\n                })\n            };\n        }\n        const text = extract(chunk);\n        if (text) yield text;\n    }\n}\nfunction chunkToText() {\n    const trimStartOfStream = trimStartOfStreamHelper();\n    let isFunctionStreamingIn;\n    return (json)=>{\n        var _a8, _b, _c, _d, _e, _f, _g, _h, _i, _j, _k, _l, _m, _n, _o, _p, _q, _r;\n        if (isChatCompletionChunk(json)) {\n            const delta = (_a8 = json.choices[0]) == null ? void 0 : _a8.delta;\n            if ((_b = delta.function_call) == null ? void 0 : _b.name) {\n                isFunctionStreamingIn = true;\n                return {\n                    isText: false,\n                    content: `{\"function_call\": {\"name\": \"${delta.function_call.name}\", \"arguments\": \"`\n                };\n            } else if ((_e = (_d = (_c = delta.tool_calls) == null ? void 0 : _c[0]) == null ? void 0 : _d.function) == null ? void 0 : _e.name) {\n                isFunctionStreamingIn = true;\n                const toolCall = delta.tool_calls[0];\n                if (toolCall.index === 0) {\n                    return {\n                        isText: false,\n                        content: `{\"tool_calls\":[ {\"id\": \"${toolCall.id}\", \"type\": \"function\", \"function\": {\"name\": \"${(_f = toolCall.function) == null ? void 0 : _f.name}\", \"arguments\": \"`\n                    };\n                } else {\n                    return {\n                        isText: false,\n                        content: `\"}}, {\"id\": \"${toolCall.id}\", \"type\": \"function\", \"function\": {\"name\": \"${(_g = toolCall.function) == null ? void 0 : _g.name}\", \"arguments\": \"`\n                    };\n                }\n            } else if ((_h = delta.function_call) == null ? void 0 : _h.arguments) {\n                return {\n                    isText: false,\n                    content: cleanupArguments((_i = delta.function_call) == null ? void 0 : _i.arguments)\n                };\n            } else if ((_l = (_k = (_j = delta.tool_calls) == null ? void 0 : _j[0]) == null ? void 0 : _k.function) == null ? void 0 : _l.arguments) {\n                return {\n                    isText: false,\n                    content: cleanupArguments((_o = (_n = (_m = delta.tool_calls) == null ? void 0 : _m[0]) == null ? void 0 : _n.function) == null ? void 0 : _o.arguments)\n                };\n            } else if (isFunctionStreamingIn && (((_p = json.choices[0]) == null ? void 0 : _p.finish_reason) === \"function_call\" || ((_q = json.choices[0]) == null ? void 0 : _q.finish_reason) === \"stop\")) {\n                isFunctionStreamingIn = false;\n                return {\n                    isText: false,\n                    content: '\"}}'\n                };\n            } else if (isFunctionStreamingIn && ((_r = json.choices[0]) == null ? void 0 : _r.finish_reason) === \"tool_calls\") {\n                isFunctionStreamingIn = false;\n                return {\n                    isText: false,\n                    content: '\"}}]}'\n                };\n            }\n        }\n        const text = trimStartOfStream(isChatCompletionChunk(json) && json.choices[0].delta.content ? json.choices[0].delta.content : isCompletion(json) ? json.choices[0].text : \"\");\n        return text;\n    };\n    function cleanupArguments(argumentChunk) {\n        let escapedPartialJson = argumentChunk.replace(/\\\\/g, \"\\\\\\\\\").replace(/\\//g, \"\\\\/\").replace(/\"/g, '\\\\\"').replace(/\\n/g, \"\\\\n\").replace(/\\r/g, \"\\\\r\").replace(/\\t/g, \"\\\\t\").replace(/\\f/g, \"\\\\f\");\n        return `${escapedPartialJson}`;\n    }\n}\nvar __internal__OpenAIFnMessagesSymbol = Symbol(\"internal_openai_fn_messages\");\nfunction isChatCompletionChunk(data) {\n    return \"choices\" in data && data.choices && data.choices[0] && \"delta\" in data.choices[0];\n}\nfunction isCompletion(data) {\n    return \"choices\" in data && data.choices && data.choices[0] && \"text\" in data.choices[0];\n}\nfunction OpenAIStream(res, callbacks) {\n    const cb = callbacks;\n    let stream;\n    if (Symbol.asyncIterator in res) {\n        stream = readableFromAsyncIterable(streamable(res)).pipeThrough(createCallbacksTransformer((cb == null ? void 0 : cb.experimental_onFunctionCall) || (cb == null ? void 0 : cb.experimental_onToolCall) ? {\n            ...cb,\n            onFinal: void 0\n        } : {\n            ...cb\n        }));\n    } else {\n        stream = AIStream(res, parseOpenAIStream(), (cb == null ? void 0 : cb.experimental_onFunctionCall) || (cb == null ? void 0 : cb.experimental_onToolCall) ? {\n            ...cb,\n            onFinal: void 0\n        } : {\n            ...cb\n        });\n    }\n    if (cb && (cb.experimental_onFunctionCall || cb.experimental_onToolCall)) {\n        const functionCallTransformer = createFunctionCallTransformer(cb);\n        return stream.pipeThrough(functionCallTransformer);\n    } else {\n        return stream.pipeThrough(createStreamDataTransformer());\n    }\n}\nfunction createFunctionCallTransformer(callbacks) {\n    const textEncoder = new TextEncoder();\n    let isFirstChunk = true;\n    let aggregatedResponse = \"\";\n    let aggregatedFinalCompletionResponse = \"\";\n    let isFunctionStreamingIn = false;\n    let functionCallMessages = callbacks[__internal__OpenAIFnMessagesSymbol] || [];\n    const decode = (0,_ai_sdk_ui_utils__WEBPACK_IMPORTED_MODULE_9__.createChunkDecoder)();\n    return new TransformStream({\n        async transform (chunk, controller) {\n            const message = decode(chunk);\n            aggregatedFinalCompletionResponse += message;\n            const shouldHandleAsFunction = isFirstChunk && (message.startsWith('{\"function_call\":') || message.startsWith('{\"tool_calls\":'));\n            if (shouldHandleAsFunction) {\n                isFunctionStreamingIn = true;\n                aggregatedResponse += message;\n                isFirstChunk = false;\n                return;\n            }\n            if (!isFunctionStreamingIn) {\n                controller.enqueue(textEncoder.encode((0,_ai_sdk_ui_utils__WEBPACK_IMPORTED_MODULE_9__.formatStreamPart)(\"text\", message)));\n                return;\n            } else {\n                aggregatedResponse += message;\n            }\n        },\n        async flush (controller) {\n            try {\n                if (!isFirstChunk && isFunctionStreamingIn && (callbacks.experimental_onFunctionCall || callbacks.experimental_onToolCall)) {\n                    isFunctionStreamingIn = false;\n                    const payload = JSON.parse(aggregatedResponse);\n                    let newFunctionCallMessages = [\n                        ...functionCallMessages\n                    ];\n                    let functionResponse = void 0;\n                    if (callbacks.experimental_onFunctionCall) {\n                        if (payload.function_call === void 0) {\n                            console.warn(\"experimental_onFunctionCall should not be defined when using tools\");\n                        }\n                        const argumentsPayload = JSON.parse(payload.function_call.arguments);\n                        functionResponse = await callbacks.experimental_onFunctionCall({\n                            name: payload.function_call.name,\n                            arguments: argumentsPayload\n                        }, (result)=>{\n                            newFunctionCallMessages = [\n                                ...functionCallMessages,\n                                {\n                                    role: \"assistant\",\n                                    content: \"\",\n                                    function_call: payload.function_call\n                                },\n                                {\n                                    role: \"function\",\n                                    name: payload.function_call.name,\n                                    content: JSON.stringify(result)\n                                }\n                            ];\n                            return newFunctionCallMessages;\n                        });\n                    }\n                    if (callbacks.experimental_onToolCall) {\n                        const toolCalls = {\n                            tools: []\n                        };\n                        for (const tool of payload.tool_calls){\n                            toolCalls.tools.push({\n                                id: tool.id,\n                                type: \"function\",\n                                func: {\n                                    name: tool.function.name,\n                                    arguments: JSON.parse(tool.function.arguments)\n                                }\n                            });\n                        }\n                        let responseIndex = 0;\n                        try {\n                            functionResponse = await callbacks.experimental_onToolCall(toolCalls, (result)=>{\n                                if (result) {\n                                    const { tool_call_id, function_name, tool_call_result } = result;\n                                    newFunctionCallMessages = [\n                                        ...newFunctionCallMessages,\n                                        // Only append the assistant message if it's the first response\n                                        ...responseIndex === 0 ? [\n                                            {\n                                                role: \"assistant\",\n                                                content: \"\",\n                                                tool_calls: payload.tool_calls.map((tc)=>({\n                                                        id: tc.id,\n                                                        type: \"function\",\n                                                        function: {\n                                                            name: tc.function.name,\n                                                            // we send the arguments an object to the user, but as the API expects a string, we need to stringify it\n                                                            arguments: JSON.stringify(tc.function.arguments)\n                                                        }\n                                                    }))\n                                            }\n                                        ] : [],\n                                        // Append the function call result message\n                                        {\n                                            role: \"tool\",\n                                            tool_call_id,\n                                            name: function_name,\n                                            content: JSON.stringify(tool_call_result)\n                                        }\n                                    ];\n                                    responseIndex++;\n                                }\n                                return newFunctionCallMessages;\n                            });\n                        } catch (e) {\n                            console.error(\"Error calling experimental_onToolCall:\", e);\n                        }\n                    }\n                    if (!functionResponse) {\n                        controller.enqueue(textEncoder.encode((0,_ai_sdk_ui_utils__WEBPACK_IMPORTED_MODULE_9__.formatStreamPart)(payload.function_call ? \"function_call\" : \"tool_calls\", // parse to prevent double-encoding:\n                        JSON.parse(aggregatedResponse))));\n                        return;\n                    } else if (typeof functionResponse === \"string\") {\n                        controller.enqueue(textEncoder.encode((0,_ai_sdk_ui_utils__WEBPACK_IMPORTED_MODULE_9__.formatStreamPart)(\"text\", functionResponse)));\n                        aggregatedFinalCompletionResponse = functionResponse;\n                        return;\n                    }\n                    const filteredCallbacks = {\n                        ...callbacks,\n                        onStart: void 0\n                    };\n                    callbacks.onFinal = void 0;\n                    const openAIStream = OpenAIStream(functionResponse, {\n                        ...filteredCallbacks,\n                        [__internal__OpenAIFnMessagesSymbol]: newFunctionCallMessages\n                    });\n                    const reader = openAIStream.getReader();\n                    while(true){\n                        const { done, value } = await reader.read();\n                        if (done) {\n                            break;\n                        }\n                        controller.enqueue(value);\n                    }\n                }\n            } finally{\n                if (callbacks.onFinal && aggregatedFinalCompletionResponse) {\n                    await callbacks.onFinal(aggregatedFinalCompletionResponse);\n                }\n            }\n        }\n    });\n}\n// util/consume-stream.ts\nasync function consumeStream(stream) {\n    const reader = stream.getReader();\n    while(true){\n        const { done } = await reader.read();\n        if (done) break;\n    }\n}\n// rsc/stream-ui/render.ts\nfunction render(options) {\n    const ui = createStreamableUI(options.initial);\n    const text = options.text ? options.text : ({ content })=>content;\n    const functions = options.functions ? Object.entries(options.functions).map(([name8, { description, parameters }])=>{\n        return {\n            name: name8,\n            description,\n            parameters: (0,zod_to_json_schema__WEBPACK_IMPORTED_MODULE_10__[\"default\"])(parameters)\n        };\n    }) : void 0;\n    const tools = options.tools ? Object.entries(options.tools).map(([name8, { description, parameters }])=>{\n        return {\n            type: \"function\",\n            function: {\n                name: name8,\n                description,\n                parameters: (0,zod_to_json_schema__WEBPACK_IMPORTED_MODULE_10__[\"default\"])(parameters)\n            }\n        };\n    }) : void 0;\n    if (functions && tools) {\n        throw new Error(\"You can't have both functions and tools defined. Please choose one or the other.\");\n    }\n    let finished;\n    async function handleRender(args, renderer, res) {\n        if (!renderer) return;\n        const resolvable = createResolvablePromise();\n        if (finished) {\n            finished = finished.then(()=>resolvable.promise);\n        } else {\n            finished = resolvable.promise;\n        }\n        const value = renderer(args);\n        if (value instanceof Promise || value && typeof value === \"object\" && \"then\" in value && typeof value.then === \"function\") {\n            const node = await value;\n            res.update(node);\n            resolvable.resolve(void 0);\n        } else if (value && typeof value === \"object\" && Symbol.asyncIterator in value) {\n            const it = value;\n            while(true){\n                const { done, value: value2 } = await it.next();\n                res.update(value2);\n                if (done) break;\n            }\n            resolvable.resolve(void 0);\n        } else if (value && typeof value === \"object\" && Symbol.iterator in value) {\n            const it = value;\n            while(true){\n                const { done, value: value2 } = it.next();\n                res.update(value2);\n                if (done) break;\n            }\n            resolvable.resolve(void 0);\n        } else {\n            res.update(value);\n            resolvable.resolve(void 0);\n        }\n    }\n    (async ()=>{\n        let hasFunction = false;\n        let content = \"\";\n        consumeStream(OpenAIStream(await options.provider.chat.completions.create({\n            model: options.model,\n            messages: options.messages,\n            temperature: options.temperature,\n            stream: true,\n            ...functions ? {\n                functions\n            } : {},\n            ...tools ? {\n                tools\n            } : {}\n        }), {\n            ...functions ? {\n                async experimental_onFunctionCall (functionCallPayload) {\n                    var _a8, _b;\n                    hasFunction = true;\n                    handleRender(functionCallPayload.arguments, (_b = (_a8 = options.functions) == null ? void 0 : _a8[functionCallPayload.name]) == null ? void 0 : _b.render, ui);\n                }\n            } : {},\n            ...tools ? {\n                async experimental_onToolCall (toolCallPayload) {\n                    var _a8, _b;\n                    hasFunction = true;\n                    for (const tool of toolCallPayload.tools){\n                        handleRender(tool.func.arguments, (_b = (_a8 = options.tools) == null ? void 0 : _a8[tool.func.name]) == null ? void 0 : _b.render, ui);\n                    }\n                }\n            } : {},\n            onText (chunk) {\n                content += chunk;\n                handleRender({\n                    content,\n                    done: false,\n                    delta: chunk\n                }, text, ui);\n            },\n            async onFinal () {\n                if (hasFunction) {\n                    await finished;\n                    ui.done();\n                    return;\n                }\n                handleRender({\n                    content,\n                    done: true\n                }, text, ui);\n                await finished;\n                ui.done();\n            }\n        }));\n    })();\n    return ui.value;\n}\n// rsc/streamable-value/streamable-value.ts\nvar STREAMABLE_VALUE_TYPE = Symbol.for(\"ui.streamable.value\");\n// rsc/streamable-value/create-streamable-value.ts\nvar STREAMABLE_VALUE_INTERNAL_LOCK = Symbol(\"streamable.value.lock\");\nfunction createStreamableValue(initialValue) {\n    const isReadableStream = initialValue instanceof ReadableStream || typeof initialValue === \"object\" && initialValue !== null && \"getReader\" in initialValue && typeof initialValue.getReader === \"function\" && \"locked\" in initialValue && typeof initialValue.locked === \"boolean\";\n    if (!isReadableStream) {\n        return createStreamableValueImpl(initialValue);\n    }\n    const streamableValue = createStreamableValueImpl();\n    streamableValue[STREAMABLE_VALUE_INTERNAL_LOCK] = true;\n    (async ()=>{\n        try {\n            const reader = initialValue.getReader();\n            while(true){\n                const { value, done } = await reader.read();\n                if (done) {\n                    break;\n                }\n                streamableValue[STREAMABLE_VALUE_INTERNAL_LOCK] = false;\n                if (typeof value === \"string\") {\n                    streamableValue.append(value);\n                } else {\n                    streamableValue.update(value);\n                }\n                streamableValue[STREAMABLE_VALUE_INTERNAL_LOCK] = true;\n            }\n            streamableValue[STREAMABLE_VALUE_INTERNAL_LOCK] = false;\n            streamableValue.done();\n        } catch (e) {\n            streamableValue[STREAMABLE_VALUE_INTERNAL_LOCK] = false;\n            streamableValue.error(e);\n        }\n    })();\n    return streamableValue;\n}\nfunction createStreamableValueImpl(initialValue) {\n    let closed = false;\n    let locked = false;\n    let resolvable = createResolvablePromise();\n    let currentValue = initialValue;\n    let currentError;\n    let currentPromise = resolvable.promise;\n    let currentPatchValue;\n    function assertStream(method) {\n        if (closed) {\n            throw new Error(method + \": Value stream is already closed.\");\n        }\n        if (locked) {\n            throw new Error(method + \": Value stream is locked and cannot be updated.\");\n        }\n    }\n    let warningTimeout;\n    function warnUnclosedStream() {\n        if (true) {\n            if (warningTimeout) {\n                clearTimeout(warningTimeout);\n            }\n            warningTimeout = setTimeout(()=>{\n                console.warn(\"The streamable value has been slow to update. This may be a bug or a performance issue or you forgot to call `.done()`.\");\n            }, HANGING_STREAM_WARNING_TIME_MS);\n        }\n    }\n    warnUnclosedStream();\n    function createWrapped(initialChunk) {\n        let init;\n        if (currentError !== void 0) {\n            init = {\n                error: currentError\n            };\n        } else {\n            if (currentPatchValue && !initialChunk) {\n                init = {\n                    diff: currentPatchValue\n                };\n            } else {\n                init = {\n                    curr: currentValue\n                };\n            }\n        }\n        if (currentPromise) {\n            init.next = currentPromise;\n        }\n        if (initialChunk) {\n            init.type = STREAMABLE_VALUE_TYPE;\n        }\n        return init;\n    }\n    function updateValueStates(value) {\n        currentPatchValue = void 0;\n        if (typeof value === \"string\") {\n            if (typeof currentValue === \"string\") {\n                if (value.startsWith(currentValue)) {\n                    currentPatchValue = [\n                        0,\n                        value.slice(currentValue.length)\n                    ];\n                }\n            }\n        }\n        currentValue = value;\n    }\n    const streamable2 = {\n        set [STREAMABLE_VALUE_INTERNAL_LOCK] (state){\n            locked = state;\n        },\n        get value () {\n            return createWrapped(true);\n        },\n        update (value) {\n            assertStream(\".update()\");\n            const resolvePrevious = resolvable.resolve;\n            resolvable = createResolvablePromise();\n            updateValueStates(value);\n            currentPromise = resolvable.promise;\n            resolvePrevious(createWrapped());\n            warnUnclosedStream();\n            return streamable2;\n        },\n        append (value) {\n            assertStream(\".append()\");\n            if (typeof currentValue !== \"string\" && typeof currentValue !== \"undefined\") {\n                throw new Error(`.append(): The current value is not a string. Received: ${typeof currentValue}`);\n            }\n            if (typeof value !== \"string\") {\n                throw new Error(`.append(): The value is not a string. Received: ${typeof value}`);\n            }\n            const resolvePrevious = resolvable.resolve;\n            resolvable = createResolvablePromise();\n            if (typeof currentValue === \"string\") {\n                currentPatchValue = [\n                    0,\n                    value\n                ];\n                currentValue = currentValue + value;\n            } else {\n                currentPatchValue = void 0;\n                currentValue = value;\n            }\n            currentPromise = resolvable.promise;\n            resolvePrevious(createWrapped());\n            warnUnclosedStream();\n            return streamable2;\n        },\n        error (error) {\n            assertStream(\".error()\");\n            if (warningTimeout) {\n                clearTimeout(warningTimeout);\n            }\n            closed = true;\n            currentError = error;\n            currentPromise = void 0;\n            resolvable.resolve({\n                error\n            });\n            return streamable2;\n        },\n        done (...args) {\n            assertStream(\".done()\");\n            if (warningTimeout) {\n                clearTimeout(warningTimeout);\n            }\n            closed = true;\n            currentPromise = void 0;\n            if (args.length) {\n                updateValueStates(args[0]);\n                resolvable.resolve(createWrapped());\n                return streamable2;\n            }\n            resolvable.resolve({});\n            return streamable2;\n        }\n    };\n    return streamable2;\n}\n //# sourceMappingURL=rsc-server.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9haS9yc2MvZGlzdC9yc2Mtc2VydmVyLm1qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBK0I7QUFDRzs7QUNRM0IsU0FBU0U7SUFLZCxJQUFJQztJQUNKLElBQUlDO0lBRUosTUFBTUMsVUFBVSxJQUFJQyxRQUFXLENBQUNDLEtBQUtDO1FBQ25DTCxVQUFVSTtRQUNWSCxTQUFTSTtJQUNYO0lBRUEsT0FBTztRQUNMSDtRQUNBRjtRQUNBQztJQUNGO0FBQ0Y7O0FDckJPLElBQU1LLGFBQWEsQ0FBQ0MsUUFDekIsT0FBT0EsVUFBVTs7QUZPbkIsSUFBTUMsc0JBQXNCLElBQUlWLDBEQUFpQkE7QUFTakQsU0FBU1csdUJBQXVCQyxPQUFBO0lBQzlCLE1BQU1DLFFBQVFILG9CQUFvQkksUUFBQTtJQUNsQyxJQUFJLENBQUNELE9BQU87UUFDVixNQUFNLElBQUlFLE1BQU1IO0lBQ2xCO0lBQ0EsT0FBT0M7QUFDVDtBQUVPLFNBQVNHLFlBQ2QsRUFBRUMsT0FBQUEsTUFBQSxFQUFPQyxPQUFBLEVBQVEsRUFDakJDLEVBQUE7SUFFQSxPQUFPVCxvQkFBb0JVLEdBQUEsQ0FDekI7UUFDRUMsY0FBY0o7UUFDZEssZUFBZUw7UUFDZk0sUUFBUTtRQUNSTDtJQUNGLEdBQ0FDO0FBRUo7QUFFTyxTQUFTSztJQUNkLE1BQU1YLFFBQVFGLHVCQUF1QjtJQUNyQyxPQUFPRSxNQUFNWSxvQkFBQTtBQUNmO0FBS08sU0FBU0M7SUFDZCxNQUFNYixRQUFRRix1QkFBdUI7SUFDckNFLE1BQU1VLE1BQUEsR0FBUztBQUNqQjtBQWdCQSxTQUFTSSxXQUFBLEdBQ0pDLElBQUE7SUFFSCxNQUFNZixRQUFRRix1QkFDWjtJQUdGLElBQUlpQixLQUFLQyxNQUFBLEdBQVMsR0FBRztRQUNuQixNQUFNQyxNQUFNRixJQUFBLENBQUssRUFBQztRQUNsQixJQUFJLE9BQU9mLE1BQU1RLFlBQUEsS0FBaUIsVUFB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bWIsZ0JBQWdCTjtZQUVoQjNMO1lBRUEsT0FBT0s7UUFDVDtRQUNBcEssT0FBTUEsS0FBQTtZQUNKNEosYUFBYTtZQUViLElBQUlFLGdCQUFnQjtnQkFDbEJHLGFBQWFIO1lBQ2Y7WUFDQUgsU0FBUztZQUNUNEwsZUFBZXZWO1lBQ2Z3VixpQkFBaUI7WUFFakJuTCxXQUFXMVAsT0FBQSxDQUFRO2dCQUFFcUY7WUFBTTtZQUUzQixPQUFPb0s7UUFDVDtRQUNBdk4sTUFBQSxHQUFRUixJQUFBO1lBQ051TixhQUFhO1lBRWIsSUFBSUUsZ0JBQWdCO2dCQUNsQkcsYUFBYUg7WUFDZjtZQUNBSCxTQUFTO1lBQ1Q2TCxpQkFBaUI7WUFFakIsSUFBSW5aLEtBQUtDLE1BQUEsRUFBUTtnQkFDZndaLGtCQUFrQnpaLElBQUEsQ0FBSyxFQUFFO2dCQUN6QmdPLFdBQVcxUCxPQUFBLENBQVErYTtnQkFDbkIsT0FBT3RMO1lBQ1Q7WUFFQUMsV0FBVzFQLE9BQUEsQ0FBUSxDQUFDO1lBRXBCLE9BQU95UDtRQUNUO0lBQ0Y7SUFFQSxPQUFPQTtBQUNUIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vYXNrX2RvYy8uLi9haS1zdGF0ZS50c3g/MzgwMCIsIndlYnBhY2s6Ly9hc2tfZG9jLy4uLy4uL3V0aWwvY3JlYXRlLXJlc29sdmFibGUtcHJvbWlzZS50cz83NTBlIiwid2VicGFjazovL2Fza19kb2MvLi4vLi4vdXRpbC9pcy1mdW5jdGlvbi50cz8yZDRjIiwid2VicGFjazovL2Fza19kb2MvLi4vcHJvdmlkZXIudHN4PzMwZWIiLCJ3ZWJwYWNrOi8vYXNrX2RvYy8uLi9zdHJlYW0tdWkvc3RyZWFtLXVpLnRzeD8xY2NhIiwid2VicGFjazovL2Fza19kb2MvLi4vLi4vY29yZS9wcm9tcHQvY29udmVydC10by1sYW5ndWFnZS1tb2RlbC1wcm9tcHQudHM/NzE3NCIsIndlYnBhY2s6Ly9hc2tfZG9jLy4uLy4uL3V0aWwvZG93bmxvYWQtZXJyb3IudHM/NmE3NSIsIndlYnBhY2s6Ly9hc2tfZG9jLy4uLy4uL3V0aWwvZG93bmxvYWQudHM/NjdhYyIsIndlYnBhY2s6Ly9hc2tfZG9jLy4uLy4uL2NvcmUvdXRpbC9kZXRlY3QtaW1hZ2UtbWltZXR5cGUudHM/OTU0NSIsIndlYnBhY2s6Ly9hc2tfZG9jLy4uLy4uL2NvcmUvcHJvbXB0L2RhdGEtY29udGVudC50cz9lOTJmIiwid2VicGFjazovL2Fza19kb2MvLi4vLi4vY29yZS9wcm9tcHQvaW52YWxpZC1kYXRhLWNvbnRlbnQtZXJyb3IudHM/ZjJmZSIsIndlYnBhY2s6Ly9hc2tfZG9jLy4uLy4uL2NvcmUvcHJvbXB0L2ludmFsaWQtbWVzc2FnZS1yb2xlLWVycm9yLnRzPzg5NzAiLCJ3ZWJwYWNrOi8vYXNrX2RvYy8uLi8uLi9jb3JlL3Byb21wdC9nZXQtdmFsaWRhdGVkLXByb21wdC50cz81NzhlIiwid2VicGFjazovL2Fza19kb2MvLi4vLi4vZXJyb3JzL2ludmFsaWQtYXJndW1lbnQtZXJyb3IudHM/ZjQyMSIsIndlYnBhY2s6Ly9hc2tfZG9jLy4uLy4uL2NvcmUvcHJvbXB0L3ByZXBhcmUtY2FsbC1zZXR0aW5ncy50cz9kNThjIiwid2VicGFjazovL2Fza19kb2MvLi4vLi4vY29yZS9wcm9tcHQvcHJlcGFyZS10b29scy1hbmQtdG9vbC1jaG9pY2UudHM/MThhMCIsIndlYnBhY2s6Ly9hc2tfZG9jLy4uLy4uL2NvcmUvdXRpbC9pcy1ub24tZW1wdHktb2JqZWN0LnRzP2NhYzgiLCJ3ZWJwYWNrOi8vYXNrX2RvYy8uLi8uLi9jb3JlL3R5cGVzL3Rva2VuLXVzYWdlLnRzPzlhZjQiLCJ3ZWJwYWNrOi8vYXNrX2RvYy8uLi8uLi9lcnJvcnMvaW52YWxpZC10b29sLWFyZ3VtZW50cy1lcnJvci50cz85NjkwIiwid2VicGFjazovL2Fza19kb2MvLi4vLi4vZXJyb3JzL25vLXN1Y2gtdG9vbC1lcnJvci50cz83OTBiIiwid2VicGFjazovL2Fza19kb2MvLi4vLi4vdXRpbC9pcy1hc3luYy1nZW5lcmF0b3IudHM/ZDk2MCIsIndlYnBhY2s6Ly9hc2tfZG9jLy4uLy4uL3V0aWwvaXMtZ2VuZXJhdG9yLnRzP2RmZDUiLCJ3ZWJwYWNrOi8vYXNrX2RvYy8uLi8uLi91dGlsL3JldHJ5LXdpdGgtZXhwb25lbnRpYWwtYmFja29mZi50cz80ZDE5Iiwid2VicGFjazovL2Fza19kb2MvLi4vLi4vdXRpbC9kZWxheS50cz8yOGFmIiwid2VicGFjazovL2Fza19kb2MvLi4vLi4vdXRpbC9yZXRyeS1lcnJvci50cz84NzU4Iiwid2VicGFjazovL2Fza19kb2MvLi4vLi4vdXRpbC9jb25zdGFudHMudHM/M2ZmMiIsIndlYnBhY2s6Ly9hc2tfZG9jLy4uL3N0cmVhbWFibGUtdWkvY3JlYXRlLXN1c3BlbmRlZC1jaHVuay50c3g/ZTI5YyIsIndlYnBhY2s6Ly9hc2tfZG9jLy4uL3N0cmVhbWFibGUtdWkvY3JlYXRlLXN0cmVhbWFibGUtdWkudHN4P2E5MDAiLCJ3ZWJwYWNrOi8vYXNrX2RvYy8uLi9zdHJlYW0tdWkvcmVuZGVyLnRzPzA5ZTYiLCJ3ZWJwYWNrOi8vYXNrX2RvYy8uLi8uLi9zdHJlYW1zL2FpLXN0cmVhbS50cz80ODU0Iiwid2VicGFjazovL2Fza19kb2MvLi4vLi4vc3RyZWFtcy9zdHJlYW0tZGF0YS50cz82NzMwIiwid2VicGFjazovL2Fza19kb2MvLi4vLi4vc3RyZWFtcy9vcGVuYWktc3RyZWFtLnRzP2IyYmQiLCJ3ZWJwYWNrOi8vYXNrX2RvYy8uLi8uLi91dGlsL2NvbnN1bWUtc3RyZWFtLnRzPzczMDgiLCJ3ZWJwYWNrOi8vYXNrX2RvYy8uLi9zdHJlYW1hYmxlLXZhbHVlL3N0cmVhbWFibGUtdmFsdWUudHM/YzVlMSIsIndlYnBhY2s6Ly9hc2tfZG9jLy4uL3N0cmVhbWFibGUtdmFsdWUvY3JlYXRlLXN0cmVhbWFibGUtdmFsdWUudHM/MzAxNSJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgKiBhcyBqc29uZGlmZnBhdGNoIGZyb20gJ2pzb25kaWZmcGF0Y2gnO1xuaW1wb3J0IHsgQXN5bmNMb2NhbFN0b3JhZ2UgfSBmcm9tICdub2RlOmFzeW5jX2hvb2tzJztcbmltcG9ydCB7IGNyZWF0ZVJlc29sdmFibGVQcm9taXNlIH0gZnJvbSAnLi4vdXRpbC9jcmVhdGUtcmVzb2x2YWJsZS1wcm9taXNlJztcbmltcG9ydCB7IGlzRnVuY3Rpb24gfSBmcm9tICcuLi91dGlsL2lzLWZ1bmN0aW9uJztcbmltcG9ydCB0eXBlIHtcbiAgQUlQcm92aWRlcixcbiAgSW5mZXJBSVN0YXRlLFxuICBJbnRlcm5hbEFJU3RhdGVTdG9yYWdlT3B0aW9ucyxcbiAgTXV0YWJsZUFJU3RhdGUsXG4gIFZhbHVlT3JVcGRhdGVyLFxufSBmcm9tICcuL3R5cGVzJztcblxuLy8gSXQgaXMgcG9zc2libGUgdGhhdCBtdWx0aXBsZSBBSSByZXF1ZXN0cyBnZXQgaW4gY29uY3VycmVudGx5LCBmb3IgZGlmZmVyZW50XG4vLyBBSSBpbnN0YW5jZXMuIFNvIEFMUyBpcyBuZWNlc3NhcnkgaGVyZSBmb3IgYSBzaW1wbGVyIEFQSS5cbmNvbnN0IGFzeW5jQUlTdGF0ZVN0b3JhZ2UgPSBuZXcgQXN5bmNMb2NhbFN0b3JhZ2U8e1xuICBjdXJyZW50U3RhdGU6IGFueTtcbiAgb3JpZ2luYWxTdGF0ZTogYW55O1xuICBzZWFsZWQ6IGJvb2xlYW47XG4gIG9wdGlvbnM6IEludGVybmFsQUlTdGF0ZVN0b3JhZ2VPcHRpb25zO1xuICBtdXRhdGlvbkRlbHRhUHJvbWlzZT86IFByb21pc2U8YW55PjtcbiAgbXV0YXRpb25EZWx0YVJlc29sdmU/OiAodjogYW55KSA9PiB2b2lkO1xufT4oKTtcblxuZnVuY3Rpb24gZ2V0QUlTdGF0ZVN0b3JlT3JUaHJvdyhtZXNzYWdlOiBzdHJpbmcpIHtcbiAgY29uc3Qgc3RvcmUgPSBhc3luY0FJU3RhdGVTdG9yYWdlLmdldFN0b3JlKCk7XG4gIGlmICghc3RvcmUpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IobWVzc2FnZSk7XG4gIH1cbiAgcmV0dXJuIHN0b3JlO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gd2l0aEFJU3RhdGU8UywgVD4oXG4gIHsgc3RhdGUsIG9wdGlvbnMgfTogeyBzdGF0ZTogUzsgb3B0aW9uczogSW50ZXJuYWxBSVN0YXRlU3RvcmFnZU9wdGlvbnMgfSxcbiAgZm46ICgpID0+IFQsXG4pOiBUIHtcbiAgcmV0dXJuIGFzeW5jQUlTdGF0ZVN0b3JhZ2UucnVuKFxuICAgIHtcbiAgICAgIGN1cnJlbnRTdGF0ZTogc3RhdGUsXG4gICAgICBvcmlnaW5hbFN0YXRlOiBzdGF0ZSxcbiAgICAgIHNlYWxlZDogZmFsc2UsXG4gICAgICBvcHRpb25zLFxuICAgIH0sXG4gICAgZm4sXG4gICk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBnZXRBSVN0YXRlRGVsdGFQcm9taXNlKCkge1xuICBjb25zdCBzdG9yZSA9IGdldEFJU3RhdGVTdG9yZU9yVGhyb3coJ0ludGVybmFsIGVycm9yIG9jY3VycmVkLicpO1xuICByZXR1cm4gc3RvcmUubXV0YXRpb25EZWx0YVByb21pc2U7XG59XG5cbi8vIEludGVybmFsIG1ldGhvZC4gVGhpcyB3aWxsIGJlIGNhbGxlZCBhZnRlciB0aGUgQUkgQWN0aW9uIGhhcyBiZWVuIHJldHVybmVkXG4vLyBhbmQgeW91IGNhbiBubyBsb25nZXIgY2FsbCBgZ2V0TXV0YWJsZUFJU3RhdGUoKWAgaW5zaWRlIGFueSBhc3luYyBjYWxsYmFja3Ncbi8vIGNyZWF0ZWQgYnkgdGhhdCBBY3Rpb24uXG5leHBvcnQgZnVuY3Rpb24gc2VhbE11dGFibGVBSVN0YXRlKCkge1xuICBjb25zdCBzdG9yZSA9IGdldEFJU3RhdGVTdG9yZU9yVGhyb3coJ0ludGVybmFsIGVycm9yIG9jY3VycmVkLicpO1xuICBzdG9yZS5zZWFsZWQgPSB0cnVlO1xufVxuXG4vKipcbiAqIEdldCB0aGUgY3VycmVudCBBSSBzdGF0ZS5cbiAqIElmIGBrZXlgIGlzIHByb3ZpZGVkLCBpdCB3aWxsIHJldHVybiB0aGUgdmFsdWUgb2YgdGhlIHNwZWNpZmllZCBrZXkgaW4gdGhlXG4gKiBBSSBzdGF0ZSwgaWYgaXQncyBhbiBvYmplY3QuIElmIGl0J3Mgbm90IGFuIG9iamVjdCwgaXQgd2lsbCB0aHJvdyBhbiBlcnJvci5cbiAqXG4gKiBAZXhhbXBsZSBjb25zdCBzdGF0ZSA9IGdldEFJU3RhdGUoKSAvLyBHZXQgdGhlIGVudGlyZSBBSSBzdGF0ZVxuICogQGV4YW1wbGUgY29uc3QgZmllbGQgPSBnZXRBSVN0YXRlKCdrZXknKSAvLyBHZXQgdGhlIHZhbHVlIG9mIHRoZSBrZXlcbiAqL1xuZnVuY3Rpb24gZ2V0QUlTdGF0ZTxBSSBleHRlbmRzIEFJUHJvdmlkZXIgPSBhbnk+KCk6IFJlYWRvbmx5PFxuICBJbmZlckFJU3RhdGU8QUksIGFueT5cbj47XG5mdW5jdGlvbiBnZXRBSVN0YXRlPEFJIGV4dGVuZHMgQUlQcm92aWRlciA9IGFueT4oXG4gIGtleToga2V5b2YgSW5mZXJBSVN0YXRlPEFJLCBhbnk+LFxuKTogUmVhZG9ubHk8SW5mZXJBSVN0YXRlPEFJLCBhbnk+W3R5cGVvZiBrZXldPjtcbmZ1bmN0aW9uIGdldEFJU3RhdGU8QUkgZXh0ZW5kcyBBSVByb3ZpZGVyID0gYW55PihcbiAgLi4uYXJnczogW10gfCBba2V5OiBrZXlvZiBJbmZlckFJU3RhdGU8QUksIGFueT5dXG4pIHtcbiAgY29uc3Qgc3RvcmUgPSBnZXRBSVN0YXRlU3RvcmVPclRocm93KFxuICAgICdgZ2V0QUlTdGF0ZWAgbXVzdCBiZSBjYWxsZWQgd2l0aGluIGFuIEFJIEFjdGlvbi4nLFxuICApO1xuXG4gIGlmIChhcmdzLmxlbmd0aCA+IDApIHtcbiAgICBjb25zdCBrZXkgPSBhcmdzWzBdO1xuICAgIGlmICh0eXBlb2Ygc3RvcmUuY3VycmVudFN0YXRlICE9PSAnb2JqZWN0Jykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICBgWW91IGNhbid0IGdldCB0aGUgXCIke1N0cmluZyhcbiAgICAgICAgICBrZXksXG4gICAgICAgICl9XCIgZmllbGQgZnJvbSB0aGUgQUkgc3RhdGUgYmVjYXVzZSBpdCdzIG5vdCBhbiBvYmplY3QuYCxcbiAgICAgICk7XG4gICAgfVxuICAgIHJldHVybiBzdG9yZS5jdXJyZW50U3RhdGVba2V5IGFzIGtleW9mIHR5cGVvZiBzdG9yZS5jdXJyZW50U3RhdGVdO1xuICB9XG5cbiAgcmV0dXJuIHN0b3JlLmN1cnJlbnRTdGF0ZTtcbn1cblxuLyoqXG4gKiBHZXQgdGhlIG11dGFibGUgQUkgc3RhdGUuIE5vdGUgdGhhdCB5b3UgbXVzdCBjYWxsIGAuZG9uZSgpYCB3aGVuIGZpbmlzaGluZ1xuICogdXBkYXRpbmcgdGhlIEFJIHN0YXRlLlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0c3hcbiAqIGNvbnN0IHN0YXRlID0gZ2V0TXV0YWJsZUFJU3RhdGUoKVxuICogc3RhdGUudXBkYXRlKHsgLi4uc3RhdGUuZ2V0KCksIGtleTogJ3ZhbHVlJyB9KVxuICogc3RhdGUudXBkYXRlKChjdXJyZW50U3RhdGUpID0+ICh7IC4uLmN1cnJlbnRTdGF0ZSwga2V5OiAndmFsdWUnIH0pKVxuICogc3RhdGUuZG9uZSgpXG4gKiBgYGBcbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHN4XG4gKiBjb25zdCBzdGF0ZSA9IGdldE11dGFibGVBSVN0YXRlKClcbiAqIHN0YXRlLmRvbmUoeyAuLi5zdGF0ZS5nZXQoKSwga2V5OiAndmFsdWUnIH0pIC8vIERvbmUgd2l0aCBhIG5ldyBzdGF0ZVxuICogYGBgXG4gKi9cbmZ1bmN0aW9uIGdldE11dGFibGVBSVN0YXRlPEFJIGV4dGVuZHMgQUlQcm92aWRlciA9IGFueT4oKTogTXV0YWJsZUFJU3RhdGU8XG4gIEluZmVyQUlTdGF0ZTxBSSwgYW55PlxuPjtcbmZ1bmN0aW9uIGdldE11dGFibGVBSVN0YXRlPEFJIGV4dGVuZHMgQUlQcm92aWRlciA9IGFueT4oXG4gIGtleToga2V5b2YgSW5mZXJBSVN0YXRlPEFJLCBhbnk+LFxuKTogTXV0YWJsZUFJU3RhdGU8SW5mZXJBSVN0YXRlPEFJLCBhbnk+W3R5cGVvZiBrZXldPjtcbmZ1bmN0aW9uIGdldE11dGFibGVBSVN0YXRlPEFJIGV4dGVuZHMgQUlQcm92aWRlciA9IGFueT4oXG4gIC4uLmFyZ3M6IFtdIHwgW2tleToga2V5b2YgSW5mZXJBSVN0YXRlPEFJLCBhbnk+XVxuKSB7XG4gIHR5cGUgQUlTdGF0ZSA9IEluZmVyQUlTdGF0ZTxBSSwgYW55PjtcbiAgdHlwZSBBSVN0YXRlV2l0aEtleSA9IHR5cGVvZiBhcmdzIGV4dGVuZHMgW2tleToga2V5b2YgQUlTdGF0ZV1cbiAgICA/IEFJU3RhdGVbKHR5cGVvZiBhcmdzKVswXV1cbiAgICA6IEFJU3RhdGU7XG4gIHR5cGUgTmV3U3RhdGVPclVwZGF0ZXIgPSBWYWx1ZU9yVXBkYXRlcjxBSVN0YXRlV2l0aEtleT47XG5cbiAgY29uc3Qgc3RvcmUgPSBnZXRBSVN0YXRlU3RvcmVPclRocm93KFxuICAgICdgZ2V0TXV0YWJsZUFJU3RhdGVgIG11c3QgYmUgY2FsbGVkIHdpdGhpbiBhbiBBSSBBY3Rpb24uJyxcbiAgKTtcblxuICBpZiAoc3RvcmUuc2VhbGVkKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgXCJgZ2V0TXV0YWJsZUFJU3RhdGVgIG11c3QgYmUgY2FsbGVkIGJlZm9yZSByZXR1cm5pbmcgZnJvbSBhbiBBSSBBY3Rpb24uIFBsZWFzZSBtb3ZlIGl0IHRvIHRoZSB0b3AgbGV2ZWwgb2YgdGhlIEFjdGlvbidzIGZ1bmN0aW9uIGJvZHkuXCIsXG4gICAgKTtcbiAgfVxuXG4gIGlmICghc3RvcmUubXV0YXRpb25EZWx0YVByb21pc2UpIHtcbiAgICBjb25zdCB7IHByb21pc2UsIHJlc29sdmUgfSA9IGNyZWF0ZVJlc29sdmFibGVQcm9taXNlKCk7XG4gICAgc3RvcmUubXV0YXRpb25EZWx0YVByb21pc2UgPSBwcm9taXNlO1xuICAgIHN0b3JlLm11dGF0aW9uRGVsdGFSZXNvbHZlID0gcmVzb2x2ZTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGRvVXBkYXRlKG5ld1N0YXRlOiBOZXdTdGF0ZU9yVXBkYXRlciwgZG9uZTogYm9vbGVhbikge1xuICAgIGlmIChhcmdzLmxlbmd0aCA+IDApIHtcbiAgICAgIGlmICh0eXBlb2Ygc3RvcmUuY3VycmVudFN0YXRlICE9PSAnb2JqZWN0Jykge1xuICAgICAgICBjb25zdCBrZXkgPSBhcmdzWzBdO1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgYFlvdSBjYW4ndCBtb2RpZnkgdGhlIFwiJHtTdHJpbmcoXG4gICAgICAgICAgICBrZXksXG4gICAgICAgICAgKX1cIiBmaWVsZCBvZiB0aGUgQUkgc3RhdGUgYmVjYXVzZSBpdCdzIG5vdCBhbiBvYmplY3QuYCxcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoaXNGdW5jdGlvbihuZXdTdGF0ZSkpIHtcbiAgICAgIGlmIChhcmdzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgc3RvcmUuY3VycmVudFN0YXRlW2FyZ3NbMF1dID0gbmV3U3RhdGUoc3RvcmUuY3VycmVudFN0YXRlW2FyZ3NbMF1dKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHN0b3JlLmN1cnJlbnRTdGF0ZSA9IG5ld1N0YXRlKHN0b3JlLmN1cnJlbnRTdGF0ZSk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChhcmdzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgc3RvcmUuY3VycmVudFN0YXRlW2FyZ3NbMF1dID0gbmV3U3RhdGU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzdG9yZS5jdXJyZW50U3RhdGUgPSBuZXdTdGF0ZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBzdG9yZS5vcHRpb25zLm9uU2V0QUlTdGF0ZT8uKHtcbiAgICAgIGtleTogYXJncy5sZW5ndGggPiAwID8gYXJnc1swXSA6IHVuZGVmaW5lZCxcbiAgICAgIHN0YXRlOiBzdG9yZS5jdXJyZW50U3RhdGUsXG4gICAgICBkb25lLFxuICAgIH0pO1xuICB9XG5cbiAgY29uc3QgbXV0YWJsZVN0YXRlID0ge1xuICAgIGdldDogKCkgPT4ge1xuICAgICAgaWYgKGFyZ3MubGVuZ3RoID4gMCkge1xuICAgICAgICBjb25zdCBrZXkgPSBhcmdzWzBdO1xuICAgICAgICBpZiAodHlwZW9mIHN0b3JlLmN1cnJlbnRTdGF0ZSAhPT0gJ29iamVjdCcpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgICBgWW91IGNhbid0IGdldCB0aGUgXCIke1N0cmluZyhcbiAgICAgICAgICAgICAga2V5LFxuICAgICAgICAgICAgKX1cIiBmaWVsZCBmcm9tIHRoZSBBSSBzdGF0ZSBiZWNhdXNlIGl0J3Mgbm90IGFuIG9iamVjdC5gLFxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHN0b3JlLmN1cnJlbnRTdGF0ZVtrZXldIGFzIFJlYWRvbmx5PEFJU3RhdGVXaXRoS2V5PjtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHN0b3JlLmN1cnJlbnRTdGF0ZSBhcyBSZWFkb25seTxBSVN0YXRlPjtcbiAgICB9LFxuICAgIHVwZGF0ZTogZnVuY3Rpb24gdXBkYXRlKG5ld0FJU3RhdGU6IE5ld1N0YXRlT3JVcGRhdGVyKSB7XG4gICAgICBkb1VwZGF0ZShuZXdBSVN0YXRlLCBmYWxzZSk7XG4gICAgfSxcbiAgICBkb25lOiBmdW5jdGlvbiBkb25lKC4uLmRvbmVBcmdzOiBbXSB8IFtOZXdTdGF0ZU9yVXBkYXRlcl0pIHtcbiAgICAgIGlmIChkb25lQXJncy5sZW5ndGggPiAwKSB7XG4gICAgICAgIGRvVXBkYXRlKGRvbmVBcmdzWzBdIGFzIE5ld1N0YXRlT3JVcGRhdGVyLCB0cnVlKTtcbiAgICAgIH1cblxuICAgICAgY29uc3QgZGVsdGEgPSBqc29uZGlmZnBhdGNoLmRpZmYoc3RvcmUub3JpZ2luYWxTdGF0ZSwgc3RvcmUuY3VycmVudFN0YXRlKTtcbiAgICAgIHN0b3JlLm11dGF0aW9uRGVsdGFSZXNvbHZlIShkZWx0YSk7XG4gICAgfSxcbiAgfTtcblxuICByZXR1cm4gbXV0YWJsZVN0YXRlO1xufVxuXG5leHBvcnQgeyBnZXRBSVN0YXRlLCBnZXRNdXRhYmxlQUlTdGF0ZSB9O1xuIiwiLyoqXG4gKiBDcmVhdGVzIGEgUHJvbWlzZSB3aXRoIGV4dGVybmFsbHkgYWNjZXNzaWJsZSByZXNvbHZlIGFuZCByZWplY3QgZnVuY3Rpb25zLlxuICpcbiAqIEB0ZW1wbGF0ZSBUIC0gVGhlIHR5cGUgb2YgdGhlIHZhbHVlIHRoYXQgdGhlIFByb21pc2Ugd2lsbCByZXNvbHZlIHRvLlxuICogQHJldHVybnMgQW4gb2JqZWN0IGNvbnRhaW5pbmc6XG4gKiAgIC0gcHJvbWlzZTogQSBQcm9taXNlIHRoYXQgY2FuIGJlIHJlc29sdmVkIG9yIHJlamVjdGVkIGV4dGVybmFsbHkuXG4gKiAgIC0gcmVzb2x2ZTogQSBmdW5jdGlvbiB0byByZXNvbHZlIHRoZSBQcm9taXNlIHdpdGggYSB2YWx1ZSBvZiB0eXBlIFQuXG4gKiAgIC0gcmVqZWN0OiBBIGZ1bmN0aW9uIHRvIHJlamVjdCB0aGUgUHJvbWlzZSB3aXRoIGFuIGVycm9yLlxuICovXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlUmVzb2x2YWJsZVByb21pc2U8VCA9IGFueT4oKToge1xuICBwcm9taXNlOiBQcm9taXNlPFQ+O1xuICByZXNvbHZlOiAodmFsdWU6IFQpID0+IHZvaWQ7XG4gIHJlamVjdDogKGVycm9yOiB1bmtub3duKSA9PiB2b2lkO1xufSB7XG4gIGxldCByZXNvbHZlOiAodmFsdWU6IFQpID0+IHZvaWQ7XG4gIGxldCByZWplY3Q6IChlcnJvcjogdW5rbm93bikgPT4gdm9pZDtcblxuICBjb25zdCBwcm9taXNlID0gbmV3IFByb21pc2U8VD4oKHJlcywgcmVqKSA9PiB7XG4gICAgcmVzb2x2ZSA9IHJlcztcbiAgICByZWplY3QgPSByZWo7XG4gIH0pO1xuXG4gIHJldHVybiB7XG4gICAgcHJvbWlzZSxcbiAgICByZXNvbHZlOiByZXNvbHZlISxcbiAgICByZWplY3Q6IHJlamVjdCEsXG4gIH07XG59XG4iLCIvKipcbiAqIENoZWNrcyBpZiB0aGUgZ2l2ZW4gdmFsdWUgaXMgYSBmdW5jdGlvbi5cbiAqXG4gKiBAcGFyYW0ge3Vua25vd259IHZhbHVlIC0gVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFRydWUgaWYgdGhlIHZhbHVlIGlzIGEgZnVuY3Rpb24sIGZhbHNlIG90aGVyd2lzZS5cbiAqL1xuZXhwb3J0IGNvbnN0IGlzRnVuY3Rpb24gPSAodmFsdWU6IHVua25vd24pOiB2YWx1ZSBpcyBGdW5jdGlvbiA9PlxuICB0eXBlb2YgdmFsdWUgPT09ICdmdW5jdGlvbic7XG4iLCIvLyBUaGlzIGZpbGUgcHJvdmlkZXMgdGhlIEFJIGNvbnRleHQgdG8gYWxsIEFJIEFjdGlvbnMgdmlhIEFzeW5jTG9jYWxTdG9yYWdlLlxuXG5pbXBvcnQgKiBhcyBSZWFjdCBmcm9tICdyZWFjdCc7XG5pbXBvcnQgeyBJbnRlcm5hbEFJUHJvdmlkZXIgfSBmcm9tICcuL3JzYy1zaGFyZWQubWpzJztcbmltcG9ydCB7XG4gIHdpdGhBSVN0YXRlLFxuICBnZXRBSVN0YXRlRGVsdGFQcm9taXNlLFxuICBzZWFsTXV0YWJsZUFJU3RhdGUsXG59IGZyb20gJy4vYWktc3RhdGUnO1xuaW1wb3J0IHR5cGUge1xuICBTZXJ2ZXJXcmFwcGVkQWN0aW9ucyxcbiAgQUlBY3Rpb24sXG4gIEFJQWN0aW9ucyxcbiAgQUlQcm92aWRlcixcbiAgSW50ZXJuYWxBSVN0YXRlU3RvcmFnZU9wdGlvbnMsXG4gIE9uU2V0QUlTdGF0ZSxcbiAgT25HZXRVSVN0YXRlLFxufSBmcm9tICcuL3R5cGVzJztcblxuYXN5bmMgZnVuY3Rpb24gaW5uZXJBY3Rpb248VD4oXG4gIHtcbiAgICBhY3Rpb24sXG4gICAgb3B0aW9ucyxcbiAgfTogeyBhY3Rpb246IEFJQWN0aW9uOyBvcHRpb25zOiBJbnRlcm5hbEFJU3RhdGVTdG9yYWdlT3B0aW9ucyB9LFxuICBzdGF0ZTogVCxcbiAgLi4uYXJnczogdW5rbm93bltdXG4pIHtcbiAgJ3VzZSBzZXJ2ZXInO1xuICByZXR1cm4gYXdhaXQgd2l0aEFJU3RhdGUoXG4gICAge1xuICAgICAgc3RhdGUsXG4gICAgICBvcHRpb25zLFxuICAgIH0sXG4gICAgYXN5bmMgKCkgPT4ge1xuICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgYWN0aW9uKC4uLmFyZ3MpO1xuICAgICAgc2VhbE11dGFibGVBSVN0YXRlKCk7XG4gICAgICByZXR1cm4gW2dldEFJU3RhdGVEZWx0YVByb21pc2UoKSBhcyBQcm9taXNlPFQ+LCByZXN1bHRdO1xuICAgIH0sXG4gICk7XG59XG5cbmZ1bmN0aW9uIHdyYXBBY3Rpb248VCA9IHVua25vd24+KFxuICBhY3Rpb246IEFJQWN0aW9uLFxuICBvcHRpb25zOiBJbnRlcm5hbEFJU3RhdGVTdG9yYWdlT3B0aW9ucyxcbikge1xuICByZXR1cm4gaW5uZXJBY3Rpb24uYmluZChudWxsLCB7IGFjdGlvbiwgb3B0aW9ucyB9KSBhcyBBSUFjdGlvbjxUPjtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZUFJPFxuICBBSVN0YXRlID0gYW55LFxuICBVSVN0YXRlID0gYW55LFxuICBBY3Rpb25zIGV4dGVuZHMgQUlBY3Rpb25zID0ge30sXG4+KHtcbiAgYWN0aW9ucyxcbiAgaW5pdGlhbEFJU3RhdGUsXG4gIGluaXRpYWxVSVN0YXRlLFxuXG4gIG9uU2V0QUlTdGF0ZSxcbiAgb25HZXRVSVN0YXRlLFxufToge1xuICBhY3Rpb25zOiBBY3Rpb25zO1xuICBpbml0aWFsQUlTdGF0ZT86IEFJU3RhdGU7XG4gIGluaXRpYWxVSVN0YXRlPzogVUlTdGF0ZTtcblxuICAvKipcbiAgICogVGhpcyBmdW5jdGlvbiBpcyBjYWxsZWQgd2hlbmV2ZXIgdGhlIEFJIHN0YXRlIGlzIHVwZGF0ZWQgYnkgYW4gQWN0aW9uLlxuICAgKiBZb3UgY2FuIHVzZSB0aGlzIHRvIHBlcnNpc3QgdGhlIEFJIHN0YXRlIHRvIGEgZGF0YWJhc2UsIG9yIHRvIHNlbmQgaXQgdG8gYVxuICAgKiBsb2dnaW5nIHNlcnZpY2UuXG4gICAqL1xuICBvblNldEFJU3RhdGU/OiBPblNldEFJU3RhdGU8QUlTdGF0ZT47XG5cbiAgLyoqXG4gICAqIFRoaXMgZnVuY3Rpb24gaXMgdXNlZCB0byByZXRyaWV2ZSB0aGUgVUkgc3RhdGUgYmFzZWQgb24gdGhlIEFJIHN0YXRlLlxuICAgKiBGb3IgZXhhbXBsZSwgdG8gcmVuZGVyIHRoZSBpbml0aWFsIFVJIHN0YXRlIGJhc2VkIG9uIGEgZ2l2ZW4gQUkgc3RhdGUsIG9yXG4gICAqIHRvIHN5bmMgdGhlIFVJIHN0YXRlIHdoZW4gdGhlIGFwcGxpY2F0aW9uIGlzIGFscmVhZHkgbG9hZGVkLlxuICAgKlxuICAgKiBJZiByZXR1cm5pbmcgYHVuZGVmaW5lZGAsIHRoZSBjbGllbnQgc2lkZSBVSSBzdGF0ZSB3aWxsIG5vdCBiZSB1cGRhdGVkLlxuICAgKlxuICAgKiBUaGlzIGZ1bmN0aW9uIG11c3QgYmUgYW5ub3RhdGVkIHdpdGggdGhlIGBcInVzZSBzZXJ2ZXJcImAgZGlyZWN0aXZlLlxuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKiBgYGB0c3hcbiAgICogb25HZXRVSVN0YXRlOiBhc3luYyAoKSA9PiB7XG4gICAqICAgJ3VzZSBzZXJ2ZXInO1xuICAgKlxuICAgKiAgIGNvbnN0IGN1cnJlbnRBSVN0YXRlID0gZ2V0QUlTdGF0ZSgpO1xuICAgKiAgIGNvbnN0IGV4dGVybmFsQUlTdGF0ZSA9IGF3YWl0IGxvYWRBSVN0YXRlRnJvbURhdGFiYXNlKCk7XG4gICAqXG4gICAqICAgaWYgKGN1cnJlbnRBSVN0YXRlID09PSBleHRlcm5hbEFJU3RhdGUpIHJldHVybiB1bmRlZmluZWQ7XG4gICAqXG4gICAqICAgLy8gVXBkYXRlIGN1cnJlbnQgQUkgc3RhdGUgYW5kIHJldHVybiB0aGUgbmV3IFVJIHN0YXRlXG4gICAqICAgY29uc3Qgc3RhdGUgPSBnZXRNdXRhYmxlQUlTdGF0ZSgpXG4gICAqICAgc3RhdGUuZG9uZShleHRlcm5hbEFJU3RhdGUpXG4gICAqXG4gICAqICAgcmV0dXJuIDxkaXY+Li4uPC9kaXY+O1xuICAgKiB9XG4gICAqIGBgYFxuICAgKi9cbiAgb25HZXRVSVN0YXRlPzogT25HZXRVSVN0YXRlPFVJU3RhdGU+O1xufSkge1xuICAvLyBXcmFwIGFsbCBhY3Rpb25zIHdpdGggb3VyIEhvQy5cbiAgY29uc3Qgd3JhcHBlZEFjdGlvbnM6IFNlcnZlcldyYXBwZWRBY3Rpb25zID0ge307XG4gIGZvciAoY29uc3QgbmFtZSBpbiBhY3Rpb25zKSB7XG4gICAgd3JhcHBlZEFjdGlvbnNbbmFtZV0gPSB3cmFwQWN0aW9uKGFjdGlvbnNbbmFtZV0sIHtcbiAgICAgIG9uU2V0QUlTdGF0ZSxcbiAgICB9KTtcbiAgfVxuXG4gIGNvbnN0IHdyYXBwZWRTeW5jVUlTdGF0ZSA9IG9uR2V0VUlTdGF0ZVxuICAgID8gd3JhcEFjdGlvbihvbkdldFVJU3RhdGUsIHt9KVxuICAgIDogdW5kZWZpbmVkO1xuXG4gIGNvbnN0IEFJOiBBSVByb3ZpZGVyPEFJU3RhdGUsIFVJU3RhdGUsIEFjdGlvbnM+ID0gYXN5bmMgcHJvcHMgPT4ge1xuICAgIGlmICgndXNlU3RhdGUnIGluIFJlYWN0KSB7XG4gICAgICAvLyBUaGlzIGZpbGUgbXVzdCBiZSBydW5uaW5nIG9uIHRoZSBSZWFjdCBTZXJ2ZXIgbGF5ZXIuXG4gICAgICAvLyBJZGVhbGx5IHdlIHNob3VsZCBiZSB1c2luZyBgaW1wb3J0IFwic2VydmVyLW9ubHlcImAgaGVyZSBidXQgd2UgY2FuIGhhdmUgYVxuICAgICAgLy8gbW9yZSBjdXN0b21pemVkIGVycm9yIG1lc3NhZ2Ugd2l0aCB0aGlzIGltcGxlbWVudGF0aW9uLlxuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAnVGhpcyBjb21wb25lbnQgY2FuIG9ubHkgYmUgdXNlZCBpbnNpZGUgU2VydmVyIENvbXBvbmVudHMuJyxcbiAgICAgICk7XG4gICAgfVxuXG4gICAgbGV0IHVpU3RhdGUgPSBwcm9wcy5pbml0aWFsVUlTdGF0ZSA/PyBpbml0aWFsVUlTdGF0ZTtcbiAgICBsZXQgYWlTdGF0ZSA9IHByb3BzLmluaXRpYWxBSVN0YXRlID8/IGluaXRpYWxBSVN0YXRlO1xuICAgIGxldCBhaVN0YXRlRGVsdGEgPSB1bmRlZmluZWQ7XG5cbiAgICBpZiAod3JhcHBlZFN5bmNVSVN0YXRlKSB7XG4gICAgICBjb25zdCBbbmV3QUlTdGF0ZURlbHRhLCBuZXdVSVN0YXRlXSA9IGF3YWl0IHdyYXBwZWRTeW5jVUlTdGF0ZShhaVN0YXRlKTtcbiAgICAgIGlmIChuZXdVSVN0YXRlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgYWlTdGF0ZURlbHRhID0gbmV3QUlTdGF0ZURlbHRhO1xuICAgICAgICB1aVN0YXRlID0gbmV3VUlTdGF0ZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gKFxuICAgICAgPEludGVybmFsQUlQcm92aWRlclxuICAgICAgICB3cmFwcGVkQWN0aW9ucz17d3JhcHBlZEFjdGlvbnN9XG4gICAgICAgIHdyYXBwZWRTeW5jVUlTdGF0ZT17d3JhcHBlZFN5bmNVSVN0YXRlfVxuICAgICAgICBpbml0aWFsVUlTdGF0ZT17dWlTdGF0ZX1cbiAgICAgICAgaW5pdGlhbEFJU3RhdGU9e2FpU3RhdGV9XG4gICAgICAgIGluaXRpYWxBSVN0YXRlUGF0Y2g9e2FpU3RhdGVEZWx0YX1cbiAgICAgID5cbiAgICAgICAge3Byb3BzLmNoaWxkcmVufVxuICAgICAgPC9JbnRlcm5hbEFJUHJvdmlkZXI+XG4gICAgKTtcbiAgfTtcblxuICByZXR1cm4gQUk7XG59XG4iLCJpbXBvcnQgeyBMYW5ndWFnZU1vZGVsVjEgfSBmcm9tICdAYWktc2RrL3Byb3ZpZGVyJztcbmltcG9ydCB7IHNhZmVQYXJzZUpTT04gfSBmcm9tICdAYWktc2RrL3Byb3ZpZGVyLXV0aWxzJztcbmltcG9ydCB7IFJlYWN0Tm9kZSB9IGZyb20gJ3JlYWN0JztcbmltcG9ydCB7IHogfSBmcm9tICd6b2QnO1xuaW1wb3J0IHsgQ2FsbFNldHRpbmdzIH0gZnJvbSAnLi4vLi4vY29yZS9wcm9tcHQvY2FsbC1zZXR0aW5ncyc7XG5pbXBvcnQgeyBjb252ZXJ0VG9MYW5ndWFnZU1vZGVsUHJvbXB0IH0gZnJvbSAnLi4vLi4vY29yZS9wcm9tcHQvY29udmVydC10by1sYW5ndWFnZS1tb2RlbC1wcm9tcHQnO1xuaW1wb3J0IHsgZ2V0VmFsaWRhdGVkUHJvbXB0IH0gZnJvbSAnLi4vLi4vY29yZS9wcm9tcHQvZ2V0LXZhbGlkYXRlZC1wcm9tcHQnO1xuaW1wb3J0IHsgcHJlcGFyZUNhbGxTZXR0aW5ncyB9IGZyb20gJy4uLy4uL2NvcmUvcHJvbXB0L3ByZXBhcmUtY2FsbC1zZXR0aW5ncyc7XG5pbXBvcnQgeyBwcmVwYXJlVG9vbHNBbmRUb29sQ2hvaWNlIH0gZnJvbSAnLi4vLi4vY29yZS9wcm9tcHQvcHJlcGFyZS10b29scy1hbmQtdG9vbC1jaG9pY2UnO1xuaW1wb3J0IHsgUHJvbXB0IH0gZnJvbSAnLi4vLi4vY29yZS9wcm9tcHQvcHJvbXB0JztcbmltcG9ydCB7IENhbGxXYXJuaW5nLCBDb3JlVG9vbENob2ljZSwgRmluaXNoUmVhc29uIH0gZnJvbSAnLi4vLi4vY29yZS90eXBlcyc7XG5pbXBvcnQge1xuICBDb21wbGV0aW9uVG9rZW5Vc2FnZSxcbiAgY2FsY3VsYXRlQ29tcGxldGlvblRva2VuVXNhZ2UsXG59IGZyb20gJy4uLy4uL2NvcmUvdHlwZXMvdG9rZW4tdXNhZ2UnO1xuaW1wb3J0IHsgSW52YWxpZFRvb2xBcmd1bWVudHNFcnJvciB9IGZyb20gJy4uLy4uL2Vycm9ycy9pbnZhbGlkLXRvb2wtYXJndW1lbnRzLWVycm9yJztcbmltcG9ydCB7IE5vU3VjaFRvb2xFcnJvciB9IGZyb20gJy4uLy4uL2Vycm9ycy9uby1zdWNoLXRvb2wtZXJyb3InO1xuaW1wb3J0IHsgY3JlYXRlUmVzb2x2YWJsZVByb21pc2UgfSBmcm9tICcuLi8uLi91dGlsL2NyZWF0ZS1yZXNvbHZhYmxlLXByb21pc2UnO1xuaW1wb3J0IHsgaXNBc3luY0dlbmVyYXRvciB9IGZyb20gJy4uLy4uL3V0aWwvaXMtYXN5bmMtZ2VuZXJhdG9yJztcbmltcG9ydCB7IGlzR2VuZXJhdG9yIH0gZnJvbSAnLi4vLi4vdXRpbC9pcy1nZW5lcmF0b3InO1xuaW1wb3J0IHsgcmV0cnlXaXRoRXhwb25lbnRpYWxCYWNrb2ZmIH0gZnJvbSAnLi4vLi4vdXRpbC9yZXRyeS13aXRoLWV4cG9uZW50aWFsLWJhY2tvZmYnO1xuaW1wb3J0IHsgY3JlYXRlU3RyZWFtYWJsZVVJIH0gZnJvbSAnLi4vc3RyZWFtYWJsZS11aS9jcmVhdGUtc3RyZWFtYWJsZS11aSc7XG5cbnR5cGUgU3RyZWFtYWJsZSA9IFJlYWN0Tm9kZSB8IFByb21pc2U8UmVhY3ROb2RlPjtcblxudHlwZSBSZW5kZXJlcjxUIGV4dGVuZHMgQXJyYXk8YW55Pj4gPSAoXG4gIC4uLmFyZ3M6IFRcbikgPT5cbiAgfCBTdHJlYW1hYmxlXG4gIHwgR2VuZXJhdG9yPFN0cmVhbWFibGUsIFN0cmVhbWFibGUsIHZvaWQ+XG4gIHwgQXN5bmNHZW5lcmF0b3I8U3RyZWFtYWJsZSwgU3RyZWFtYWJsZSwgdm9pZD47XG5cbnR5cGUgUmVuZGVyVG9vbDxQQVJBTUVURVJTIGV4dGVuZHMgei5ab2RUeXBlQW55ID0gYW55PiA9IHtcbiAgZGVzY3JpcHRpb24/OiBzdHJpbmc7XG4gIHBhcmFtZXRlcnM6IFBBUkFNRVRFUlM7XG4gIGdlbmVyYXRlPzogUmVuZGVyZXI8XG4gICAgW1xuICAgICAgei5pbmZlcjxQQVJBTUVURVJTPixcbiAgICAgIHtcbiAgICAgICAgdG9vbE5hbWU6IHN0cmluZztcbiAgICAgICAgdG9vbENhbGxJZDogc3RyaW5nO1xuICAgICAgfSxcbiAgICBdXG4gID47XG59O1xuXG50eXBlIFJlbmRlclRleHQgPSBSZW5kZXJlcjxcbiAgW1xuICAgIHtcbiAgICAgIC8qKlxuICAgICAgICogVGhlIGZ1bGwgdGV4dCBjb250ZW50IGZyb20gdGhlIG1vZGVsIHNvIGZhci5cbiAgICAgICAqL1xuICAgICAgY29udGVudDogc3RyaW5nO1xuXG4gICAgICAvKipcbiAgICAgICAqIFRoZSBuZXcgYXBwZW5kZWQgdGV4dCBjb250ZW50IGZyb20gdGhlIG1vZGVsIHNpbmNlIHRoZSBsYXN0IGB0ZXh0YCBjYWxsLlxuICAgICAgICovXG4gICAgICBkZWx0YTogc3RyaW5nO1xuXG4gICAgICAvKipcbiAgICAgICAqIFdoZXRoZXIgdGhlIG1vZGVsIGlzIGRvbmUgZ2VuZXJhdGluZyB0ZXh0LlxuICAgICAgICogSWYgYHRydWVgLCB0aGUgYGNvbnRlbnRgIHdpbGwgYmUgdGhlIGZpbmFsIG91dHB1dCBhbmQgdGhpcyBjYWxsIHdpbGwgYmUgdGhlIGxhc3QuXG4gICAgICAgKi9cbiAgICAgIGRvbmU6IGJvb2xlYW47XG4gICAgfSxcbiAgXVxuPjtcblxudHlwZSBSZW5kZXJSZXN1bHQgPSB7XG4gIHZhbHVlOiBSZWFjdE5vZGU7XG59ICYgQXdhaXRlZDxSZXR1cm5UeXBlPExhbmd1YWdlTW9kZWxWMVsnZG9TdHJlYW0nXT4+O1xuXG5jb25zdCBkZWZhdWx0VGV4dFJlbmRlcmVyOiBSZW5kZXJUZXh0ID0gKHsgY29udGVudCB9OiB7IGNvbnRlbnQ6IHN0cmluZyB9KSA9PlxuICBjb250ZW50O1xuXG4vKipcbiAqIGBzdHJlYW1VSWAgaXMgYSBoZWxwZXIgZnVuY3Rpb24gdG8gY3JlYXRlIGEgc3RyZWFtYWJsZSBVSSBmcm9tIExMTXMuXG4gKi9cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBzdHJlYW1VSTxcbiAgVE9PTFMgZXh0ZW5kcyB7IFtuYW1lOiBzdHJpbmddOiB6LlpvZFR5cGVBbnkgfSA9IHt9LFxuPih7XG4gIG1vZGVsLFxuICB0b29scyxcbiAgdG9vbENob2ljZSxcbiAgc3lzdGVtLFxuICBwcm9tcHQsXG4gIG1lc3NhZ2VzLFxuICBtYXhSZXRyaWVzLFxuICBhYm9ydFNpZ25hbCxcbiAgaGVhZGVycyxcbiAgaW5pdGlhbCxcbiAgdGV4dCxcbiAgb25GaW5pc2gsXG4gIC4uLnNldHRpbmdzXG59OiBDYWxsU2V0dGluZ3MgJlxuICBQcm9tcHQgJiB7XG4gICAgLyoqXG4gICAgICogVGhlIGxhbmd1YWdlIG1vZGVsIHRvIHVzZS5cbiAgICAgKi9cbiAgICBtb2RlbDogTGFuZ3VhZ2VNb2RlbFYxO1xuXG4gICAgLyoqXG4gICAgICogVGhlIHRvb2xzIHRoYXQgdGhlIG1vZGVsIGNhbiBjYWxsLiBUaGUgbW9kZWwgbmVlZHMgdG8gc3VwcG9ydCBjYWxsaW5nIHRvb2xzLlxuICAgICAqL1xuICAgIHRvb2xzPzoge1xuICAgICAgW25hbWUgaW4ga2V5b2YgVE9PTFNdOiBSZW5kZXJUb29sPFRPT0xTW25hbWVdPjtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogVGhlIHRvb2wgY2hvaWNlIHN0cmF0ZWd5LiBEZWZhdWx0OiAnYXV0bycuXG4gICAgICovXG4gICAgdG9vbENob2ljZT86IENvcmVUb29sQ2hvaWNlPFRPT0xTPjtcblxuICAgIHRleHQ/OiBSZW5kZXJUZXh0O1xuICAgIGluaXRpYWw/OiBSZWFjdE5vZGU7XG4gICAgLyoqXG4gICAgICogQ2FsbGJhY2sgdGhhdCBpcyBjYWxsZWQgd2hlbiB0aGUgTExNIHJlc3BvbnNlIGFuZCB0aGUgZmluYWwgb2JqZWN0IHZhbGlkYXRpb24gYXJlIGZpbmlzaGVkLlxuICAgICAqL1xuICAgIG9uRmluaXNoPzogKGV2ZW50OiB7XG4gICAgICAvKipcbiAgICAgICAqIFRoZSByZWFzb24gd2h5IHRoZSBnZW5lcmF0aW9uIGZpbmlzaGVkLlxuICAgICAgICovXG4gICAgICBmaW5pc2hSZWFzb246IEZpbmlzaFJlYXNvbjtcbiAgICAgIC8qKlxuICAgICAgICogVGhlIHRva2VuIHVzYWdlIG9mIHRoZSBnZW5lcmF0ZWQgcmVzcG9uc2UuXG4gICAgICAgKi9cbiAgICAgIHVzYWdlOiBDb21wbGV0aW9uVG9rZW5Vc2FnZTtcbiAgICAgIC8qKlxuICAgICAgICogVGhlIGZpbmFsIHVpIG5vZGUgdGhhdCB3YXMgZ2VuZXJhdGVkLlxuICAgICAgICovXG4gICAgICB2YWx1ZTogUmVhY3ROb2RlO1xuICAgICAgLyoqXG4gICAgICAgKiBXYXJuaW5ncyBmcm9tIHRoZSBtb2RlbCBwcm92aWRlciAoZS5nLiB1bnN1cHBvcnRlZCBzZXR0aW5ncylcbiAgICAgICAqL1xuICAgICAgd2FybmluZ3M/OiBDYWxsV2FybmluZ1tdO1xuICAgICAgLyoqXG4gICAgICAgKiBPcHRpb25hbCByYXcgcmVzcG9uc2UgZGF0YS5cbiAgICAgICAqL1xuICAgICAgcmF3UmVzcG9uc2U/OiB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBSZXNwb25zZSBoZWFkZXJzLlxuICAgICAgICAgKi9cbiAgICAgICAgaGVhZGVycz86IFJlY29yZDxzdHJpbmcsIHN0cmluZz47XG4gICAgICB9O1xuICAgIH0pID0+IFByb21pc2U8dm9pZD4gfCB2b2lkO1xuICB9KTogUHJvbWlzZTxSZW5kZXJSZXN1bHQ+IHtcbiAgLy8gVE9ETzogUmVtb3ZlIHRoZXNlIGVycm9ycyBhZnRlciB0aGUgZXhwZXJpbWVudGFsIHBoYXNlLlxuICBpZiAodHlwZW9mIG1vZGVsID09PSAnc3RyaW5nJykge1xuICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICdgbW9kZWxgIGNhbm5vdCBiZSBhIHN0cmluZyBpbiBgc3RyZWFtVUlgLiBVc2UgdGhlIGFjdHVhbCBtb2RlbCBpbnN0YW5jZSBpbnN0ZWFkLicsXG4gICAgKTtcbiAgfVxuICBpZiAoJ2Z1bmN0aW9ucycgaW4gc2V0dGluZ3MpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAnYGZ1bmN0aW9uc2AgaXMgbm90IHN1cHBvcnRlZCBpbiBgc3RyZWFtVUlgLCB1c2UgYHRvb2xzYCBpbnN0ZWFkLicsXG4gICAgKTtcbiAgfVxuICBpZiAoJ3Byb3ZpZGVyJyBpbiBzZXR0aW5ncykge1xuICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICdgcHJvdmlkZXJgIGlzIG5vIGxvbmdlciBuZWVkZWQgaW4gYHN0cmVhbVVJYC4gVXNlIGBtb2RlbGAgaW5zdGVhZC4nLFxuICAgICk7XG4gIH1cbiAgaWYgKHRvb2xzKSB7XG4gICAgZm9yIChjb25zdCBbbmFtZSwgdG9vbF0gb2YgT2JqZWN0LmVudHJpZXModG9vbHMpKSB7XG4gICAgICBpZiAoJ3JlbmRlcicgaW4gdG9vbCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgJ1Rvb2wgZGVmaW5pdGlvbiBpbiBgc3RyZWFtVUlgIHNob3VsZCBub3QgaGF2ZSBgcmVuZGVyYCBwcm9wZXJ0eS4gVXNlIGBnZW5lcmF0ZWAgaW5zdGVhZC4gRm91bmQgaW4gdG9vbDogJyArXG4gICAgICAgICAgICBuYW1lLFxuICAgICAgICApO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGNvbnN0IHVpID0gY3JlYXRlU3RyZWFtYWJsZVVJKGluaXRpYWwpO1xuXG4gIC8vIFRoZSBkZWZhdWx0IHRleHQgcmVuZGVyZXIganVzdCByZXR1cm5zIHRoZSBjb250ZW50IGFzIHN0cmluZy5cbiAgY29uc3QgdGV4dFJlbmRlciA9IHRleHQgfHwgZGVmYXVsdFRleHRSZW5kZXJlcjtcblxuICBsZXQgZmluaXNoZWQ6IFByb21pc2U8dm9pZD4gfCB1bmRlZmluZWQ7XG5cbiAgYXN5bmMgZnVuY3Rpb24gcmVuZGVyKHtcbiAgICBhcmdzLFxuICAgIHJlbmRlcmVyLFxuICAgIHN0cmVhbWFibGVVSSxcbiAgICBpc0xhc3RDYWxsID0gZmFsc2UsXG4gIH06IHtcbiAgICByZW5kZXJlcjogdW5kZWZpbmVkIHwgUmVuZGVyZXI8YW55PjtcbiAgICBhcmdzOiBbcGF5bG9hZDogYW55XSB8IFtwYXlsb2FkOiBhbnksIG9wdGlvbnM6IGFueV07XG4gICAgc3RyZWFtYWJsZVVJOiBSZXR1cm5UeXBlPHR5cGVvZiBjcmVhdGVTdHJlYW1hYmxlVUk+O1xuICAgIGlzTGFzdENhbGw/OiBib29sZWFuO1xuICB9KSB7XG4gICAgaWYgKCFyZW5kZXJlcikgcmV0dXJuO1xuXG4gICAgLy8gY3JlYXRlIGEgcHJvbWlzZSB0aGF0IHdpbGwgYmUgcmVzb2x2ZWQgd2hlbiB0aGUgcmVuZGVyIGNhbGwgaXMgZmluaXNoZWQuXG4gICAgLy8gaXQgaXMgYXBwZW5kZWQgdG8gdGhlIGBmaW5pc2hlZGAgcHJvbWlzZSBjaGFpbiB0byBlbnN1cmUgdGhlIHJlbmRlciBjYWxsXG4gICAgLy8gaXMgZmluaXNoZWQgYmVmb3JlIHRoZSBuZXh0IHJlbmRlciBjYWxsIHN0YXJ0cy5cbiAgICBjb25zdCByZW5kZXJGaW5pc2hlZCA9IGNyZWF0ZVJlc29sdmFibGVQcm9taXNlPHZvaWQ+KCk7XG4gICAgZmluaXNoZWQgPSBmaW5pc2hlZFxuICAgICAgPyBmaW5pc2hlZC50aGVuKCgpID0+IHJlbmRlckZpbmlzaGVkLnByb21pc2UpXG4gICAgICA6IHJlbmRlckZpbmlzaGVkLnByb21pc2U7XG5cbiAgICBjb25zdCByZW5kZXJlclJlc3VsdCA9IHJlbmRlcmVyKC4uLmFyZ3MpO1xuXG4gICAgaWYgKGlzQXN5bmNHZW5lcmF0b3IocmVuZGVyZXJSZXN1bHQpIHx8IGlzR2VuZXJhdG9yKHJlbmRlcmVyUmVzdWx0KSkge1xuICAgICAgd2hpbGUgKHRydWUpIHtcbiAgICAgICAgY29uc3QgeyBkb25lLCB2YWx1ZSB9ID0gYXdhaXQgcmVuZGVyZXJSZXN1bHQubmV4dCgpO1xuICAgICAgICBjb25zdCBub2RlID0gYXdhaXQgdmFsdWU7XG5cbiAgICAgICAgaWYgKGlzTGFzdENhbGwgJiYgZG9uZSkge1xuICAgICAgICAgIHN0cmVhbWFibGVVSS5kb25lKG5vZGUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHN0cmVhbWFibGVVSS51cGRhdGUobm9kZSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZG9uZSkgYnJlYWs7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IG5vZGUgPSBhd2FpdCByZW5kZXJlclJlc3VsdDtcblxuICAgICAgaWYgKGlzTGFzdENhbGwpIHtcbiAgICAgICAgc3RyZWFtYWJsZVVJLmRvbmUobm9kZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzdHJlYW1hYmxlVUkudXBkYXRlKG5vZGUpO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIHJlc29sdmUgdGhlIHByb21pc2UgdG8gc2lnbmFsIHRoYXQgdGhlIHJlbmRlciBjYWxsIGlzIGZpbmlzaGVkXG4gICAgcmVuZGVyRmluaXNoZWQucmVzb2x2ZSh1bmRlZmluZWQpO1xuICB9XG5cbiAgY29uc3QgcmV0cnkgPSByZXRyeVdpdGhFeHBvbmVudGlhbEJhY2tvZmYoeyBtYXhSZXRyaWVzIH0pO1xuICBjb25zdCB2YWxpZGF0ZWRQcm9tcHQgPSBnZXRWYWxpZGF0ZWRQcm9tcHQoeyBzeXN0ZW0sIHByb21wdCwgbWVzc2FnZXMgfSk7XG4gIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHJldHJ5KGFzeW5jICgpID0+XG4gICAgbW9kZWwuZG9TdHJlYW0oe1xuICAgICAgbW9kZToge1xuICAgICAgICB0eXBlOiAncmVndWxhcicsXG4gICAgICAgIC4uLnByZXBhcmVUb29sc0FuZFRvb2xDaG9pY2UoeyB0b29scywgdG9vbENob2ljZSB9KSxcbiAgICAgIH0sXG4gICAgICAuLi5wcmVwYXJlQ2FsbFNldHRpbmdzKHNldHRpbmdzKSxcbiAgICAgIGlucHV0Rm9ybWF0OiB2YWxpZGF0ZWRQcm9tcHQudHlwZSxcbiAgICAgIHByb21wdDogYXdhaXQgY29udmVydFRvTGFuZ3VhZ2VNb2RlbFByb21wdCh7XG4gICAgICAgIHByb21wdDogdmFsaWRhdGVkUHJvbXB0LFxuICAgICAgICBtb2RlbFN1cHBvcnRzSW1hZ2VVcmxzOiBtb2RlbC5zdXBwb3J0c0ltYWdlVXJscyxcbiAgICAgIH0pLFxuICAgICAgYWJvcnRTaWduYWwsXG4gICAgICBoZWFkZXJzLFxuICAgIH0pLFxuICApO1xuXG4gIC8vIEZvciB0aGUgc3RyZWFtIGFuZCBjb25zdW1lIGl0IGFzeW5jaHJvbm91c2x5OlxuICBjb25zdCBbc3RyZWFtLCBmb3JrZWRTdHJlYW1dID0gcmVzdWx0LnN0cmVhbS50ZWUoKTtcbiAgKGFzeW5jICgpID0+IHtcbiAgICB0cnkge1xuICAgICAgbGV0IGNvbnRlbnQgPSAnJztcbiAgICAgIGxldCBoYXNUb29sQ2FsbCA9IGZhbHNlO1xuXG4gICAgICBjb25zdCByZWFkZXIgPSBmb3JrZWRTdHJlYW0uZ2V0UmVhZGVyKCk7XG4gICAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgICBjb25zdCB7IGRvbmUsIHZhbHVlIH0gPSBhd2FpdCByZWFkZXIucmVhZCgpO1xuICAgICAgICBpZiAoZG9uZSkgYnJlYWs7XG5cbiAgICAgICAgc3dpdGNoICh2YWx1ZS50eXBlKSB7XG4gICAgICAgICAgY2FzZSAndGV4dC1kZWx0YSc6IHtcbiAgICAgICAgICAgIGNvbnRlbnQgKz0gdmFsdWUudGV4dERlbHRhO1xuICAgICAgICAgICAgcmVuZGVyKHtcbiAgICAgICAgICAgICAgcmVuZGVyZXI6IHRleHRSZW5kZXIsXG4gICAgICAgICAgICAgIGFyZ3M6IFt7IGNvbnRlbnQsIGRvbmU6IGZhbHNlLCBkZWx0YTogdmFsdWUudGV4dERlbHRhIH1dLFxuICAgICAgICAgICAgICBzdHJlYW1hYmxlVUk6IHVpLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBjYXNlICd0b29sLWNhbGwtZGVsdGEnOiB7XG4gICAgICAgICAgICBoYXNUb29sQ2FsbCA9IHRydWU7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBjYXNlICd0b29sLWNhbGwnOiB7XG4gICAgICAgICAgICBjb25zdCB0b29sTmFtZSA9IHZhbHVlLnRvb2xOYW1lIGFzIGtleW9mIFRPT0xTICYgc3RyaW5nO1xuXG4gICAgICAgICAgICBpZiAoIXRvb2xzKSB7XG4gICAgICAgICAgICAgIHRocm93IG5ldyBOb1N1Y2hUb29sRXJyb3IoeyB0b29sTmFtZSB9KTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgY29uc3QgdG9vbCA9IHRvb2xzW3Rvb2xOYW1lXTtcbiAgICAgICAgICAgIGlmICghdG9vbCkge1xuICAgICAgICAgICAgICB0aHJvdyBuZXcgTm9TdWNoVG9vbEVycm9yKHtcbiAgICAgICAgICAgICAgICB0b29sTmFtZSxcbiAgICAgICAgICAgICAgICBhdmFpbGFibGVUb29sczogT2JqZWN0LmtleXModG9vbHMpLFxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaGFzVG9vbENhbGwgPSB0cnVlO1xuICAgICAgICAgICAgY29uc3QgcGFyc2VSZXN1bHQgPSBzYWZlUGFyc2VKU09OKHtcbiAgICAgICAgICAgICAgdGV4dDogdmFsdWUuYXJncyxcbiAgICAgICAgICAgICAgc2NoZW1hOiB0b29sLnBhcmFtZXRlcnMsXG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgaWYgKHBhcnNlUmVzdWx0LnN1Y2Nlc3MgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICAgIHRocm93IG5ldyBJbnZhbGlkVG9vbEFyZ3VtZW50c0Vycm9yKHtcbiAgICAgICAgICAgICAgICB0b29sTmFtZSxcbiAgICAgICAgICAgICAgICB0b29sQXJnczogdmFsdWUuYXJncyxcbiAgICAgICAgICAgICAgICBjYXVzZTogcGFyc2VSZXN1bHQuZXJyb3IsXG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZW5kZXIoe1xuICAgICAgICAgICAgICByZW5kZXJlcjogdG9vbC5nZW5lcmF0ZSxcbiAgICAgICAgICAgICAgYXJnczogW1xuICAgICAgICAgICAgICAgIHBhcnNlUmVzdWx0LnZhbHVlLFxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgIHRvb2xOYW1lLFxuICAgICAgICAgICAgICAgICAgdG9vbENhbGxJZDogdmFsdWUudG9vbENhbGxJZCxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgICBzdHJlYW1hYmxlVUk6IHVpLFxuICAgICAgICAgICAgICBpc0xhc3RDYWxsOiB0cnVlLFxuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGNhc2UgJ2Vycm9yJzoge1xuICAgICAgICAgICAgdGhyb3cgdmFsdWUuZXJyb3I7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgY2FzZSAnZmluaXNoJzoge1xuICAgICAgICAgICAgb25GaW5pc2g/Lih7XG4gICAgICAgICAgICAgIGZpbmlzaFJlYXNvbjogdmFsdWUuZmluaXNoUmVhc29uLFxuICAgICAgICAgICAgICB1c2FnZTogY2FsY3VsYXRlQ29tcGxldGlvblRva2VuVXNhZ2UodmFsdWUudXNhZ2UpLFxuICAgICAgICAgICAgICB2YWx1ZTogdWkudmFsdWUsXG4gICAgICAgICAgICAgIHdhcm5pbmdzOiByZXN1bHQud2FybmluZ3MsXG4gICAgICAgICAgICAgIHJhd1Jlc3BvbnNlOiByZXN1bHQucmF3UmVzcG9uc2UsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKCFoYXNUb29sQ2FsbCkge1xuICAgICAgICByZW5kZXIoe1xuICAgICAgICAgIHJlbmRlcmVyOiB0ZXh0UmVuZGVyLFxuICAgICAgICAgIGFyZ3M6IFt7IGNvbnRlbnQsIGRvbmU6IHRydWUgfV0sXG4gICAgICAgICAgc3RyZWFtYWJsZVVJOiB1aSxcbiAgICAgICAgICBpc0xhc3RDYWxsOiB0cnVlLFxuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgYXdhaXQgZmluaXNoZWQ7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIC8vIER1cmluZyB0aGUgc3RyZWFtIHJlbmRlcmluZywgd2UgZG9uJ3Qgd2FudCB0byB0aHJvdyB0aGUgZXJyb3IgdG8gdGhlXG4gICAgICAvLyBwYXJlbnQgc2NvcGUgYnV0IG9ubHkgbGV0IHRoZSBSZWFjdCdzIGVycm9yIGJvdW5kYXJ5IHRvIGNhdGNoIGl0LlxuICAgICAgdWkuZXJyb3IoZXJyb3IpO1xuICAgIH1cbiAgfSkoKTtcblxuICByZXR1cm4ge1xuICAgIC4uLnJlc3VsdCxcbiAgICBzdHJlYW0sXG4gICAgdmFsdWU6IHVpLnZhbHVlLFxuICB9O1xufVxuIiwiaW1wb3J0IHtcbiAgTGFuZ3VhZ2VNb2RlbFYxSW1hZ2VQYXJ0LFxuICBMYW5ndWFnZU1vZGVsVjFNZXNzYWdlLFxuICBMYW5ndWFnZU1vZGVsVjFQcm9tcHQsXG4gIExhbmd1YWdlTW9kZWxWMVRleHRQYXJ0LFxufSBmcm9tICdAYWktc2RrL3Byb3ZpZGVyJztcbmltcG9ydCB7IGdldEVycm9yTWVzc2FnZSB9IGZyb20gJ0BhaS1zZGsvcHJvdmlkZXItdXRpbHMnO1xuaW1wb3J0IHsgZG93bmxvYWQgfSBmcm9tICcuLi8uLi91dGlsL2Rvd25sb2FkJztcbmltcG9ydCB7IENvcmVNZXNzYWdlIH0gZnJvbSAnLi4vcHJvbXB0L21lc3NhZ2UnO1xuaW1wb3J0IHsgZGV0ZWN0SW1hZ2VNaW1lVHlwZSB9IGZyb20gJy4uL3V0aWwvZGV0ZWN0LWltYWdlLW1pbWV0eXBlJztcbmltcG9ydCB7IEltYWdlUGFydCwgVGV4dFBhcnQgfSBmcm9tICcuL2NvbnRlbnQtcGFydCc7XG5pbXBvcnQgeyBjb252ZXJ0RGF0YUNvbnRlbnRUb1VpbnQ4QXJyYXkgfSBmcm9tICcuL2RhdGEtY29udGVudCc7XG5pbXBvcnQgeyBWYWxpZGF0ZWRQcm9tcHQgfSBmcm9tICcuL2dldC12YWxpZGF0ZWQtcHJvbXB0JztcbmltcG9ydCB7IEludmFsaWRNZXNzYWdlUm9sZUVycm9yIH0gZnJvbSAnLi9pbnZhbGlkLW1lc3NhZ2Utcm9sZS1lcnJvcic7XG5cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBjb252ZXJ0VG9MYW5ndWFnZU1vZGVsUHJvbXB0KHtcbiAgcHJvbXB0LFxuICBtb2RlbFN1cHBvcnRzSW1hZ2VVcmxzID0gdHJ1ZSxcbiAgZG93bmxvYWRJbXBsZW1lbnRhdGlvbiA9IGRvd25sb2FkLFxufToge1xuICBwcm9tcHQ6IFZhbGlkYXRlZFByb21wdDtcbiAgbW9kZWxTdXBwb3J0c0ltYWdlVXJsczogYm9vbGVhbiB8IHVuZGVmaW5lZDtcbiAgZG93bmxvYWRJbXBsZW1lbnRhdGlvbj86IHR5cGVvZiBkb3dubG9hZDtcbn0pOiBQcm9taXNlPExhbmd1YWdlTW9kZWxWMVByb21wdD4ge1xuICBjb25zdCBsYW5ndWFnZU1vZGVsTWVzc2FnZXM6IExhbmd1YWdlTW9kZWxWMVByb21wdCA9IFtdO1xuXG4gIGlmIChwcm9tcHQuc3lzdGVtICE9IG51bGwpIHtcbiAgICBsYW5ndWFnZU1vZGVsTWVzc2FnZXMucHVzaCh7IHJvbGU6ICdzeXN0ZW0nLCBjb250ZW50OiBwcm9tcHQuc3lzdGVtIH0pO1xuICB9XG5cbiAgY29uc3QgZG93bmxvYWRlZEltYWdlcyA9XG4gICAgbW9kZWxTdXBwb3J0c0ltYWdlVXJscyB8fCBwcm9tcHQubWVzc2FnZXMgPT0gbnVsbFxuICAgICAgPyBudWxsXG4gICAgICA6IGF3YWl0IGRvd25sb2FkSW1hZ2VzKHByb21wdC5tZXNzYWdlcywgZG93bmxvYWRJbXBsZW1lbnRhdGlvbik7XG5cbiAgY29uc3QgcHJvbXB0VHlwZSA9IHByb21wdC50eXBlO1xuICBzd2l0Y2ggKHByb21wdFR5cGUpIHtcbiAgICBjYXNlICdwcm9tcHQnOiB7XG4gICAgICBsYW5ndWFnZU1vZGVsTWVzc2FnZXMucHVzaCh7XG4gICAgICAgIHJvbGU6ICd1c2VyJyxcbiAgICAgICAgY29udGVudDogW3sgdHlwZTogJ3RleHQnLCB0ZXh0OiBwcm9tcHQucHJvbXB0IH1dLFxuICAgICAgfSk7XG4gICAgICBicmVhaztcbiAgICB9XG5cbiAgICBjYXNlICdtZXNzYWdlcyc6IHtcbiAgICAgIGxhbmd1YWdlTW9kZWxNZXNzYWdlcy5wdXNoKFxuICAgICAgICAuLi5wcm9tcHQubWVzc2FnZXMubWFwKFxuICAgICAgICAgIChtZXNzYWdlKTogTGFuZ3VhZ2VNb2RlbFYxTWVzc2FnZSA9PlxuICAgICAgICAgICAgY29udmVydFRvTGFuZ3VhZ2VNb2RlbE1lc3NhZ2UobWVzc2FnZSwgZG93bmxvYWRlZEltYWdlcyksXG4gICAgICAgICksXG4gICAgICApO1xuICAgICAgYnJlYWs7XG4gICAgfVxuXG4gICAgZGVmYXVsdDoge1xuICAgICAgY29uc3QgX2V4aGF1c3RpdmVDaGVjazogbmV2ZXIgPSBwcm9tcHRUeXBlO1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBVbnN1cHBvcnRlZCBwcm9tcHQgdHlwZTogJHtfZXhoYXVzdGl2ZUNoZWNrfWApO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBsYW5ndWFnZU1vZGVsTWVzc2FnZXM7XG59XG5cbi8qKlxuICogQ29udmVydCBhIENvcmVNZXNzYWdlIHRvIGEgTGFuZ3VhZ2VNb2RlbFYxTWVzc2FnZS5cbiAqXG4gKiBAcGFyYW0gbWVzc2FnZSBUaGUgQ29yZU1lc3NhZ2UgdG8gY29udmVydC5cbiAqIEBwYXJhbSBkb3dubG9hZGVkSW1hZ2VzIEEgbWFwIG9mIGltYWdlIFVSTHMgdG8gdGhlaXIgZG93bmxvYWRlZCBkYXRhLiBPbmx5XG4gKiAgIGF2YWlsYWJsZSBpZiB0aGUgbW9kZWwgZG9lcyBub3Qgc3VwcG9ydCBpbWFnZSBVUkxzLCBudWxsIG90aGVyd2lzZS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNvbnZlcnRUb0xhbmd1YWdlTW9kZWxNZXNzYWdlKFxuICBtZXNzYWdlOiBDb3JlTWVzc2FnZSxcbiAgZG93bmxvYWRlZEltYWdlczogUmVjb3JkPFxuICAgIHN0cmluZyxcbiAgICB7IG1pbWVUeXBlOiBzdHJpbmcgfCB1bmRlZmluZWQ7IGRhdGE6IFVpbnQ4QXJyYXkgfVxuICA+IHwgbnVsbCxcbik6IExhbmd1YWdlTW9kZWxWMU1lc3NhZ2Uge1xuICBjb25zdCByb2xlID0gbWVzc2FnZS5yb2xlO1xuICBzd2l0Y2ggKHJvbGUpIHtcbiAgICBjYXNlICdzeXN0ZW0nOiB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICByb2xlOiAnc3lzdGVtJyxcbiAgICAgICAgY29udGVudDogbWVzc2FnZS5jb250ZW50LFxuICAgICAgICBwcm92aWRlck1ldGFkYXRhOiBtZXNzYWdlLmV4cGVyaW1lbnRhbF9wcm92aWRlck1ldGFkYXRhLFxuICAgICAgfTtcbiAgICB9XG5cbiAgICBjYXNlICd1c2VyJzoge1xuICAgICAgaWYgKHR5cGVvZiBtZXNzYWdlLmNvbnRlbnQgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgcm9sZTogJ3VzZXInLFxuICAgICAgICAgIGNvbnRlbnQ6IFt7IHR5cGU6ICd0ZXh0JywgdGV4dDogbWVzc2FnZS5jb250ZW50IH1dLFxuICAgICAgICAgIHByb3ZpZGVyTWV0YWRhdGE6IG1lc3NhZ2UuZXhwZXJpbWVudGFsX3Byb3ZpZGVyTWV0YWRhdGEsXG4gICAgICAgIH07XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB7XG4gICAgICAgIHJvbGU6ICd1c2VyJyxcbiAgICAgICAgY29udGVudDogbWVzc2FnZS5jb250ZW50Lm1hcChcbiAgICAgICAgICAocGFydCk6IExhbmd1YWdlTW9kZWxWMVRleHRQYXJ0IHwgTGFuZ3VhZ2VNb2RlbFYxSW1hZ2VQYXJ0ID0+IHtcbiAgICAgICAgICAgIHN3aXRjaCAocGFydC50eXBlKSB7XG4gICAgICAgICAgICAgIGNhc2UgJ3RleHQnOiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgIHR5cGU6ICd0ZXh0JyxcbiAgICAgICAgICAgICAgICAgIHRleHQ6IHBhcnQudGV4dCxcbiAgICAgICAgICAgICAgICAgIHByb3ZpZGVyTWV0YWRhdGE6IHBhcnQuZXhwZXJpbWVudGFsX3Byb3ZpZGVyTWV0YWRhdGEsXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIGNhc2UgJ2ltYWdlJzoge1xuICAgICAgICAgICAgICAgIGlmIChwYXJ0LmltYWdlIGluc3RhbmNlb2YgVVJMKSB7XG4gICAgICAgICAgICAgICAgICBpZiAoZG93bmxvYWRlZEltYWdlcyA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgICAgdHlwZTogJ2ltYWdlJyxcbiAgICAgICAgICAgICAgICAgICAgICBpbWFnZTogcGFydC5pbWFnZSxcbiAgICAgICAgICAgICAgICAgICAgICBtaW1lVHlwZTogcGFydC5taW1lVHlwZSxcbiAgICAgICAgICAgICAgICAgICAgICBwcm92aWRlck1ldGFkYXRhOiBwYXJ0LmV4cGVyaW1lbnRhbF9wcm92aWRlck1ldGFkYXRhLFxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgZG93bmxvYWRlZEltYWdlID1cbiAgICAgICAgICAgICAgICAgICAgICBkb3dubG9hZGVkSW1hZ2VzW3BhcnQuaW1hZ2UudG9TdHJpbmcoKV07XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgICAgdHlwZTogJ2ltYWdlJyxcbiAgICAgICAgICAgICAgICAgICAgICBpbWFnZTogZG93bmxvYWRlZEltYWdlLmRhdGEsXG4gICAgICAgICAgICAgICAgICAgICAgbWltZVR5cGU6IHBhcnQubWltZVR5cGUgPz8gZG93bmxvYWRlZEltYWdlLm1pbWVUeXBlLFxuICAgICAgICAgICAgICAgICAgICAgIHByb3ZpZGVyTWV0YWRhdGE6IHBhcnQuZXhwZXJpbWVudGFsX3Byb3ZpZGVyTWV0YWRhdGEsXG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy8gdHJ5IHRvIGNvbnZlcnQgc3RyaW5nIGltYWdlIHBhcnRzIHRvIHVybHNcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHBhcnQuaW1hZ2UgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCB1cmwgPSBuZXcgVVJMKHBhcnQuaW1hZ2UpO1xuXG4gICAgICAgICAgICAgICAgICAgIHN3aXRjaCAodXJsLnByb3RvY29sKSB7XG4gICAgICAgICAgICAgICAgICAgICAgY2FzZSAnaHR0cDonOlxuICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJ2h0dHBzOic6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChkb3dubG9hZGVkSW1hZ2VzID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiAnaW1hZ2UnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGltYWdlOiB1cmwsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbWltZVR5cGU6IHBhcnQubWltZVR5cGUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcHJvdmlkZXJNZXRhZGF0YTpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhcnQuZXhwZXJpbWVudGFsX3Byb3ZpZGVyTWV0YWRhdGEsXG4gICAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBkb3dubG9hZGVkSW1hZ2UgPSBkb3dubG9hZGVkSW1hZ2VzW3BhcnQuaW1hZ2VdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6ICdpbWFnZScsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaW1hZ2U6IGRvd25sb2FkZWRJbWFnZS5kYXRhLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1pbWVUeXBlOiBwYXJ0Lm1pbWVUeXBlID8/IGRvd25sb2FkZWRJbWFnZS5taW1lVHlwZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwcm92aWRlck1ldGFkYXRhOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcGFydC5leHBlcmltZW50YWxfcHJvdmlkZXJNZXRhZGF0YSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgY2FzZSAnZGF0YTonOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBbaGVhZGVyLCBiYXNlNjRDb250ZW50XSA9IHBhcnQuaW1hZ2Uuc3BsaXQoJywnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgbWltZVR5cGUgPSBoZWFkZXIuc3BsaXQoJzsnKVswXS5zcGxpdCgnOicpWzFdO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChtaW1lVHlwZSA9PSBudWxsIHx8IGJhc2U2NENvbnRlbnQgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBkYXRhIFVSTCBmb3JtYXQnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogJ2ltYWdlJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbWFnZTpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnZlcnREYXRhQ29udGVudFRvVWludDhBcnJheShiYXNlNjRDb250ZW50KSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtaW1lVHlwZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwcm92aWRlck1ldGFkYXRhOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcGFydC5leHBlcmltZW50YWxfcHJvdmlkZXJNZXRhZGF0YSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBgRXJyb3IgcHJvY2Vzc2luZyBkYXRhIFVSTDogJHtnZXRFcnJvck1lc3NhZ2UoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICl9YCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgZGVmYXVsdDoge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgICAgICAgICAgICAgICAgICBgVW5zdXBwb3J0ZWQgVVJMIHByb3RvY29sOiAke3VybC5wcm90b2NvbH1gLFxuICAgICAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIH0gY2F0Y2ggKF9pZ25vcmVkKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIG5vdCBhIFVSTFxuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGNvbnN0IGltYWdlVWludDggPSBjb252ZXJ0RGF0YUNvbnRlbnRUb1VpbnQ4QXJyYXkocGFydC5pbWFnZSk7XG5cbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgdHlwZTogJ2ltYWdlJyxcbiAgICAgICAgICAgICAgICAgIGltYWdlOiBpbWFnZVVpbnQ4LFxuICAgICAgICAgICAgICAgICAgbWltZVR5cGU6IHBhcnQubWltZVR5cGUgPz8gZGV0ZWN0SW1hZ2VNaW1lVHlwZShpbWFnZVVpbnQ4KSxcbiAgICAgICAgICAgICAgICAgIHByb3ZpZGVyTWV0YWRhdGE6IHBhcnQuZXhwZXJpbWVudGFsX3Byb3ZpZGVyTWV0YWRhdGEsXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0sXG4gICAgICAgICksXG4gICAgICAgIHByb3ZpZGVyTWV0YWRhdGE6IG1lc3NhZ2UuZXhwZXJpbWVudGFsX3Byb3ZpZGVyTWV0YWRhdGEsXG4gICAgICB9O1xuICAgIH1cblxuICAgIGNhc2UgJ2Fzc2lzdGFudCc6IHtcbiAgICAgIGlmICh0eXBlb2YgbWVzc2FnZS5jb250ZW50ID09PSAnc3RyaW5nJykge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHJvbGU6ICdhc3Npc3RhbnQnLFxuICAgICAgICAgIGNvbnRlbnQ6IFt7IHR5cGU6ICd0ZXh0JywgdGV4dDogbWVzc2FnZS5jb250ZW50IH1dLFxuICAgICAgICAgIHByb3ZpZGVyTWV0YWRhdGE6IG1lc3NhZ2UuZXhwZXJpbWVudGFsX3Byb3ZpZGVyTWV0YWRhdGEsXG4gICAgICAgIH07XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB7XG4gICAgICAgIHJvbGU6ICdhc3Npc3RhbnQnLFxuICAgICAgICBjb250ZW50OiBtZXNzYWdlLmNvbnRlbnQuZmlsdGVyKFxuICAgICAgICAgIC8vIHJlbW92ZSBlbXB0eSB0ZXh0IHBhcnRzOlxuICAgICAgICAgIHBhcnQgPT4gcGFydC50eXBlICE9PSAndGV4dCcgfHwgcGFydC50ZXh0ICE9PSAnJyxcbiAgICAgICAgKSxcbiAgICAgICAgcHJvdmlkZXJNZXRhZGF0YTogbWVzc2FnZS5leHBlcmltZW50YWxfcHJvdmlkZXJNZXRhZGF0YSxcbiAgICAgIH07XG4gICAgfVxuXG4gICAgY2FzZSAndG9vbCc6IHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHJvbGU6ICd0b29sJyxcbiAgICAgICAgY29udGVudDogbWVzc2FnZS5jb250ZW50Lm1hcChwYXJ0ID0+ICh7XG4gICAgICAgICAgdHlwZTogJ3Rvb2wtcmVzdWx0JyxcbiAgICAgICAgICB0b29sQ2FsbElkOiBwYXJ0LnRvb2xDYWxsSWQsXG4gICAgICAgICAgdG9vbE5hbWU6IHBhcnQudG9vbE5hbWUsXG4gICAgICAgICAgcmVzdWx0OiBwYXJ0LnJlc3VsdCxcbiAgICAgICAgICBwcm92aWRlck1ldGFkYXRhOiBwYXJ0LmV4cGVyaW1lbnRhbF9wcm92aWRlck1ldGFkYXRhLFxuICAgICAgICB9KSksXG4gICAgICAgIHByb3ZpZGVyTWV0YWRhdGE6IG1lc3NhZ2UuZXhwZXJpbWVudGFsX3Byb3ZpZGVyTWV0YWRhdGEsXG4gICAgICB9O1xuICAgIH1cblxuICAgIGRlZmF1bHQ6IHtcbiAgICAgIGNvbnN0IF9leGhhdXN0aXZlQ2hlY2s6IG5ldmVyID0gcm9sZTtcbiAgICAgIHRocm93IG5ldyBJbnZhbGlkTWVzc2FnZVJvbGVFcnJvcih7IHJvbGU6IF9leGhhdXN0aXZlQ2hlY2sgfSk7XG4gICAgfVxuICB9XG59XG5cbmFzeW5jIGZ1bmN0aW9uIGRvd25sb2FkSW1hZ2VzKFxuICBtZXNzYWdlczogQ29yZU1lc3NhZ2VbXSxcbiAgZG93bmxvYWRJbXBsZW1lbnRhdGlvbjogdHlwZW9mIGRvd25sb2FkLFxuKTogUHJvbWlzZTxSZWNvcmQ8c3RyaW5nLCB7IG1pbWVUeXBlOiBzdHJpbmcgfCB1bmRlZmluZWQ7IGRhdGE6IFVpbnQ4QXJyYXkgfT4+IHtcbiAgY29uc3QgdXJscyA9IG1lc3NhZ2VzXG4gICAgLmZpbHRlcihtZXNzYWdlID0+IG1lc3NhZ2Uucm9sZSA9PT0gJ3VzZXInKVxuICAgIC5tYXAobWVzc2FnZSA9PiBtZXNzYWdlLmNvbnRlbnQpXG4gICAgLmZpbHRlcigoY29udGVudCk6IGNvbnRlbnQgaXMgQXJyYXk8VGV4dFBhcnQgfCBJbWFnZVBhcnQ+ID0+XG4gICAgICBBcnJheS5pc0FycmF5KGNvbnRlbnQpLFxuICAgIClcbiAgICAuZmxhdCgpXG4gICAgLmZpbHRlcigocGFydCk6IHBhcnQgaXMgSW1hZ2VQYXJ0ID0+IHBhcnQudHlwZSA9PT0gJ2ltYWdlJylcbiAgICAubWFwKHBhcnQgPT4gcGFydC5pbWFnZSlcbiAgICAubWFwKHBhcnQgPT5cbiAgICAgIC8vIHN1cHBvcnQgc3RyaW5nIHVybHMgaW4gaW1hZ2UgcGFydHM6XG4gICAgICB0eXBlb2YgcGFydCA9PT0gJ3N0cmluZycgJiZcbiAgICAgIChwYXJ0LnN0YXJ0c1dpdGgoJ2h0dHA6JykgfHwgcGFydC5zdGFydHNXaXRoKCdodHRwczonKSlcbiAgICAgICAgPyBuZXcgVVJMKHBhcnQpXG4gICAgICAgIDogcGFydCxcbiAgICApXG4gICAgLmZpbHRlcigoaW1hZ2UpOiBpbWFnZSBpcyBVUkwgPT4gaW1hZ2UgaW5zdGFuY2VvZiBVUkwpO1xuXG4gIC8vIGRvd25sb2FkIGltYWdlcyBpbiBwYXJhbGxlbDpcbiAgY29uc3QgZG93bmxvYWRlZEltYWdlcyA9IGF3YWl0IFByb21pc2UuYWxsKFxuICAgIHVybHMubWFwKGFzeW5jIHVybCA9PiAoe1xuICAgICAgdXJsLFxuICAgICAgZGF0YTogYXdhaXQgZG93bmxvYWRJbXBsZW1lbnRhdGlvbih7IHVybCB9KSxcbiAgICB9KSksXG4gICk7XG5cbiAgcmV0dXJuIE9iamVjdC5mcm9tRW50cmllcyhcbiAgICBkb3dubG9hZGVkSW1hZ2VzLm1hcCgoeyB1cmwsIGRhdGEgfSkgPT4gW3VybC50b1N0cmluZygpLCBkYXRhXSksXG4gICk7XG59XG4iLCJpbXBvcnQgeyBBSVNES0Vycm9yIH0gZnJvbSAnQGFpLXNkay9wcm92aWRlcic7XG5cbmNvbnN0IG5hbWUgPSAnQUlfRG93bmxvYWRFcnJvcic7XG5jb25zdCBtYXJrZXIgPSBgdmVyY2VsLmFpLmVycm9yLiR7bmFtZX1gO1xuY29uc3Qgc3ltYm9sID0gU3ltYm9sLmZvcihtYXJrZXIpO1xuXG5leHBvcnQgY2xhc3MgRG93bmxvYWRFcnJvciBleHRlbmRzIEFJU0RLRXJyb3Ige1xuICBwcml2YXRlIHJlYWRvbmx5IFtzeW1ib2xdID0gdHJ1ZTsgLy8gdXNlZCBpbiBpc0luc3RhbmNlXG5cbiAgcmVhZG9ubHkgdXJsOiBzdHJpbmc7XG4gIHJlYWRvbmx5IHN0YXR1c0NvZGU/OiBudW1iZXI7XG4gIHJlYWRvbmx5IHN0YXR1c1RleHQ/OiBzdHJpbmc7XG5cbiAgY29uc3RydWN0b3Ioe1xuICAgIHVybCxcbiAgICBzdGF0dXNDb2RlLFxuICAgIHN0YXR1c1RleHQsXG4gICAgY2F1c2UsXG4gICAgbWVzc2FnZSA9IGNhdXNlID09IG51bGxcbiAgICAgID8gYEZhaWxlZCB0byBkb3dubG9hZCAke3VybH06ICR7c3RhdHVzQ29kZX0gJHtzdGF0dXNUZXh0fWBcbiAgICAgIDogYEZhaWxlZCB0byBkb3dubG9hZCAke3VybH06ICR7Y2F1c2V9YCxcbiAgfToge1xuICAgIHVybDogc3RyaW5nO1xuICAgIHN0YXR1c0NvZGU/OiBudW1iZXI7XG4gICAgc3RhdHVzVGV4dD86IHN0cmluZztcbiAgICBtZXNzYWdlPzogc3RyaW5nO1xuICAgIGNhdXNlPzogdW5rbm93bjtcbiAgfSkge1xuICAgIHN1cGVyKHsgbmFtZSwgbWVzc2FnZSwgY2F1c2UgfSk7XG5cbiAgICB0aGlzLnVybCA9IHVybDtcbiAgICB0aGlzLnN0YXR1c0NvZGUgPSBzdGF0dXNDb2RlO1xuICAgIHRoaXMuc3RhdHVzVGV4dCA9IHN0YXR1c1RleHQ7XG4gIH1cblxuICBzdGF0aWMgaXNJbnN0YW5jZShlcnJvcjogdW5rbm93bik6IGVycm9yIGlzIERvd25sb2FkRXJyb3Ige1xuICAgIHJldHVybiBBSVNES0Vycm9yLmhhc01hcmtlcihlcnJvciwgbWFya2VyKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAZGVwcmVjYXRlZCB1c2UgYGlzSW5zdGFuY2VgIGluc3RlYWRcbiAgICovXG4gIHN0YXRpYyBpc0Rvd25sb2FkRXJyb3IoZXJyb3I6IHVua25vd24pOiBlcnJvciBpcyBEb3dubG9hZEVycm9yIHtcbiAgICByZXR1cm4gKFxuICAgICAgZXJyb3IgaW5zdGFuY2VvZiBFcnJvciAmJlxuICAgICAgZXJyb3IubmFtZSA9PT0gbmFtZSAmJlxuICAgICAgdHlwZW9mIChlcnJvciBhcyBEb3dubG9hZEVycm9yKS51cmwgPT09ICdzdHJpbmcnICYmXG4gICAgICAoKGVycm9yIGFzIERvd25sb2FkRXJyb3IpLnN0YXR1c0NvZGUgPT0gbnVsbCB8fFxuICAgICAgICB0eXBlb2YgKGVycm9yIGFzIERvd25sb2FkRXJyb3IpLnN0YXR1c0NvZGUgPT09ICdudW1iZXInKSAmJlxuICAgICAgKChlcnJvciBhcyBEb3dubG9hZEVycm9yKS5zdGF0dXNUZXh0ID09IG51bGwgfHxcbiAgICAgICAgdHlwZW9mIChlcnJvciBhcyBEb3dubG9hZEVycm9yKS5zdGF0dXNUZXh0ID09PSAnc3RyaW5nJylcbiAgICApO1xuICB9XG5cbiAgLyoqXG4gICAqIEBkZXByZWNhdGVkIERvIG5vdCB1c2UgdGhpcyBtZXRob2QuIEl0IHdpbGwgYmUgcmVtb3ZlZCBpbiB0aGUgbmV4dCBtYWpvciB2ZXJzaW9uLlxuICAgKi9cbiAgdG9KU09OKCkge1xuICAgIHJldHVybiB7XG4gICAgICBuYW1lOiB0aGlzLm5hbWUsXG4gICAgICBtZXNzYWdlOiB0aGlzLm1lc3NhZ2UsXG4gICAgICB1cmw6IHRoaXMudXJsLFxuICAgICAgc3RhdHVzQ29kZTogdGhpcy5zdGF0dXNDb2RlLFxuICAgICAgc3RhdHVzVGV4dDogdGhpcy5zdGF0dXNUZXh0LFxuICAgICAgY2F1c2U6IHRoaXMuY2F1c2UsXG4gICAgfTtcbiAgfVxufVxuIiwiaW1wb3J0IHsgRG93bmxvYWRFcnJvciB9IGZyb20gJy4vZG93bmxvYWQtZXJyb3InO1xuXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gZG93bmxvYWQoe1xuICB1cmwsXG4gIGZldGNoSW1wbGVtZW50YXRpb24gPSBmZXRjaCxcbn06IHtcbiAgdXJsOiBVUkw7XG4gIGZldGNoSW1wbGVtZW50YXRpb24/OiB0eXBlb2YgZmV0Y2g7XG59KTogUHJvbWlzZTx7XG4gIGRhdGE6IFVpbnQ4QXJyYXk7XG4gIG1pbWVUeXBlOiBzdHJpbmcgfCB1bmRlZmluZWQ7XG59PiB7XG4gIGNvbnN0IHVybFRleHQgPSB1cmwudG9TdHJpbmcoKTtcbiAgdHJ5IHtcbiAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoSW1wbGVtZW50YXRpb24odXJsVGV4dCk7XG5cbiAgICBpZiAoIXJlc3BvbnNlLm9rKSB7XG4gICAgICB0aHJvdyBuZXcgRG93bmxvYWRFcnJvcih7XG4gICAgICAgIHVybDogdXJsVGV4dCxcbiAgICAgICAgc3RhdHVzQ29kZTogcmVzcG9uc2Uuc3RhdHVzLFxuICAgICAgICBzdGF0dXNUZXh0OiByZXNwb25zZS5zdGF0dXNUZXh0LFxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHtcbiAgICAgIGRhdGE6IG5ldyBVaW50OEFycmF5KGF3YWl0IHJlc3BvbnNlLmFycmF5QnVmZmVyKCkpLFxuICAgICAgbWltZVR5cGU6IHJlc3BvbnNlLmhlYWRlcnMuZ2V0KCdjb250ZW50LXR5cGUnKSA/PyB1bmRlZmluZWQsXG4gICAgfTtcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICBpZiAoRG93bmxvYWRFcnJvci5pc0luc3RhbmNlKGVycm9yKSkge1xuICAgICAgdGhyb3cgZXJyb3I7XG4gICAgfVxuXG4gICAgdGhyb3cgbmV3IERvd25sb2FkRXJyb3IoeyB1cmw6IHVybFRleHQsIGNhdXNlOiBlcnJvciB9KTtcbiAgfVxufVxuIiwiY29uc3QgbWltZVR5cGVTaWduYXR1cmVzID0gW1xuICB7IG1pbWVUeXBlOiAnaW1hZ2UvZ2lmJyBhcyBjb25zdCwgYnl0ZXM6IFsweDQ3LCAweDQ5LCAweDQ2XSB9LFxuICB7IG1pbWVUeXBlOiAnaW1hZ2UvcG5nJyBhcyBjb25zdCwgYnl0ZXM6IFsweDg5LCAweDUwLCAweDRlLCAweDQ3XSB9LFxuICB7IG1pbWVUeXBlOiAnaW1hZ2UvanBlZycgYXMgY29uc3QsIGJ5dGVzOiBbMHhmZiwgMHhkOF0gfSxcbiAgeyBtaW1lVHlwZTogJ2ltYWdlL3dlYnAnIGFzIGNvbnN0LCBieXRlczogWzB4NTIsIDB4NDksIDB4NDYsIDB4NDZdIH0sXG5dO1xuXG5leHBvcnQgZnVuY3Rpb24gZGV0ZWN0SW1hZ2VNaW1lVHlwZShcbiAgaW1hZ2U6IFVpbnQ4QXJyYXksXG4pOiAnaW1hZ2UvanBlZycgfCAnaW1hZ2UvcG5nJyB8ICdpbWFnZS9naWYnIHwgJ2ltYWdlL3dlYnAnIHwgdW5kZWZpbmVkIHtcbiAgZm9yIChjb25zdCB7IGJ5dGVzLCBtaW1lVHlwZSB9IG9mIG1pbWVUeXBlU2lnbmF0dXJlcykge1xuICAgIGlmIChcbiAgICAgIGltYWdlLmxlbmd0aCA+PSBieXRlcy5sZW5ndGggJiZcbiAgICAgIGJ5dGVzLmV2ZXJ5KChieXRlLCBpbmRleCkgPT4gaW1hZ2VbaW5kZXhdID09PSBieXRlKVxuICAgICkge1xuICAgICAgcmV0dXJuIG1pbWVUeXBlO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB1bmRlZmluZWQ7XG59XG4iLCJpbXBvcnQge1xuICBjb252ZXJ0QmFzZTY0VG9VaW50OEFycmF5LFxuICBjb252ZXJ0VWludDhBcnJheVRvQmFzZTY0LFxufSBmcm9tICdAYWktc2RrL3Byb3ZpZGVyLXV0aWxzJztcbmltcG9ydCB7IEludmFsaWREYXRhQ29udGVudEVycm9yIH0gZnJvbSAnLi9pbnZhbGlkLWRhdGEtY29udGVudC1lcnJvcic7XG5cbi8qKlxuRGF0YSBjb250ZW50LiBDYW4gZWl0aGVyIGJlIGEgYmFzZTY0LWVuY29kZWQgc3RyaW5nLCBhIFVpbnQ4QXJyYXksIGFuIEFycmF5QnVmZmVyLCBvciBhIEJ1ZmZlci5cbiAqL1xuZXhwb3J0IHR5cGUgRGF0YUNvbnRlbnQgPSBzdHJpbmcgfCBVaW50OEFycmF5IHwgQXJyYXlCdWZmZXIgfCBCdWZmZXI7XG5cbi8qKlxuQ29udmVydHMgZGF0YSBjb250ZW50IHRvIGEgYmFzZTY0LWVuY29kZWQgc3RyaW5nLlxuXG5AcGFyYW0gY29udGVudCAtIERhdGEgY29udGVudCB0byBjb252ZXJ0LlxuQHJldHVybnMgQmFzZTY0LWVuY29kZWQgc3RyaW5nLlxuKi9cbmV4cG9ydCBmdW5jdGlvbiBjb252ZXJ0RGF0YUNvbnRlbnRUb0Jhc2U2NFN0cmluZyhjb250ZW50OiBEYXRhQ29udGVudCk6IHN0cmluZyB7XG4gIGlmICh0eXBlb2YgY29udGVudCA9PT0gJ3N0cmluZycpIHtcbiAgICByZXR1cm4gY29udGVudDtcbiAgfVxuXG4gIGlmIChjb250ZW50IGluc3RhbmNlb2YgQXJyYXlCdWZmZXIpIHtcbiAgICByZXR1cm4gY29udmVydFVpbnQ4QXJyYXlUb0Jhc2U2NChuZXcgVWludDhBcnJheShjb250ZW50KSk7XG4gIH1cblxuICByZXR1cm4gY29udmVydFVpbnQ4QXJyYXlUb0Jhc2U2NChjb250ZW50KTtcbn1cblxuLyoqXG5Db252ZXJ0cyBkYXRhIGNvbnRlbnQgdG8gYSBVaW50OEFycmF5LlxuXG5AcGFyYW0gY29udGVudCAtIERhdGEgY29udGVudCB0byBjb252ZXJ0LlxuQHJldHVybnMgVWludDhBcnJheS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNvbnZlcnREYXRhQ29udGVudFRvVWludDhBcnJheShcbiAgY29udGVudDogRGF0YUNvbnRlbnQsXG4pOiBVaW50OEFycmF5IHtcbiAgaWYgKGNvbnRlbnQgaW5zdGFuY2VvZiBVaW50OEFycmF5KSB7XG4gICAgcmV0dXJuIGNvbnRlbnQ7XG4gIH1cblxuICBpZiAodHlwZW9mIGNvbnRlbnQgPT09ICdzdHJpbmcnKSB7XG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiBjb252ZXJ0QmFzZTY0VG9VaW50OEFycmF5KGNvbnRlbnQpO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICB0aHJvdyBuZXcgSW52YWxpZERhdGFDb250ZW50RXJyb3Ioe1xuICAgICAgICBtZXNzYWdlOlxuICAgICAgICAgICdJbnZhbGlkIGRhdGEgY29udGVudC4gQ29udGVudCBzdHJpbmcgaXMgbm90IGEgYmFzZTY0LWVuY29kZWQgbWVkaWEuJyxcbiAgICAgICAgY29udGVudCxcbiAgICAgICAgY2F1c2U6IGVycm9yLFxuICAgICAgfSk7XG4gICAgfVxuICB9XG5cbiAgaWYgKGNvbnRlbnQgaW5zdGFuY2VvZiBBcnJheUJ1ZmZlcikge1xuICAgIHJldHVybiBuZXcgVWludDhBcnJheShjb250ZW50KTtcbiAgfVxuXG4gIHRocm93IG5ldyBJbnZhbGlkRGF0YUNvbnRlbnRFcnJvcih7IGNvbnRlbnQgfSk7XG59XG5cbi8qKlxuICogQ29udmVydHMgYSBVaW50OEFycmF5IHRvIGEgc3RyaW5nIG9mIHRleHQuXG4gKlxuICogQHBhcmFtIHVpbnQ4QXJyYXkgLSBUaGUgVWludDhBcnJheSB0byBjb252ZXJ0LlxuICogQHJldHVybnMgVGhlIGNvbnZlcnRlZCBzdHJpbmcuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjb252ZXJ0VWludDhBcnJheVRvVGV4dCh1aW50OEFycmF5OiBVaW50OEFycmF5KTogc3RyaW5nIHtcbiAgdHJ5IHtcbiAgICByZXR1cm4gbmV3IFRleHREZWNvZGVyKCkuZGVjb2RlKHVpbnQ4QXJyYXkpO1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIHRocm93IG5ldyBFcnJvcignRXJyb3IgZGVjb2RpbmcgVWludDhBcnJheSB0byB0ZXh0Jyk7XG4gIH1cbn1cbiIsImltcG9ydCB7IEFJU0RLRXJyb3IgfSBmcm9tICdAYWktc2RrL3Byb3ZpZGVyJztcblxuY29uc3QgbmFtZSA9ICdBSV9JbnZhbGlkRGF0YUNvbnRlbnRFcnJvcic7XG5jb25zdCBtYXJrZXIgPSBgdmVyY2VsLmFpLmVycm9yLiR7bmFtZX1gO1xuY29uc3Qgc3ltYm9sID0gU3ltYm9sLmZvcihtYXJrZXIpO1xuXG5leHBvcnQgY2xhc3MgSW52YWxpZERhdGFDb250ZW50RXJyb3IgZXh0ZW5kcyBBSVNES0Vycm9yIHtcbiAgcHJpdmF0ZSByZWFkb25seSBbc3ltYm9sXSA9IHRydWU7IC8vIHVzZWQgaW4gaXNJbnN0YW5jZVxuXG4gIHJlYWRvbmx5IGNvbnRlbnQ6IHVua25vd247XG5cbiAgY29uc3RydWN0b3Ioe1xuICAgIGNvbnRlbnQsXG4gICAgY2F1c2UsXG4gICAgbWVzc2FnZSA9IGBJbnZhbGlkIGRhdGEgY29udGVudC4gRXhwZWN0ZWQgYSBiYXNlNjQgc3RyaW5nLCBVaW50OEFycmF5LCBBcnJheUJ1ZmZlciwgb3IgQnVmZmVyLCBidXQgZ290ICR7dHlwZW9mIGNvbnRlbnR9LmAsXG4gIH06IHtcbiAgICBjb250ZW50OiB1bmtub3duO1xuICAgIGNhdXNlPzogdW5rbm93bjtcbiAgICBtZXNzYWdlPzogc3RyaW5nO1xuICB9KSB7XG4gICAgc3VwZXIoeyBuYW1lLCBtZXNzYWdlLCBjYXVzZSB9KTtcblxuICAgIHRoaXMuY29udGVudCA9IGNvbnRlbnQ7XG4gIH1cblxuICBzdGF0aWMgaXNJbnN0YW5jZShlcnJvcjogdW5rbm93bik6IGVycm9yIGlzIEludmFsaWREYXRhQ29udGVudEVycm9yIHtcbiAgICByZXR1cm4gQUlTREtFcnJvci5oYXNNYXJrZXIoZXJyb3IsIG1hcmtlcik7XG4gIH1cblxuICAvKipcbiAgICogQGRlcHJlY2F0ZWQgdXNlIGBpc0luc3RhbmNlYCBpbnN0ZWFkXG4gICAqL1xuICBzdGF0aWMgaXNJbnZhbGlkRGF0YUNvbnRlbnRFcnJvcihcbiAgICBlcnJvcjogdW5rbm93bixcbiAgKTogZXJyb3IgaXMgSW52YWxpZERhdGFDb250ZW50RXJyb3Ige1xuICAgIHJldHVybiAoXG4gICAgICBlcnJvciBpbnN0YW5jZW9mIEVycm9yICYmXG4gICAgICBlcnJvci5uYW1lID09PSBuYW1lICYmXG4gICAgICAoZXJyb3IgYXMgSW52YWxpZERhdGFDb250ZW50RXJyb3IpLmNvbnRlbnQgIT0gbnVsbFxuICAgICk7XG4gIH1cblxuICAvKipcbiAgICogQGRlcHJlY2F0ZWQgRG8gbm90IHVzZSB0aGlzIG1ldGhvZC4gSXQgd2lsbCBiZSByZW1vdmVkIGluIHRoZSBuZXh0IG1ham9yIHZlcnNpb24uXG4gICAqL1xuICB0b0pTT04oKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIG5hbWU6IHRoaXMubmFtZSxcbiAgICAgIG1lc3NhZ2U6IHRoaXMubWVzc2FnZSxcbiAgICAgIHN0YWNrOiB0aGlzLnN0YWNrLFxuICAgICAgY2F1c2U6IHRoaXMuY2F1c2UsXG4gICAgICBjb250ZW50OiB0aGlzLmNvbnRlbnQsXG4gICAgfTtcbiAgfVxufVxuIiwiaW1wb3J0IHsgQUlTREtFcnJvciB9IGZyb20gJ0BhaS1zZGsvcHJvdmlkZXInO1xuXG5jb25zdCBuYW1lID0gJ0FJX0ludmFsaWRNZXNzYWdlUm9sZUVycm9yJztcbmNvbnN0IG1hcmtlciA9IGB2ZXJjZWwuYWkuZXJyb3IuJHtuYW1lfWA7XG5jb25zdCBzeW1ib2wgPSBTeW1ib2wuZm9yKG1hcmtlcik7XG5cbmV4cG9ydCBjbGFzcyBJbnZhbGlkTWVzc2FnZVJvbGVFcnJvciBleHRlbmRzIEFJU0RLRXJyb3Ige1xuICBwcml2YXRlIHJlYWRvbmx5IFtzeW1ib2xdID0gdHJ1ZTsgLy8gdXNlZCBpbiBpc0luc3RhbmNlXG5cbiAgcmVhZG9ubHkgcm9sZTogc3RyaW5nO1xuXG4gIGNvbnN0cnVjdG9yKHtcbiAgICByb2xlLFxuICAgIG1lc3NhZ2UgPSBgSW52YWxpZCBtZXNzYWdlIHJvbGU6ICcke3JvbGV9Jy4gTXVzdCBiZSBvbmUgb2Y6IFwic3lzdGVtXCIsIFwidXNlclwiLCBcImFzc2lzdGFudFwiLCBcInRvb2xcIi5gLFxuICB9OiB7XG4gICAgcm9sZTogc3RyaW5nO1xuICAgIG1lc3NhZ2U/OiBzdHJpbmc7XG4gIH0pIHtcbiAgICBzdXBlcih7IG5hbWUsIG1lc3NhZ2UgfSk7XG5cbiAgICB0aGlzLnJvbGUgPSByb2xlO1xuICB9XG5cbiAgc3RhdGljIGlzSW5zdGFuY2UoZXJyb3I6IHVua25vd24pOiBlcnJvciBpcyBJbnZhbGlkTWVzc2FnZVJvbGVFcnJvciB7XG4gICAgcmV0dXJuIEFJU0RLRXJyb3IuaGFzTWFya2VyKGVycm9yLCBtYXJrZXIpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBkZXByZWNhdGVkIHVzZSBgaXNJbnN0YW5jZWAgaW5zdGVhZFxuICAgKi9cbiAgc3RhdGljIGlzSW52YWxpZE1lc3NhZ2VSb2xlRXJyb3IoXG4gICAgZXJyb3I6IHVua25vd24sXG4gICk6IGVycm9yIGlzIEludmFsaWRNZXNzYWdlUm9sZUVycm9yIHtcbiAgICByZXR1cm4gKFxuICAgICAgZXJyb3IgaW5zdGFuY2VvZiBFcnJvciAmJlxuICAgICAgZXJyb3IubmFtZSA9PT0gbmFtZSAmJlxuICAgICAgdHlwZW9mIChlcnJvciBhcyBJbnZhbGlkTWVzc2FnZVJvbGVFcnJvcikucm9sZSA9PT0gJ3N0cmluZydcbiAgICApO1xuICB9XG5cbiAgLyoqXG4gICAqIEBkZXByZWNhdGVkIERvIG5vdCB1c2UgdGhpcyBtZXRob2QuIEl0IHdpbGwgYmUgcmVtb3ZlZCBpbiB0aGUgbmV4dCBtYWpvciB2ZXJzaW9uLlxuICAgKi9cbiAgdG9KU09OKCkge1xuICAgIHJldHVybiB7XG4gICAgICBuYW1lOiB0aGlzLm5hbWUsXG4gICAgICBtZXNzYWdlOiB0aGlzLm1lc3NhZ2UsXG4gICAgICBzdGFjazogdGhpcy5zdGFjayxcblxuICAgICAgcm9sZTogdGhpcy5yb2xlLFxuICAgIH07XG4gIH1cbn1cbiIsImltcG9ydCB7IEludmFsaWRQcm9tcHRFcnJvciB9IGZyb20gJ0BhaS1zZGsvcHJvdmlkZXInO1xuaW1wb3J0IHsgQ29yZU1lc3NhZ2UgfSBmcm9tICcuL21lc3NhZ2UnO1xuaW1wb3J0IHsgUHJvbXB0IH0gZnJvbSAnLi9wcm9tcHQnO1xuXG5leHBvcnQgdHlwZSBWYWxpZGF0ZWRQcm9tcHQgPVxuICB8IHtcbiAgICAgIHR5cGU6ICdwcm9tcHQnO1xuICAgICAgcHJvbXB0OiBzdHJpbmc7XG4gICAgICBtZXNzYWdlczogdW5kZWZpbmVkO1xuICAgICAgc3lzdGVtPzogc3RyaW5nO1xuICAgIH1cbiAgfCB7XG4gICAgICB0eXBlOiAnbWVzc2FnZXMnO1xuICAgICAgcHJvbXB0OiB1bmRlZmluZWQ7XG4gICAgICBtZXNzYWdlczogQ29yZU1lc3NhZ2VbXTtcbiAgICAgIHN5c3RlbT86IHN0cmluZztcbiAgICB9O1xuXG5leHBvcnQgZnVuY3Rpb24gZ2V0VmFsaWRhdGVkUHJvbXB0KHByb21wdDogUHJvbXB0KTogVmFsaWRhdGVkUHJvbXB0IHtcbiAgaWYgKHByb21wdC5wcm9tcHQgPT0gbnVsbCAmJiBwcm9tcHQubWVzc2FnZXMgPT0gbnVsbCkge1xuICAgIHRocm93IG5ldyBJbnZhbGlkUHJvbXB0RXJyb3Ioe1xuICAgICAgcHJvbXB0LFxuICAgICAgbWVzc2FnZTogJ3Byb21wdCBvciBtZXNzYWdlcyBtdXN0IGJlIGRlZmluZWQnLFxuICAgIH0pO1xuICB9XG5cbiAgaWYgKHByb21wdC5wcm9tcHQgIT0gbnVsbCAmJiBwcm9tcHQubWVzc2FnZXMgIT0gbnVsbCkge1xuICAgIHRocm93IG5ldyBJbnZhbGlkUHJvbXB0RXJyb3Ioe1xuICAgICAgcHJvbXB0LFxuICAgICAgbWVzc2FnZTogJ3Byb21wdCBhbmQgbWVzc2FnZXMgY2Fubm90IGJlIGRlZmluZWQgYXQgdGhlIHNhbWUgdGltZScsXG4gICAgfSk7XG4gIH1cblxuICBpZiAocHJvbXB0Lm1lc3NhZ2VzICE9IG51bGwpIHtcbiAgICBmb3IgKGNvbnN0IG1lc3NhZ2Ugb2YgcHJvbXB0Lm1lc3NhZ2VzKSB7XG4gICAgICBpZiAobWVzc2FnZS5yb2xlID09PSAnc3lzdGVtJyAmJiB0eXBlb2YgbWVzc2FnZS5jb250ZW50ICE9PSAnc3RyaW5nJykge1xuICAgICAgICB0aHJvdyBuZXcgSW52YWxpZFByb21wdEVycm9yKHtcbiAgICAgICAgICBwcm9tcHQsXG4gICAgICAgICAgbWVzc2FnZTogJ3N5c3RlbSBtZXNzYWdlIGNvbnRlbnQgbXVzdCBiZSBhIHN0cmluZycsXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBwcm9tcHQucHJvbXB0ICE9IG51bGxcbiAgICA/IHtcbiAgICAgICAgdHlwZTogJ3Byb21wdCcsXG4gICAgICAgIHByb21wdDogcHJvbXB0LnByb21wdCxcbiAgICAgICAgbWVzc2FnZXM6IHVuZGVmaW5lZCxcbiAgICAgICAgc3lzdGVtOiBwcm9tcHQuc3lzdGVtLFxuICAgICAgfVxuICAgIDoge1xuICAgICAgICB0eXBlOiAnbWVzc2FnZXMnLFxuICAgICAgICBwcm9tcHQ6IHVuZGVmaW5lZCxcbiAgICAgICAgbWVzc2FnZXM6IHByb21wdC5tZXNzYWdlcyEsIC8vIG9ubHkgcG9zc2libGUgY2FzZSBiYyBvZiBjaGVja3MgYWJvdmVcbiAgICAgICAgc3lzdGVtOiBwcm9tcHQuc3lzdGVtLFxuICAgICAgfTtcbn1cbiIsImltcG9ydCB7IEFJU0RLRXJyb3IgfSBmcm9tICdAYWktc2RrL3Byb3ZpZGVyJztcblxuY29uc3QgbmFtZSA9ICdBSV9JbnZhbGlkQXJndW1lbnRFcnJvcic7XG5jb25zdCBtYXJrZXIgPSBgdmVyY2VsLmFpLmVycm9yLiR7bmFtZX1gO1xuY29uc3Qgc3ltYm9sID0gU3ltYm9sLmZvcihtYXJrZXIpO1xuXG5leHBvcnQgY2xhc3MgSW52YWxpZEFyZ3VtZW50RXJyb3IgZXh0ZW5kcyBBSVNES0Vycm9yIHtcbiAgcHJpdmF0ZSByZWFkb25seSBbc3ltYm9sXSA9IHRydWU7IC8vIHVzZWQgaW4gaXNJbnN0YW5jZVxuXG4gIHJlYWRvbmx5IHBhcmFtZXRlcjogc3RyaW5nO1xuICByZWFkb25seSB2YWx1ZTogdW5rbm93bjtcblxuICBjb25zdHJ1Y3Rvcih7XG4gICAgcGFyYW1ldGVyLFxuICAgIHZhbHVlLFxuICAgIG1lc3NhZ2UsXG4gIH06IHtcbiAgICBwYXJhbWV0ZXI6IHN0cmluZztcbiAgICB2YWx1ZTogdW5rbm93bjtcbiAgICBtZXNzYWdlOiBzdHJpbmc7XG4gIH0pIHtcbiAgICBzdXBlcih7XG4gICAgICBuYW1lLFxuICAgICAgbWVzc2FnZTogYEludmFsaWQgYXJndW1lbnQgZm9yIHBhcmFtZXRlciAke3BhcmFtZXRlcn06ICR7bWVzc2FnZX1gLFxuICAgIH0pO1xuXG4gICAgdGhpcy5wYXJhbWV0ZXIgPSBwYXJhbWV0ZXI7XG4gICAgdGhpcy52YWx1ZSA9IHZhbHVlO1xuICB9XG5cbiAgc3RhdGljIGlzSW5zdGFuY2UoZXJyb3I6IHVua25vd24pOiBlcnJvciBpcyBJbnZhbGlkQXJndW1lbnRFcnJvciB7XG4gICAgcmV0dXJuIEFJU0RLRXJyb3IuaGFzTWFya2VyKGVycm9yLCBtYXJrZXIpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBkZXByZWNhdGVkIHVzZSBgaXNJbnN0YW5jZWAgaW5zdGVhZFxuICAgKi9cbiAgc3RhdGljIGlzSW52YWxpZEFyZ3VtZW50RXJyb3IoZXJyb3I6IHVua25vd24pOiBlcnJvciBpcyBJbnZhbGlkQXJndW1lbnRFcnJvciB7XG4gICAgcmV0dXJuIChcbiAgICAgIGVycm9yIGluc3RhbmNlb2YgRXJyb3IgJiZcbiAgICAgIGVycm9yLm5hbWUgPT09IG5hbWUgJiZcbiAgICAgIHR5cGVvZiAoZXJyb3IgYXMgSW52YWxpZEFyZ3VtZW50RXJyb3IpLnBhcmFtZXRlciA9PT0gJ3N0cmluZycgJiZcbiAgICAgIHR5cGVvZiAoZXJyb3IgYXMgSW52YWxpZEFyZ3VtZW50RXJyb3IpLnZhbHVlID09PSAnc3RyaW5nJ1xuICAgICk7XG4gIH1cblxuICB0b0pTT04oKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIG5hbWU6IHRoaXMubmFtZSxcbiAgICAgIG1lc3NhZ2U6IHRoaXMubWVzc2FnZSxcbiAgICAgIHN0YWNrOiB0aGlzLnN0YWNrLFxuXG4gICAgICBwYXJhbWV0ZXI6IHRoaXMucGFyYW1ldGVyLFxuICAgICAgdmFsdWU6IHRoaXMudmFsdWUsXG4gICAgfTtcbiAgfVxufVxuIiwiaW1wb3J0IHsgSW52YWxpZEFyZ3VtZW50RXJyb3IgfSBmcm9tICcuLi8uLi9lcnJvcnMvaW52YWxpZC1hcmd1bWVudC1lcnJvcic7XG5pbXBvcnQgeyBDYWxsU2V0dGluZ3MgfSBmcm9tICcuL2NhbGwtc2V0dGluZ3MnO1xuXG4vKipcbiAqIFZhbGlkYXRlcyBjYWxsIHNldHRpbmdzIGFuZCBzZXRzIGRlZmF1bHQgdmFsdWVzLlxuICovXG5leHBvcnQgZnVuY3Rpb24gcHJlcGFyZUNhbGxTZXR0aW5ncyh7XG4gIG1heFRva2VucyxcbiAgdGVtcGVyYXR1cmUsXG4gIHRvcFAsXG4gIHByZXNlbmNlUGVuYWx0eSxcbiAgZnJlcXVlbmN5UGVuYWx0eSxcbiAgc3RvcFNlcXVlbmNlcyxcbiAgc2VlZCxcbiAgbWF4UmV0cmllcyxcbn06IENhbGxTZXR0aW5ncyk6IENhbGxTZXR0aW5ncyB7XG4gIGlmIChtYXhUb2tlbnMgIT0gbnVsbCkge1xuICAgIGlmICghTnVtYmVyLmlzSW50ZWdlcihtYXhUb2tlbnMpKSB7XG4gICAgICB0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50RXJyb3Ioe1xuICAgICAgICBwYXJhbWV0ZXI6ICdtYXhUb2tlbnMnLFxuICAgICAgICB2YWx1ZTogbWF4VG9rZW5zLFxuICAgICAgICBtZXNzYWdlOiAnbWF4VG9rZW5zIG11c3QgYmUgYW4gaW50ZWdlcicsXG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBpZiAobWF4VG9rZW5zIDwgMSkge1xuICAgICAgdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudEVycm9yKHtcbiAgICAgICAgcGFyYW1ldGVyOiAnbWF4VG9rZW5zJyxcbiAgICAgICAgdmFsdWU6IG1heFRva2VucyxcbiAgICAgICAgbWVzc2FnZTogJ21heFRva2VucyBtdXN0IGJlID49IDEnLFxuICAgICAgfSk7XG4gICAgfVxuICB9XG5cbiAgaWYgKHRlbXBlcmF0dXJlICE9IG51bGwpIHtcbiAgICBpZiAodHlwZW9mIHRlbXBlcmF0dXJlICE9PSAnbnVtYmVyJykge1xuICAgICAgdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudEVycm9yKHtcbiAgICAgICAgcGFyYW1ldGVyOiAndGVtcGVyYXR1cmUnLFxuICAgICAgICB2YWx1ZTogdGVtcGVyYXR1cmUsXG4gICAgICAgIG1lc3NhZ2U6ICd0ZW1wZXJhdHVyZSBtdXN0IGJlIGEgbnVtYmVyJyxcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuXG4gIGlmICh0b3BQICE9IG51bGwpIHtcbiAgICBpZiAodHlwZW9mIHRvcFAgIT09ICdudW1iZXInKSB7XG4gICAgICB0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50RXJyb3Ioe1xuICAgICAgICBwYXJhbWV0ZXI6ICd0b3BQJyxcbiAgICAgICAgdmFsdWU6IHRvcFAsXG4gICAgICAgIG1lc3NhZ2U6ICd0b3BQIG11c3QgYmUgYSBudW1iZXInLFxuICAgICAgfSk7XG4gICAgfVxuICB9XG5cbiAgaWYgKHByZXNlbmNlUGVuYWx0eSAhPSBudWxsKSB7XG4gICAgaWYgKHR5cGVvZiBwcmVzZW5jZVBlbmFsdHkgIT09ICdudW1iZXInKSB7XG4gICAgICB0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50RXJyb3Ioe1xuICAgICAgICBwYXJhbWV0ZXI6ICdwcmVzZW5jZVBlbmFsdHknLFxuICAgICAgICB2YWx1ZTogcHJlc2VuY2VQZW5hbHR5LFxuICAgICAgICBtZXNzYWdlOiAncHJlc2VuY2VQZW5hbHR5IG11c3QgYmUgYSBudW1iZXInLFxuICAgICAgfSk7XG4gICAgfVxuICB9XG5cbiAgaWYgKGZyZXF1ZW5jeVBlbmFsdHkgIT0gbnVsbCkge1xuICAgIGlmICh0eXBlb2YgZnJlcXVlbmN5UGVuYWx0eSAhPT0gJ251bWJlcicpIHtcbiAgICAgIHRocm93IG5ldyBJbnZhbGlkQXJndW1lbnRFcnJvcih7XG4gICAgICAgIHBhcmFtZXRlcjogJ2ZyZXF1ZW5jeVBlbmFsdHknLFxuICAgICAgICB2YWx1ZTogZnJlcXVlbmN5UGVuYWx0eSxcbiAgICAgICAgbWVzc2FnZTogJ2ZyZXF1ZW5jeVBlbmFsdHkgbXVzdCBiZSBhIG51bWJlcicsXG4gICAgICB9KTtcbiAgICB9XG4gIH1cblxuICBpZiAoc2VlZCAhPSBudWxsKSB7XG4gICAgaWYgKCFOdW1iZXIuaXNJbnRlZ2VyKHNlZWQpKSB7XG4gICAgICB0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50RXJyb3Ioe1xuICAgICAgICBwYXJhbWV0ZXI6ICdzZWVkJyxcbiAgICAgICAgdmFsdWU6IHNlZWQsXG4gICAgICAgIG1lc3NhZ2U6ICdzZWVkIG11c3QgYmUgYW4gaW50ZWdlcicsXG4gICAgICB9KTtcbiAgICB9XG4gIH1cblxuICBpZiAobWF4UmV0cmllcyAhPSBudWxsKSB7XG4gICAgaWYgKCFOdW1iZXIuaXNJbnRlZ2VyKG1heFJldHJpZXMpKSB7XG4gICAgICB0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50RXJyb3Ioe1xuICAgICAgICBwYXJhbWV0ZXI6ICdtYXhSZXRyaWVzJyxcbiAgICAgICAgdmFsdWU6IG1heFJldHJpZXMsXG4gICAgICAgIG1lc3NhZ2U6ICdtYXhSZXRyaWVzIG11c3QgYmUgYW4gaW50ZWdlcicsXG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBpZiAobWF4UmV0cmllcyA8IDApIHtcbiAgICAgIHRocm93IG5ldyBJbnZhbGlkQXJndW1lbnRFcnJvcih7XG4gICAgICAgIHBhcmFtZXRlcjogJ21heFJldHJpZXMnLFxuICAgICAgICB2YWx1ZTogbWF4UmV0cmllcyxcbiAgICAgICAgbWVzc2FnZTogJ21heFJldHJpZXMgbXVzdCBiZSA+PSAwJyxcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB7XG4gICAgbWF4VG9rZW5zLFxuICAgIHRlbXBlcmF0dXJlOiB0ZW1wZXJhdHVyZSA/PyAwLFxuICAgIHRvcFAsXG4gICAgcHJlc2VuY2VQZW5hbHR5LFxuICAgIGZyZXF1ZW5jeVBlbmFsdHksXG4gICAgc3RvcFNlcXVlbmNlczpcbiAgICAgIHN0b3BTZXF1ZW5jZXMgIT0gbnVsbCAmJiBzdG9wU2VxdWVuY2VzLmxlbmd0aCA+IDBcbiAgICAgICAgPyBzdG9wU2VxdWVuY2VzXG4gICAgICAgIDogdW5kZWZpbmVkLFxuICAgIHNlZWQsXG4gICAgbWF4UmV0cmllczogbWF4UmV0cmllcyA/PyAyLFxuICB9O1xufVxuIiwiaW1wb3J0IHtcbiAgTGFuZ3VhZ2VNb2RlbFYxRnVuY3Rpb25Ub29sLFxuICBMYW5ndWFnZU1vZGVsVjFUb29sQ2hvaWNlLFxufSBmcm9tICdAYWktc2RrL3Byb3ZpZGVyJztcbmltcG9ydCB7IGFzU2NoZW1hIH0gZnJvbSAnQGFpLXNkay91aS11dGlscyc7XG5pbXBvcnQgeyBDb3JlVG9vbCB9IGZyb20gJy4uL3Rvb2wvdG9vbCc7XG5pbXBvcnQgeyBDb3JlVG9vbENob2ljZSB9IGZyb20gJy4uL3R5cGVzL2xhbmd1YWdlLW1vZGVsJztcbmltcG9ydCB7IGlzTm9uRW1wdHlPYmplY3QgfSBmcm9tICcuLi91dGlsL2lzLW5vbi1lbXB0eS1vYmplY3QnO1xuXG5leHBvcnQgZnVuY3Rpb24gcHJlcGFyZVRvb2xzQW5kVG9vbENob2ljZTxcbiAgVE9PTFMgZXh0ZW5kcyBSZWNvcmQ8c3RyaW5nLCBDb3JlVG9vbD4sXG4+KHtcbiAgdG9vbHMsXG4gIHRvb2xDaG9pY2UsXG59OiB7XG4gIHRvb2xzOiBUT09MUyB8IHVuZGVmaW5lZDtcbiAgdG9vbENob2ljZTogQ29yZVRvb2xDaG9pY2U8VE9PTFM+IHwgdW5kZWZpbmVkO1xufSk6IHtcbiAgdG9vbHM6IExhbmd1YWdlTW9kZWxWMUZ1bmN0aW9uVG9vbFtdIHwgdW5kZWZpbmVkO1xuICB0b29sQ2hvaWNlOiBMYW5ndWFnZU1vZGVsVjFUb29sQ2hvaWNlIHwgdW5kZWZpbmVkO1xufSB7XG4gIGlmICghaXNOb25FbXB0eU9iamVjdCh0b29scykpIHtcbiAgICByZXR1cm4ge1xuICAgICAgdG9vbHM6IHVuZGVmaW5lZCxcbiAgICAgIHRvb2xDaG9pY2U6IHVuZGVmaW5lZCxcbiAgICB9O1xuICB9XG5cbiAgcmV0dXJuIHtcbiAgICB0b29sczogT2JqZWN0LmVudHJpZXModG9vbHMpLm1hcCgoW25hbWUsIHRvb2xdKSA9PiAoe1xuICAgICAgdHlwZTogJ2Z1bmN0aW9uJyBhcyBjb25zdCxcbiAgICAgIG5hbWUsXG4gICAgICBkZXNjcmlwdGlvbjogdG9vbC5kZXNjcmlwdGlvbixcbiAgICAgIHBhcmFtZXRlcnM6IGFzU2NoZW1hKHRvb2wucGFyYW1ldGVycykuanNvblNjaGVtYSxcbiAgICB9KSksXG4gICAgdG9vbENob2ljZTpcbiAgICAgIHRvb2xDaG9pY2UgPT0gbnVsbFxuICAgICAgICA/IHsgdHlwZTogJ2F1dG8nIH1cbiAgICAgICAgOiB0eXBlb2YgdG9vbENob2ljZSA9PT0gJ3N0cmluZydcbiAgICAgICAgPyB7IHR5cGU6IHRvb2xDaG9pY2UgfVxuICAgICAgICA6IHsgdHlwZTogJ3Rvb2wnIGFzIGNvbnN0LCB0b29sTmFtZTogdG9vbENob2ljZS50b29sTmFtZSBhcyBzdHJpbmcgfSxcbiAgfTtcbn1cbiIsImV4cG9ydCBmdW5jdGlvbiBpc05vbkVtcHR5T2JqZWN0KFxuICBvYmplY3Q6IFJlY29yZDxzdHJpbmcsIHVua25vd24+IHwgdW5kZWZpbmVkIHwgbnVsbCxcbik6IG9iamVjdCBpcyBSZWNvcmQ8c3RyaW5nLCB1bmtub3duPiB7XG4gIHJldHVybiBvYmplY3QgIT0gbnVsbCAmJiBPYmplY3Qua2V5cyhvYmplY3QpLmxlbmd0aCA+IDA7XG59XG4iLCIvKipcblJlcHJlc2VudHMgdGhlIG51bWJlciBvZiB0b2tlbnMgdXNlZCBpbiBhIHByb21wdCBhbmQgY29tcGxldGlvbi5cbiAqL1xuZXhwb3J0IHR5cGUgQ29tcGxldGlvblRva2VuVXNhZ2UgPSB7XG4gIC8qKlxuVGhlIG51bWJlciBvZiB0b2tlbnMgdXNlZCBpbiB0aGUgcHJvbXB0LlxuICAgKi9cbiAgcHJvbXB0VG9rZW5zOiBudW1iZXI7XG5cbiAgLyoqXG5UaGUgbnVtYmVyIG9mIHRva2VucyB1c2VkIGluIHRoZSBjb21wbGV0aW9uLlxuICovXG4gIGNvbXBsZXRpb25Ub2tlbnM6IG51bWJlcjtcblxuICAvKipcblRoZSB0b3RhbCBudW1iZXIgb2YgdG9rZW5zIHVzZWQgKHByb21wdFRva2VucyArIGNvbXBsZXRpb25Ub2tlbnMpLlxuICAgKi9cbiAgdG90YWxUb2tlbnM6IG51bWJlcjtcbn07XG5cbi8qKlxuUmVwcmVzZW50cyB0aGUgbnVtYmVyIG9mIHRva2VucyB1c2VkIGluIGFuIGVtYmVkZGluZy5cbiAqL1xuZXhwb3J0IHR5cGUgRW1iZWRkaW5nVG9rZW5Vc2FnZSA9IHtcbiAgLyoqXG5UaGUgbnVtYmVyIG9mIHRva2VucyB1c2VkIGluIHRoZSBlbWJlZGRpbmcuXG4gICAqL1xuICB0b2tlbnM6IG51bWJlcjtcbn07XG5cbmV4cG9ydCBmdW5jdGlvbiBjYWxjdWxhdGVDb21wbGV0aW9uVG9rZW5Vc2FnZSh1c2FnZToge1xuICBwcm9tcHRUb2tlbnM6IG51bWJlcjtcbiAgY29tcGxldGlvblRva2VuczogbnVtYmVyO1xufSk6IENvbXBsZXRpb25Ub2tlblVzYWdlIHtcbiAgcmV0dXJuIHtcbiAgICBwcm9tcHRUb2tlbnM6IHVzYWdlLnByb21wdFRva2VucyxcbiAgICBjb21wbGV0aW9uVG9rZW5zOiB1c2FnZS5jb21wbGV0aW9uVG9rZW5zLFxuICAgIHRvdGFsVG9rZW5zOiB1c2FnZS5wcm9tcHRUb2tlbnMgKyB1c2FnZS5jb21wbGV0aW9uVG9rZW5zLFxuICB9O1xufVxuIiwiaW1wb3J0IHsgQUlTREtFcnJvciwgZ2V0RXJyb3JNZXNzYWdlIH0gZnJvbSAnQGFpLXNkay9wcm92aWRlcic7XG5cbmNvbnN0IG5hbWUgPSAnQUlfSW52YWxpZFRvb2xBcmd1bWVudHNFcnJvcic7XG5jb25zdCBtYXJrZXIgPSBgdmVyY2VsLmFpLmVycm9yLiR7bmFtZX1gO1xuY29uc3Qgc3ltYm9sID0gU3ltYm9sLmZvcihtYXJrZXIpO1xuXG5leHBvcnQgY2xhc3MgSW52YWxpZFRvb2xBcmd1bWVudHNFcnJvciBleHRlbmRzIEFJU0RLRXJyb3Ige1xuICBwcml2YXRlIHJlYWRvbmx5IFtzeW1ib2xdID0gdHJ1ZTsgLy8gdXNlZCBpbiBpc0luc3RhbmNlXG5cbiAgcmVhZG9ubHkgdG9vbE5hbWU6IHN0cmluZztcbiAgcmVhZG9ubHkgdG9vbEFyZ3M6IHN0cmluZztcblxuICBjb25zdHJ1Y3Rvcih7XG4gICAgdG9vbEFyZ3MsXG4gICAgdG9vbE5hbWUsXG4gICAgY2F1c2UsXG4gICAgbWVzc2FnZSA9IGBJbnZhbGlkIGFyZ3VtZW50cyBmb3IgdG9vbCAke3Rvb2xOYW1lfTogJHtnZXRFcnJvck1lc3NhZ2UoXG4gICAgICBjYXVzZSxcbiAgICApfWAsXG4gIH06IHtcbiAgICBtZXNzYWdlPzogc3RyaW5nO1xuICAgIHRvb2xBcmdzOiBzdHJpbmc7XG4gICAgdG9vbE5hbWU6IHN0cmluZztcbiAgICBjYXVzZTogdW5rbm93bjtcbiAgfSkge1xuICAgIHN1cGVyKHsgbmFtZSwgbWVzc2FnZSwgY2F1c2UgfSk7XG5cbiAgICB0aGlzLnRvb2xBcmdzID0gdG9vbEFyZ3M7XG4gICAgdGhpcy50b29sTmFtZSA9IHRvb2xOYW1lO1xuICB9XG5cbiAgc3RhdGljIGlzSW5zdGFuY2UoZXJyb3I6IHVua25vd24pOiBlcnJvciBpcyBJbnZhbGlkVG9vbEFyZ3VtZW50c0Vycm9yIHtcbiAgICByZXR1cm4gQUlTREtFcnJvci5oYXNNYXJrZXIoZXJyb3IsIG1hcmtlcik7XG4gIH1cblxuICAvKipcbiAgICogQGRlcHJlY2F0ZWQgdXNlIGBpc0luc3RhbmNlYCBpbnN0ZWFkXG4gICAqL1xuICBzdGF0aWMgaXNJbnZhbGlkVG9vbEFyZ3VtZW50c0Vycm9yKFxuICAgIGVycm9yOiB1bmtub3duLFxuICApOiBlcnJvciBpcyBJbnZhbGlkVG9vbEFyZ3VtZW50c0Vycm9yIHtcbiAgICByZXR1cm4gKFxuICAgICAgZXJyb3IgaW5zdGFuY2VvZiBFcnJvciAmJlxuICAgICAgZXJyb3IubmFtZSA9PT0gbmFtZSAmJlxuICAgICAgdHlwZW9mIChlcnJvciBhcyBJbnZhbGlkVG9vbEFyZ3VtZW50c0Vycm9yKS50b29sTmFtZSA9PT0gJ3N0cmluZycgJiZcbiAgICAgIHR5cGVvZiAoZXJyb3IgYXMgSW52YWxpZFRvb2xBcmd1bWVudHNFcnJvcikudG9vbEFyZ3MgPT09ICdzdHJpbmcnXG4gICAgKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAZGVwcmVjYXRlZCBEbyBub3QgdXNlIHRoaXMgbWV0aG9kLiBJdCB3aWxsIGJlIHJlbW92ZWQgaW4gdGhlIG5leHQgbWFqb3IgdmVyc2lvbi5cbiAgICovXG4gIHRvSlNPTigpIHtcbiAgICByZXR1cm4ge1xuICAgICAgbmFtZTogdGhpcy5uYW1lLFxuICAgICAgbWVzc2FnZTogdGhpcy5tZXNzYWdlLFxuICAgICAgY2F1c2U6IHRoaXMuY2F1c2UsXG4gICAgICBzdGFjazogdGhpcy5zdGFjayxcblxuICAgICAgdG9vbE5hbWU6IHRoaXMudG9vbE5hbWUsXG4gICAgICB0b29sQXJnczogdGhpcy50b29sQXJncyxcbiAgICB9O1xuICB9XG59XG4iLCJpbXBvcnQgeyBBSVNES0Vycm9yIH0gZnJvbSAnQGFpLXNkay9wcm92aWRlcic7XG5cbmNvbnN0IG5hbWUgPSAnQUlfTm9TdWNoVG9vbEVycm9yJztcbmNvbnN0IG1hcmtlciA9IGB2ZXJjZWwuYWkuZXJyb3IuJHtuYW1lfWA7XG5jb25zdCBzeW1ib2wgPSBTeW1ib2wuZm9yKG1hcmtlcik7XG5cbmV4cG9ydCBjbGFzcyBOb1N1Y2hUb29sRXJyb3IgZXh0ZW5kcyBBSVNES0Vycm9yIHtcbiAgcHJpdmF0ZSByZWFkb25seSBbc3ltYm9sXSA9IHRydWU7IC8vIHVzZWQgaW4gaXNJbnN0YW5jZVxuXG4gIHJlYWRvbmx5IHRvb2xOYW1lOiBzdHJpbmc7XG4gIHJlYWRvbmx5IGF2YWlsYWJsZVRvb2xzOiBzdHJpbmdbXSB8IHVuZGVmaW5lZDtcblxuICBjb25zdHJ1Y3Rvcih7XG4gICAgdG9vbE5hbWUsXG4gICAgYXZhaWxhYmxlVG9vbHMgPSB1bmRlZmluZWQsXG4gICAgbWVzc2FnZSA9IGBNb2RlbCB0cmllZCB0byBjYWxsIHVuYXZhaWxhYmxlIHRvb2wgJyR7dG9vbE5hbWV9Jy4gJHtcbiAgICAgIGF2YWlsYWJsZVRvb2xzID09PSB1bmRlZmluZWRcbiAgICAgICAgPyAnTm8gdG9vbHMgYXJlIGF2YWlsYWJsZS4nXG4gICAgICAgIDogYEF2YWlsYWJsZSB0b29sczogJHthdmFpbGFibGVUb29scy5qb2luKCcsICcpfS5gXG4gICAgfWAsXG4gIH06IHtcbiAgICB0b29sTmFtZTogc3RyaW5nO1xuICAgIGF2YWlsYWJsZVRvb2xzPzogc3RyaW5nW10gfCB1bmRlZmluZWQ7XG4gICAgbWVzc2FnZT86IHN0cmluZztcbiAgfSkge1xuICAgIHN1cGVyKHsgbmFtZSwgbWVzc2FnZSB9KTtcblxuICAgIHRoaXMudG9vbE5hbWUgPSB0b29sTmFtZTtcbiAgICB0aGlzLmF2YWlsYWJsZVRvb2xzID0gYXZhaWxhYmxlVG9vbHM7XG4gIH1cblxuICBzdGF0aWMgaXNJbnN0YW5jZShlcnJvcjogdW5rbm93bik6IGVycm9yIGlzIE5vU3VjaFRvb2xFcnJvciB7XG4gICAgcmV0dXJuIEFJU0RLRXJyb3IuaGFzTWFya2VyKGVycm9yLCBtYXJrZXIpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBkZXByZWNhdGVkIHVzZSBgaXNJbnN0YW5jZWAgaW5zdGVhZFxuICAgKi9cbiAgc3RhdGljIGlzTm9TdWNoVG9vbEVycm9yKGVycm9yOiB1bmtub3duKTogZXJyb3IgaXMgTm9TdWNoVG9vbEVycm9yIHtcbiAgICByZXR1cm4gKFxuICAgICAgZXJyb3IgaW5zdGFuY2VvZiBFcnJvciAmJlxuICAgICAgZXJyb3IubmFtZSA9PT0gbmFtZSAmJlxuICAgICAgJ3Rvb2xOYW1lJyBpbiBlcnJvciAmJlxuICAgICAgZXJyb3IudG9vbE5hbWUgIT0gdW5kZWZpbmVkICYmXG4gICAgICB0eXBlb2YgZXJyb3IubmFtZSA9PT0gJ3N0cmluZydcbiAgICApO1xuICB9XG5cbiAgLyoqXG4gICAqIEBkZXByZWNhdGVkIERvIG5vdCB1c2UgdGhpcyBtZXRob2QuIEl0IHdpbGwgYmUgcmVtb3ZlZCBpbiB0aGUgbmV4dCBtYWpvciB2ZXJzaW9uLlxuICAgKi9cbiAgdG9KU09OKCkge1xuICAgIHJldHVybiB7XG4gICAgICBuYW1lOiB0aGlzLm5hbWUsXG4gICAgICBtZXNzYWdlOiB0aGlzLm1lc3NhZ2UsXG4gICAgICBzdGFjazogdGhpcy5zdGFjayxcblxuICAgICAgdG9vbE5hbWU6IHRoaXMudG9vbE5hbWUsXG4gICAgICBhdmFpbGFibGVUb29sczogdGhpcy5hdmFpbGFibGVUb29scyxcbiAgICB9O1xuICB9XG59XG4iLCJleHBvcnQgZnVuY3Rpb24gaXNBc3luY0dlbmVyYXRvcjxULCBUUmV0dXJuLCBUTmV4dD4oXG4gIHZhbHVlOiB1bmtub3duLFxuKTogdmFsdWUgaXMgQXN5bmNHZW5lcmF0b3I8VCwgVFJldHVybiwgVE5leHQ+IHtcbiAgcmV0dXJuIChcbiAgICB2YWx1ZSAhPSBudWxsICYmIHR5cGVvZiB2YWx1ZSA9PT0gJ29iamVjdCcgJiYgU3ltYm9sLmFzeW5jSXRlcmF0b3IgaW4gdmFsdWVcbiAgKTtcbn1cbiIsImV4cG9ydCBmdW5jdGlvbiBpc0dlbmVyYXRvcjxULCBUUmV0dXJuLCBUTmV4dD4oXG4gIHZhbHVlOiB1bmtub3duLFxuKTogdmFsdWUgaXMgR2VuZXJhdG9yPFQsIFRSZXR1cm4sIFROZXh0PiB7XG4gIHJldHVybiB2YWx1ZSAhPSBudWxsICYmIHR5cGVvZiB2YWx1ZSA9PT0gJ29iamVjdCcgJiYgU3ltYm9sLml0ZXJhdG9yIGluIHZhbHVlO1xufVxuIiwiaW1wb3J0IHsgQVBJQ2FsbEVycm9yIH0gZnJvbSAnQGFpLXNkay9wcm92aWRlcic7XG5pbXBvcnQgeyBnZXRFcnJvck1lc3NhZ2UsIGlzQWJvcnRFcnJvciB9IGZyb20gJ0BhaS1zZGsvcHJvdmlkZXItdXRpbHMnO1xuaW1wb3J0IHsgZGVsYXkgfSBmcm9tICcuL2RlbGF5JztcbmltcG9ydCB7IFJldHJ5RXJyb3IgfSBmcm9tICcuL3JldHJ5LWVycm9yJztcblxuZXhwb3J0IHR5cGUgUmV0cnlGdW5jdGlvbiA9IDxPVVRQVVQ+KFxuICBmbjogKCkgPT4gUHJvbWlzZUxpa2U8T1VUUFVUPixcbikgPT4gUHJvbWlzZUxpa2U8T1VUUFVUPjtcblxuLyoqXG5UaGUgYHJldHJ5V2l0aEV4cG9uZW50aWFsQmFja29mZmAgc3RyYXRlZ3kgcmV0cmllcyBhIGZhaWxlZCBBUEkgY2FsbCB3aXRoIGFuIGV4cG9uZW50aWFsIGJhY2tvZmYuXG5Zb3UgY2FuIGNvbmZpZ3VyZSB0aGUgbWF4aW11bSBudW1iZXIgb2YgcmV0cmllcywgdGhlIGluaXRpYWwgZGVsYXksIGFuZCB0aGUgYmFja29mZiBmYWN0b3IuXG4gKi9cbmV4cG9ydCBjb25zdCByZXRyeVdpdGhFeHBvbmVudGlhbEJhY2tvZmYgPVxuICAoe1xuICAgIG1heFJldHJpZXMgPSAyLFxuICAgIGluaXRpYWxEZWxheUluTXMgPSAyMDAwLFxuICAgIGJhY2tvZmZGYWN0b3IgPSAyLFxuICB9ID0ge30pOiBSZXRyeUZ1bmN0aW9uID0+XG4gIGFzeW5jIDxPVVRQVVQ+KGY6ICgpID0+IFByb21pc2VMaWtlPE9VVFBVVD4pID0+XG4gICAgX3JldHJ5V2l0aEV4cG9uZW50aWFsQmFja29mZihmLCB7XG4gICAgICBtYXhSZXRyaWVzLFxuICAgICAgZGVsYXlJbk1zOiBpbml0aWFsRGVsYXlJbk1zLFxuICAgICAgYmFja29mZkZhY3RvcixcbiAgICB9KTtcblxuYXN5bmMgZnVuY3Rpb24gX3JldHJ5V2l0aEV4cG9uZW50aWFsQmFja29mZjxPVVRQVVQ+KFxuICBmOiAoKSA9PiBQcm9taXNlTGlrZTxPVVRQVVQ+LFxuICB7XG4gICAgbWF4UmV0cmllcyxcbiAgICBkZWxheUluTXMsXG4gICAgYmFja29mZkZhY3RvcixcbiAgfTogeyBtYXhSZXRyaWVzOiBudW1iZXI7IGRlbGF5SW5NczogbnVtYmVyOyBiYWNrb2ZmRmFjdG9yOiBudW1iZXIgfSxcbiAgZXJyb3JzOiB1bmtub3duW10gPSBbXSxcbik6IFByb21pc2U8T1VUUFVUPiB7XG4gIHRyeSB7XG4gICAgcmV0dXJuIGF3YWl0IGYoKTtcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICBpZiAoaXNBYm9ydEVycm9yKGVycm9yKSkge1xuICAgICAgdGhyb3cgZXJyb3I7IC8vIGRvbid0IHJldHJ5IHdoZW4gdGhlIHJlcXVlc3Qgd2FzIGFib3J0ZWRcbiAgICB9XG5cbiAgICBpZiAobWF4UmV0cmllcyA9PT0gMCkge1xuICAgICAgdGhyb3cgZXJyb3I7IC8vIGRvbid0IHdyYXAgdGhlIGVycm9yIHdoZW4gcmV0cmllcyBhcmUgZGlzYWJsZWRcbiAgICB9XG5cbiAgICBjb25zdCBlcnJvck1lc3NhZ2UgPSBnZXRFcnJvck1lc3NhZ2UoZXJyb3IpO1xuICAgIGNvbnN0IG5ld0Vycm9ycyA9IFsuLi5lcnJvcnMsIGVycm9yXTtcbiAgICBjb25zdCB0cnlOdW1iZXIgPSBuZXdFcnJvcnMubGVuZ3RoO1xuXG4gICAgaWYgKHRyeU51bWJlciA+IG1heFJldHJpZXMpIHtcbiAgICAgIHRocm93IG5ldyBSZXRyeUVycm9yKHtcbiAgICAgICAgbWVzc2FnZTogYEZhaWxlZCBhZnRlciAke3RyeU51bWJlcn0gYXR0ZW1wdHMuIExhc3QgZXJyb3I6ICR7ZXJyb3JNZXNzYWdlfWAsXG4gICAgICAgIHJlYXNvbjogJ21heFJldHJpZXNFeGNlZWRlZCcsXG4gICAgICAgIGVycm9yczogbmV3RXJyb3JzLFxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgaWYgKFxuICAgICAgZXJyb3IgaW5zdGFuY2VvZiBFcnJvciAmJlxuICAgICAgQVBJQ2FsbEVycm9yLmlzQVBJQ2FsbEVycm9yKGVycm9yKSAmJlxuICAgICAgZXJyb3IuaXNSZXRyeWFibGUgPT09IHRydWUgJiZcbiAgICAgIHRyeU51bWJlciA8PSBtYXhSZXRyaWVzXG4gICAgKSB7XG4gICAgICBhd2FpdCBkZWxheShkZWxheUluTXMpO1xuICAgICAgcmV0dXJuIF9yZXRyeVdpdGhFeHBvbmVudGlhbEJhY2tvZmYoXG4gICAgICAgIGYsXG4gICAgICAgIHsgbWF4UmV0cmllcywgZGVsYXlJbk1zOiBiYWNrb2ZmRmFjdG9yICogZGVsYXlJbk1zLCBiYWNrb2ZmRmFjdG9yIH0sXG4gICAgICAgIG5ld0Vycm9ycyxcbiAgICAgICk7XG4gICAgfVxuXG4gICAgaWYgKHRyeU51bWJlciA9PT0gMSkge1xuICAgICAgdGhyb3cgZXJyb3I7IC8vIGRvbid0IHdyYXAgdGhlIGVycm9yIHdoZW4gYSBub24tcmV0cnlhYmxlIGVycm9yIG9jY3VycyBvbiB0aGUgZmlyc3QgdHJ5XG4gICAgfVxuXG4gICAgdGhyb3cgbmV3IFJldHJ5RXJyb3Ioe1xuICAgICAgbWVzc2FnZTogYEZhaWxlZCBhZnRlciAke3RyeU51bWJlcn0gYXR0ZW1wdHMgd2l0aCBub24tcmV0cnlhYmxlIGVycm9yOiAnJHtlcnJvck1lc3NhZ2V9J2AsXG4gICAgICByZWFzb246ICdlcnJvck5vdFJldHJ5YWJsZScsXG4gICAgICBlcnJvcnM6IG5ld0Vycm9ycyxcbiAgICB9KTtcbiAgfVxufVxuIiwiZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGRlbGF5KGRlbGF5SW5Ncz86IG51bWJlcik6IFByb21pc2U8dm9pZD4ge1xuICByZXR1cm4gZGVsYXlJbk1zID09PSB1bmRlZmluZWRcbiAgICA/IFByb21pc2UucmVzb2x2ZSgpXG4gICAgOiBuZXcgUHJvbWlzZShyZXNvbHZlID0+IHNldFRpbWVvdXQocmVzb2x2ZSwgZGVsYXlJbk1zKSk7XG59XG4iLCJpbXBvcnQgeyBBSVNES0Vycm9yIH0gZnJvbSAnQGFpLXNkay9wcm92aWRlcic7XG5cbmNvbnN0IG5hbWUgPSAnQUlfUmV0cnlFcnJvcic7XG5jb25zdCBtYXJrZXIgPSBgdmVyY2VsLmFpLmVycm9yLiR7bmFtZX1gO1xuY29uc3Qgc3ltYm9sID0gU3ltYm9sLmZvcihtYXJrZXIpO1xuXG5leHBvcnQgdHlwZSBSZXRyeUVycm9yUmVhc29uID1cbiAgfCAnbWF4UmV0cmllc0V4Y2VlZGVkJ1xuICB8ICdlcnJvck5vdFJldHJ5YWJsZSdcbiAgfCAnYWJvcnQnO1xuXG5leHBvcnQgY2xhc3MgUmV0cnlFcnJvciBleHRlbmRzIEFJU0RLRXJyb3Ige1xuICBwcml2YXRlIHJlYWRvbmx5IFtzeW1ib2xdID0gdHJ1ZTsgLy8gdXNlZCBpbiBpc0luc3RhbmNlXG5cbiAgLy8gbm90ZTogcHJvcGVydHkgb3JkZXIgZGV0ZXJtaW5lcyBkZWJ1Z2dpbmcgb3V0cHV0XG4gIHJlYWRvbmx5IHJlYXNvbjogUmV0cnlFcnJvclJlYXNvbjtcbiAgcmVhZG9ubHkgbGFzdEVycm9yOiB1bmtub3duO1xuICByZWFkb25seSBlcnJvcnM6IEFycmF5PHVua25vd24+O1xuXG4gIGNvbnN0cnVjdG9yKHtcbiAgICBtZXNzYWdlLFxuICAgIHJlYXNvbixcbiAgICBlcnJvcnMsXG4gIH06IHtcbiAgICBtZXNzYWdlOiBzdHJpbmc7XG4gICAgcmVhc29uOiBSZXRyeUVycm9yUmVhc29uO1xuICAgIGVycm9yczogQXJyYXk8dW5rbm93bj47XG4gIH0pIHtcbiAgICBzdXBlcih7IG5hbWUsIG1lc3NhZ2UgfSk7XG5cbiAgICB0aGlzLnJlYXNvbiA9IHJlYXNvbjtcbiAgICB0aGlzLmVycm9ycyA9IGVycm9ycztcblxuICAgIC8vIHNlcGFyYXRlIG91ciBsYXN0IGVycm9yIHRvIG1ha2UgZGVidWdnaW5nIHZpYSBsb2cgZWFzaWVyOlxuICAgIHRoaXMubGFzdEVycm9yID0gZXJyb3JzW2Vycm9ycy5sZW5ndGggLSAxXTtcbiAgfVxuXG4gIHN0YXRpYyBpc0luc3RhbmNlKGVycm9yOiB1bmtub3duKTogZXJyb3IgaXMgUmV0cnlFcnJvciB7XG4gICAgcmV0dXJuIEFJU0RLRXJyb3IuaGFzTWFya2VyKGVycm9yLCBtYXJrZXIpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBkZXByZWNhdGVkIHVzZSBgaXNJbnN0YW5jZWAgaW5zdGVhZFxuICAgKi9cbiAgc3RhdGljIGlzUmV0cnlFcnJvcihlcnJvcjogdW5rbm93bik6IGVycm9yIGlzIFJldHJ5RXJyb3Ige1xuICAgIHJldHVybiAoXG4gICAgICBlcnJvciBpbnN0YW5jZW9mIEVycm9yICYmXG4gICAgICBlcnJvci5uYW1lID09PSBuYW1lICYmXG4gICAgICB0eXBlb2YgKGVycm9yIGFzIFJldHJ5RXJyb3IpLnJlYXNvbiA9PT0gJ3N0cmluZycgJiZcbiAgICAgIEFycmF5LmlzQXJyYXkoKGVycm9yIGFzIFJldHJ5RXJyb3IpLmVycm9ycylcbiAgICApO1xuICB9XG5cbiAgLyoqXG4gICAqIEBkZXByZWNhdGVkIERvIG5vdCB1c2UgdGhpcyBtZXRob2QuIEl0IHdpbGwgYmUgcmVtb3ZlZCBpbiB0aGUgbmV4dCBtYWpvciB2ZXJzaW9uLlxuICAgKi9cbiAgdG9KU09OKCkge1xuICAgIHJldHVybiB7XG4gICAgICBuYW1lOiB0aGlzLm5hbWUsXG4gICAgICBtZXNzYWdlOiB0aGlzLm1lc3NhZ2UsXG4gICAgICByZWFzb246IHRoaXMucmVhc29uLFxuICAgICAgbGFzdEVycm9yOiB0aGlzLmxhc3RFcnJvcixcbiAgICAgIGVycm9yczogdGhpcy5lcnJvcnMsXG4gICAgfTtcbiAgfVxufVxuIiwiLyoqXG4gKiBXYXJuaW5nIHRpbWUgZm9yIG5vdGlmeWluZyBkZXZlbG9wZXJzIHRoYXQgYSBzdHJlYW0gaXMgaGFuZ2luZyBpbiBkZXYgbW9kZVxuICogdXNpbmcgYSBjb25zb2xlLndhcm4uXG4gKi9cbmV4cG9ydCBjb25zdCBIQU5HSU5HX1NUUkVBTV9XQVJOSU5HX1RJTUVfTVMgPSAxNSAqIDEwMDA7XG4iLCJpbXBvcnQgUmVhY3QsIHsgU3VzcGVuc2UgfSBmcm9tICdyZWFjdCc7XG5pbXBvcnQgeyBjcmVhdGVSZXNvbHZhYmxlUHJvbWlzZSB9IGZyb20gJy4uLy4uL3V0aWwvY3JlYXRlLXJlc29sdmFibGUtcHJvbWlzZSc7XG5cbi8vIFJlY3Vyc2l2ZSB0eXBlIGZvciB0aGUgY2h1bmsuXG50eXBlIENodW5rVHlwZSA9XG4gIHwge1xuICAgICAgZG9uZTogZmFsc2U7XG4gICAgICB2YWx1ZTogUmVhY3QuUmVhY3ROb2RlO1xuICAgICAgbmV4dDogUHJvbWlzZTxDaHVua1R5cGU+O1xuICAgICAgYXBwZW5kPzogYm9vbGVhbjtcbiAgICB9XG4gIHwge1xuICAgICAgZG9uZTogdHJ1ZTtcbiAgICAgIHZhbHVlOiBSZWFjdC5SZWFjdE5vZGU7XG4gICAgfTtcblxuLy8gVXNlIHNpbmdsZSBsZXR0ZXIgbmFtZXMgZm9yIHRoZSB2YXJpYWJsZXMgdG8gcmVkdWNlIHRoZSBzaXplIG9mIHRoZSBSU0MgcGF5bG9hZC5cbi8vIGBSYCBmb3IgYFJvd2AsIGBjYCBmb3IgYGN1cnJlbnRgLCBgbmAgZm9yIGBuZXh0YC5cbi8vIE5vdGU6IEFycmF5IGNvbnN0cnVjdGlvbiBpcyBuZWVkZWQgdG8gYWNjZXNzIHRoZSBuYW1lIFIuXG5jb25zdCBSID0gW1xuICAoYXN5bmMgKHtcbiAgICBjOiBjdXJyZW50LFxuICAgIG46IG5leHQsXG4gIH06IHtcbiAgICBjOiBSZWFjdC5SZWFjdE5vZGU7XG4gICAgbjogUHJvbWlzZTxDaHVua1R5cGU+O1xuICB9KSA9PiB7XG4gICAgY29uc3QgY2h1bmsgPSBhd2FpdCBuZXh0O1xuXG4gICAgaWYgKGNodW5rLmRvbmUpIHtcbiAgICAgIHJldHVybiBjaHVuay52YWx1ZTtcbiAgICB9XG5cbiAgICBpZiAoY2h1bmsuYXBwZW5kKSB7XG4gICAgICByZXR1cm4gKFxuICAgICAgICA8PlxuICAgICAgICAgIHtjdXJyZW50fVxuICAgICAgICAgIDxTdXNwZW5zZSBmYWxsYmFjaz17Y2h1bmsudmFsdWV9PlxuICAgICAgICAgICAgPFIgYz17Y2h1bmsudmFsdWV9IG49e2NodW5rLm5leHR9IC8+XG4gICAgICAgICAgPC9TdXNwZW5zZT5cbiAgICAgICAgPC8+XG4gICAgICApO1xuICAgIH1cblxuICAgIHJldHVybiAoXG4gICAgICA8U3VzcGVuc2UgZmFsbGJhY2s9e2NodW5rLnZhbHVlfT5cbiAgICAgICAgPFIgYz17Y2h1bmsudmFsdWV9IG49e2NodW5rLm5leHR9IC8+XG4gICAgICA8L1N1c3BlbnNlPlxuICAgICk7XG4gIH0pIGFzIHVua25vd24gYXMgUmVhY3QuRkM8e1xuICAgIGM6IFJlYWN0LlJlYWN0Tm9kZTtcbiAgICBuOiBQcm9taXNlPENodW5rVHlwZT47XG4gIH0+LFxuXVswXTtcblxuLyoqXG4gKiBDcmVhdGVzIGEgc3VzcGVuZGVkIGNodW5rIGZvciBSZWFjdCBTZXJ2ZXIgQ29tcG9uZW50cy5cbiAqXG4gKiBUaGlzIGZ1bmN0aW9uIGdlbmVyYXRlcyBhIHN1c3BlbnNlZnVsIFJlYWN0IGNvbXBvbmVudCB0aGF0IGNhbiBiZSBkeW5hbWljYWxseSB1cGRhdGVkLlxuICogSXQncyB1c2VmdWwgZm9yIHN0cmVhbWluZyB1cGRhdGVzIHRvIHRoZSBjbGllbnQgaW4gYSBSZWFjdCBTZXJ2ZXIgQ29tcG9uZW50cyBjb250ZXh0LlxuICpcbiAqIEBwYXJhbSB7UmVhY3QuUmVhY3ROb2RlfSBpbml0aWFsVmFsdWUgLSBUaGUgaW5pdGlhbCB2YWx1ZSB0byByZW5kZXIgd2hpbGUgdGhlIHByb21pc2UgaXMgcGVuZGluZy5cbiAqIEByZXR1cm5zIHtPYmplY3R9IEFuIG9iamVjdCBjb250YWluaW5nOlxuICogICAtIHJvdzogQSBSZWFjdCBub2RlIHRoYXQgcmVuZGVycyB0aGUgc3VzcGVuc2VmdWwgY29udGVudC5cbiAqICAgLSByZXNvbHZlOiBBIGZ1bmN0aW9uIHRvIHJlc29sdmUgdGhlIHByb21pc2Ugd2l0aCBhIG5ldyB2YWx1ZS5cbiAqICAgLSByZWplY3Q6IEEgZnVuY3Rpb24gdG8gcmVqZWN0IHRoZSBwcm9taXNlIHdpdGggYW4gZXJyb3IuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVTdXNwZW5kZWRDaHVuayhpbml0aWFsVmFsdWU6IFJlYWN0LlJlYWN0Tm9kZSk6IHtcbiAgcm93OiBSZWFjdC5SZWFjdE5vZGU7XG4gIHJlc29sdmU6ICh2YWx1ZTogQ2h1bmtUeXBlKSA9PiB2b2lkO1xuICByZWplY3Q6IChlcnJvcjogdW5rbm93bikgPT4gdm9pZDtcbn0ge1xuICBjb25zdCB7IHByb21pc2UsIHJlc29sdmUsIHJlamVjdCB9ID0gY3JlYXRlUmVzb2x2YWJsZVByb21pc2U8Q2h1bmtUeXBlPigpO1xuXG4gIHJldHVybiB7XG4gICAgcm93OiAoXG4gICAgICA8U3VzcGVuc2UgZmFsbGJhY2s9e2luaXRpYWxWYWx1ZX0+XG4gICAgICAgIDxSIGM9e2luaXRpYWxWYWx1ZX0gbj17cHJvbWlzZX0gLz5cbiAgICAgIDwvU3VzcGVuc2U+XG4gICAgKSxcbiAgICByZXNvbHZlLFxuICAgIHJlamVjdCxcbiAgfTtcbn1cbiIsImltcG9ydCB7IEhBTkdJTkdfU1RSRUFNX1dBUk5JTkdfVElNRV9NUyB9IGZyb20gJy4uLy4uL3V0aWwvY29uc3RhbnRzJztcbmltcG9ydCB7IGNyZWF0ZVJlc29sdmFibGVQcm9taXNlIH0gZnJvbSAnLi4vLi4vdXRpbC9jcmVhdGUtcmVzb2x2YWJsZS1wcm9taXNlJztcbmltcG9ydCB7IGNyZWF0ZVN1c3BlbmRlZENodW5rIH0gZnJvbSAnLi9jcmVhdGUtc3VzcGVuZGVkLWNodW5rJztcblxuLy8gSXQncyBuZWNlc3NhcnkgdG8gZGVmaW5lIHRoZSB0eXBlIG1hbnVhbGx5IGhlcmUsIG90aGVyd2lzZSBUeXBlU2NyaXB0IGNvbXBpbGVyXG4vLyB3aWxsIG5vdCBiZSBhYmxlIHRvIGluZmVyIHRoZSBjb3JyZWN0IHJldHVybiB0eXBlIGFzIGl0J3MgY2lyY3VsYXIuXG50eXBlIFN0cmVhbWFibGVVSVdyYXBwZXIgPSB7XG4gIC8qKlxuICAgKiBUaGUgdmFsdWUgb2YgdGhlIHN0cmVhbWFibGUgVUkuIFRoaXMgY2FuIGJlIHJldHVybmVkIGZyb20gYSBTZXJ2ZXIgQWN0aW9uIGFuZCByZWNlaXZlZCBieSB0aGUgY2xpZW50LlxuICAgKi9cbiAgcmVhZG9ubHkgdmFsdWU6IFJlYWN0LlJlYWN0Tm9kZTtcblxuICAvKipcbiAgICogVGhpcyBtZXRob2QgdXBkYXRlcyB0aGUgY3VycmVudCBVSSBub2RlLiBJdCB0YWtlcyBhIG5ldyBVSSBub2RlIGFuZCByZXBsYWNlcyB0aGUgb2xkIG9uZS5cbiAgICovXG4gIHVwZGF0ZSh2YWx1ZTogUmVhY3QuUmVhY3ROb2RlKTogU3RyZWFtYWJsZVVJV3JhcHBlcjtcblxuICAvKipcbiAgICogVGhpcyBtZXRob2QgaXMgdXNlZCB0byBhcHBlbmQgYSBuZXcgVUkgbm9kZSB0byB0aGUgZW5kIG9mIHRoZSBvbGQgb25lLlxuICAgKiBPbmNlIGFwcGVuZGVkIGEgbmV3IFVJIG5vZGUsIHRoZSBwcmV2aW91cyBVSSBub2RlIGNhbm5vdCBiZSB1cGRhdGVkIGFueW1vcmUuXG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqIGBgYGpzeFxuICAgKiBjb25zdCB1aSA9IGNyZWF0ZVN0cmVhbWFibGVVSSg8ZGl2PmhlbGxvPC9kaXY+KVxuICAgKiB1aS5hcHBlbmQoPGRpdj53b3JsZDwvZGl2PilcbiAgICpcbiAgICogLy8gVGhlIFVJIG5vZGUgd2lsbCBiZTpcbiAgICogLy8gPD5cbiAgICogLy8gICA8ZGl2PmhlbGxvPC9kaXY+XG4gICAqIC8vICAgPGRpdj53b3JsZDwvZGl2PlxuICAgKiAvLyA8Lz5cbiAgICogYGBgXG4gICAqL1xuICBhcHBlbmQodmFsdWU6IFJlYWN0LlJlYWN0Tm9kZSk6IFN0cmVhbWFibGVVSVdyYXBwZXI7XG5cbiAgLyoqXG4gICAqIFRoaXMgbWV0aG9kIGlzIHVzZWQgdG8gc2lnbmFsIHRoYXQgdGhlcmUgaXMgYW4gZXJyb3IgaW4gdGhlIFVJIHN0cmVhbS5cbiAgICogSXQgd2lsbCBiZSB0aHJvd24gb24gdGhlIGNsaWVudCBzaWRlIGFuZCBjYXVnaHQgYnkgdGhlIG5lYXJlc3QgZXJyb3IgYm91bmRhcnkgY29tcG9uZW50LlxuICAgKi9cbiAgZXJyb3IoZXJyb3I6IGFueSk6IFN0cmVhbWFibGVVSVdyYXBwZXI7XG5cbiAgLyoqXG4gICAqIFRoaXMgbWV0aG9kIG1hcmtzIHRoZSBVSSBub2RlIGFzIGZpbmFsaXplZC4gWW91IGNhbiBlaXRoZXIgY2FsbCBpdCB3aXRob3V0IGFueSBwYXJhbWV0ZXJzIG9yIHdpdGggYSBuZXcgVUkgbm9kZSBhcyB0aGUgZmluYWwgc3RhdGUuXG4gICAqIE9uY2UgY2FsbGVkLCB0aGUgVUkgbm9kZSBjYW5ub3QgYmUgdXBkYXRlZCBvciBhcHBlbmRlZCBhbnltb3JlLlxuICAgKlxuICAgKiBUaGlzIG1ldGhvZCBpcyBhbHdheXMgKipyZXF1aXJlZCoqIHRvIGJlIGNhbGxlZCwgb3RoZXJ3aXNlIHRoZSByZXNwb25zZSB3aWxsIGJlIHN0dWNrIGluIGEgbG9hZGluZyBzdGF0ZS5cbiAgICovXG4gIGRvbmUoLi4uYXJnczogW1JlYWN0LlJlYWN0Tm9kZV0gfCBbXSk6IFN0cmVhbWFibGVVSVdyYXBwZXI7XG59O1xuXG4vKipcbiAqIENyZWF0ZSBhIHBpZWNlIG9mIGNoYW5nZWFibGUgVUkgdGhhdCBjYW4gYmUgc3RyZWFtZWQgdG8gdGhlIGNsaWVudC5cbiAqIE9uIHRoZSBjbGllbnQgc2lkZSwgaXQgY2FuIGJlIHJlbmRlcmVkIGFzIGEgbm9ybWFsIFJlYWN0IG5vZGUuXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZVN0cmVhbWFibGVVSShpbml0aWFsVmFsdWU/OiBSZWFjdC5SZWFjdE5vZGUpIHtcbiAgbGV0IGN1cnJlbnRWYWx1ZSA9IGluaXRpYWxWYWx1ZTtcbiAgbGV0IGNsb3NlZCA9IGZhbHNlO1xuICBsZXQgeyByb3csIHJlc29sdmUsIHJlamVjdCB9ID0gY3JlYXRlU3VzcGVuZGVkQ2h1bmsoaW5pdGlhbFZhbHVlKTtcblxuICBmdW5jdGlvbiBhc3NlcnRTdHJlYW0obWV0aG9kOiBzdHJpbmcpIHtcbiAgICBpZiAoY2xvc2VkKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IobWV0aG9kICsgJzogVUkgc3RyZWFtIGlzIGFscmVhZHkgY2xvc2VkLicpO1xuICAgIH1cbiAgfVxuXG4gIGxldCB3YXJuaW5nVGltZW91dDogTm9kZUpTLlRpbWVvdXQgfCB1bmRlZmluZWQ7XG4gIGZ1bmN0aW9uIHdhcm5VbmNsb3NlZFN0cmVhbSgpIHtcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09ICdkZXZlbG9wbWVudCcpIHtcbiAgICAgIGlmICh3YXJuaW5nVGltZW91dCkge1xuICAgICAgICBjbGVhclRpbWVvdXQod2FybmluZ1RpbWVvdXQpO1xuICAgICAgfVxuICAgICAgd2FybmluZ1RpbWVvdXQgPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgY29uc29sZS53YXJuKFxuICAgICAgICAgICdUaGUgc3RyZWFtYWJsZSBVSSBoYXMgYmVlbiBzbG93IHRvIHVwZGF0ZS4gVGhpcyBtYXkgYmUgYSBidWcgb3IgYSBwZXJmb3JtYW5jZSBpc3N1ZSBvciB5b3UgZm9yZ290IHRvIGNhbGwgYC5kb25lKClgLicsXG4gICAgICAgICk7XG4gICAgICB9LCBIQU5HSU5HX1NUUkVBTV9XQVJOSU5HX1RJTUVfTVMpO1xuICAgIH1cbiAgfVxuICB3YXJuVW5jbG9zZWRTdHJlYW0oKTtcblxuICBjb25zdCBzdHJlYW1hYmxlOiBTdHJlYW1hYmxlVUlXcmFwcGVyID0ge1xuICAgIHZhbHVlOiByb3csXG4gICAgdXBkYXRlKHZhbHVlOiBSZWFjdC5SZWFjdE5vZGUpIHtcbiAgICAgIGFzc2VydFN0cmVhbSgnLnVwZGF0ZSgpJyk7XG5cbiAgICAgIC8vIFRoZXJlIGlzIG5vIG5lZWQgdG8gdXBkYXRlIHRoZSB2YWx1ZSBpZiBpdCdzIHJlZmVyZW50aWFsbHkgZXF1YWwuXG4gICAgICBpZiAodmFsdWUgPT09IGN1cnJlbnRWYWx1ZSkge1xuICAgICAgICB3YXJuVW5jbG9zZWRTdHJlYW0oKTtcbiAgICAgICAgcmV0dXJuIHN0cmVhbWFibGU7XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IHJlc29sdmFibGUgPSBjcmVhdGVSZXNvbHZhYmxlUHJvbWlzZSgpO1xuICAgICAgY3VycmVudFZhbHVlID0gdmFsdWU7XG5cbiAgICAgIHJlc29sdmUoeyB2YWx1ZTogY3VycmVudFZhbHVlLCBkb25lOiBmYWxzZSwgbmV4dDogcmVzb2x2YWJsZS5wcm9taXNlIH0pO1xuICAgICAgcmVzb2x2ZSA9IHJlc29sdmFibGUucmVzb2x2ZTtcbiAgICAgIHJlamVjdCA9IHJlc29sdmFibGUucmVqZWN0O1xuXG4gICAgICB3YXJuVW5jbG9zZWRTdHJlYW0oKTtcblxuICAgICAgcmV0dXJuIHN0cmVhbWFibGU7XG4gICAgfSxcbiAgICBhcHBlbmQodmFsdWU6IFJlYWN0LlJlYWN0Tm9kZSkge1xuICAgICAgYXNzZXJ0U3RyZWFtKCcuYXBwZW5kKCknKTtcblxuICAgICAgY29uc3QgcmVzb2x2YWJsZSA9IGNyZWF0ZVJlc29sdmFibGVQcm9taXNlKCk7XG4gICAgICBjdXJyZW50VmFsdWUgPSB2YWx1ZTtcblxuICAgICAgcmVzb2x2ZSh7IHZhbHVlLCBkb25lOiBmYWxzZSwgYXBwZW5kOiB0cnVlLCBuZXh0OiByZXNvbHZhYmxlLnByb21pc2UgfSk7XG4gICAgICByZXNvbHZlID0gcmVzb2x2YWJsZS5yZXNvbHZlO1xuICAgICAgcmVqZWN0ID0gcmVzb2x2YWJsZS5yZWplY3Q7XG5cbiAgICAgIHdhcm5VbmNsb3NlZFN0cmVhbSgpO1xuXG4gICAgICByZXR1cm4gc3RyZWFtYWJsZTtcbiAgICB9LFxuICAgIGVycm9yKGVycm9yOiBhbnkpIHtcbiAgICAgIGFzc2VydFN0cmVhbSgnLmVycm9yKCknKTtcblxuICAgICAgaWYgKHdhcm5pbmdUaW1lb3V0KSB7XG4gICAgICAgIGNsZWFyVGltZW91dCh3YXJuaW5nVGltZW91dCk7XG4gICAgICB9XG4gICAgICBjbG9zZWQgPSB0cnVlO1xuICAgICAgcmVqZWN0KGVycm9yKTtcblxuICAgICAgcmV0dXJuIHN0cmVhbWFibGU7XG4gICAgfSxcbiAgICBkb25lKC4uLmFyZ3M6IFtdIHwgW1JlYWN0LlJlYWN0Tm9kZV0pIHtcbiAgICAgIGFzc2VydFN0cmVhbSgnLmRvbmUoKScpO1xuXG4gICAgICBpZiAod2FybmluZ1RpbWVvdXQpIHtcbiAgICAgICAgY2xlYXJUaW1lb3V0KHdhcm5pbmdUaW1lb3V0KTtcbiAgICAgIH1cbiAgICAgIGNsb3NlZCA9IHRydWU7XG4gICAgICBpZiAoYXJncy5sZW5ndGgpIHtcbiAgICAgICAgcmVzb2x2ZSh7IHZhbHVlOiBhcmdzWzBdLCBkb25lOiB0cnVlIH0pO1xuICAgICAgICByZXR1cm4gc3RyZWFtYWJsZTtcbiAgICAgIH1cbiAgICAgIHJlc29sdmUoeyB2YWx1ZTogY3VycmVudFZhbHVlLCBkb25lOiB0cnVlIH0pO1xuXG4gICAgICByZXR1cm4gc3RyZWFtYWJsZTtcbiAgICB9LFxuICB9O1xuXG4gIHJldHVybiBzdHJlYW1hYmxlO1xufVxuXG5leHBvcnQgeyBjcmVhdGVTdHJlYW1hYmxlVUkgfTtcbiIsImltcG9ydCB0eXBlIE9wZW5BSSBmcm9tICdvcGVuYWknO1xuaW1wb3J0IHR5cGUgeyBSZWFjdE5vZGUgfSBmcm9tICdyZWFjdCc7XG5pbXBvcnQgeyB6IH0gZnJvbSAnem9kJztcbmltcG9ydCB6b2RUb0pzb25TY2hlbWEgZnJvbSAnem9kLXRvLWpzb24tc2NoZW1hJztcbmltcG9ydCB7IE9wZW5BSVN0cmVhbSB9IGZyb20gJy4uLy4uL3N0cmVhbXMnO1xuaW1wb3J0IHsgY29uc3VtZVN0cmVhbSB9IGZyb20gJy4uLy4uL3V0aWwvY29uc3VtZS1zdHJlYW0nO1xuaW1wb3J0IHsgY3JlYXRlUmVzb2x2YWJsZVByb21pc2UgfSBmcm9tICcuLi8uLi91dGlsL2NyZWF0ZS1yZXNvbHZhYmxlLXByb21pc2UnO1xuaW1wb3J0IHsgY3JlYXRlU3RyZWFtYWJsZVVJIH0gZnJvbSAnLi4vc3RyZWFtYWJsZS11aS9jcmVhdGUtc3RyZWFtYWJsZS11aSc7XG5cbnR5cGUgU3RyZWFtYWJsZSA9IFJlYWN0Tm9kZSB8IFByb21pc2U8UmVhY3ROb2RlPjtcbnR5cGUgUmVuZGVyZXI8VD4gPSAoXG4gIHByb3BzOiBULFxuKSA9PlxuICB8IFN0cmVhbWFibGVcbiAgfCBHZW5lcmF0b3I8U3RyZWFtYWJsZSwgU3RyZWFtYWJsZSwgdm9pZD5cbiAgfCBBc3luY0dlbmVyYXRvcjxTdHJlYW1hYmxlLCBTdHJlYW1hYmxlLCB2b2lkPjtcblxuLyoqXG4gKiBgcmVuZGVyYCBpcyBhIGhlbHBlciBmdW5jdGlvbiB0byBjcmVhdGUgYSBzdHJlYW1hYmxlIFVJIGZyb20gc29tZSBMTE1zLlxuICogVGhpcyBBUEkgb25seSBzdXBwb3J0cyBPcGVuQUkncyBHUFQgbW9kZWxzIHdpdGggRnVuY3Rpb24gQ2FsbGluZyBhbmQgQXNzaXN0YW50cyBUb29scyxcbiAqIHBsZWFzZSB1c2UgYHN0cmVhbVVJYCBmb3IgY29tcGF0aWJpbGl0eSB3aXRoIG90aGVyIHByb3ZpZGVycy5cbiAqXG4gKiBAZGVwcmVjYXRlZCBJdCdzIHJlY29tbWVuZGVkIHRvIHVzZSB0aGUgYHN0cmVhbVVJYCBBUEkgZm9yIGNvbXBhdGliaWxpdHkgd2l0aCBBSSBTREsgQ29yZSBBUElzXG4gKiBhbmQgZnV0dXJlIGZlYXR1cmVzLiBUaGlzIEFQSSB3aWxsIGJlIHJlbW92ZWQgaW4gYSBmdXR1cmUgcmVsZWFzZS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHJlbmRlcjxcbiAgVFMgZXh0ZW5kcyB7XG4gICAgW25hbWU6IHN0cmluZ106IHouU2NoZW1hO1xuICB9ID0ge30sXG4gIEZTIGV4dGVuZHMge1xuICAgIFtuYW1lOiBzdHJpbmddOiB6LlNjaGVtYTtcbiAgfSA9IHt9LFxuPihvcHRpb25zOiB7XG4gIC8qKlxuICAgKiBUaGUgbW9kZWwgbmFtZSB0byB1c2UuIE11c3QgYmUgT3BlbkFJIFNESyBjb21wYXRpYmxlLiBUb29scyBhbmQgRnVuY3Rpb25zIGFyZSBvbmx5IHN1cHBvcnRlZFxuICAgKiBHUFQgbW9kZWxzICgzLjUvNCksIE9wZW5BSSBBc3Npc3RhbnRzLCBNaXN0cmFsIHNtYWxsIGFuZCBsYXJnZSwgYW5kIEZpcmV3b3JrcyBmaXJlZnVuY3Rpb24tdjEuXG4gICAqXG4gICAqIEBleGFtcGxlIFwiZ3B0LTMuNS10dXJib1wiXG4gICAqL1xuICBtb2RlbDogc3RyaW5nO1xuICAvKipcbiAgICogVGhlIHByb3ZpZGVyIGluc3RhbmNlIHRvIHVzZS4gQ3VycmVudGx5IHRoZSBvbmx5IHByb3ZpZGVyIGF2YWlsYWJsZSBpcyBPcGVuQUkuXG4gICAqIFRoaXMgbmVlZHMgdG8gbWF0Y2ggdGhlIG1vZGVsIG5hbWUuXG4gICAqL1xuICBwcm92aWRlcjogT3BlbkFJO1xuICBtZXNzYWdlczogUGFyYW1ldGVyczxcbiAgICB0eXBlb2YgT3BlbkFJLnByb3RvdHlwZS5jaGF0LmNvbXBsZXRpb25zLmNyZWF0ZVxuICA+WzBdWydtZXNzYWdlcyddO1xuICB0ZXh0PzogUmVuZGVyZXI8e1xuICAgIC8qKlxuICAgICAqIFRoZSBmdWxsIHRleHQgY29udGVudCBmcm9tIHRoZSBtb2RlbCBzbyBmYXIuXG4gICAgICovXG4gICAgY29udGVudDogc3RyaW5nO1xuICAgIC8qKlxuICAgICAqIFRoZSBuZXcgYXBwZW5kZWQgdGV4dCBjb250ZW50IGZyb20gdGhlIG1vZGVsIHNpbmNlIHRoZSBsYXN0IGB0ZXh0YCBjYWxsLlxuICAgICAqL1xuICAgIGRlbHRhOiBzdHJpbmc7XG4gICAgLyoqXG4gICAgICogV2hldGhlciB0aGUgbW9kZWwgaXMgZG9uZSBnZW5lcmF0aW5nIHRleHQuXG4gICAgICogSWYgYHRydWVgLCB0aGUgYGNvbnRlbnRgIHdpbGwgYmUgdGhlIGZpbmFsIG91dHB1dCBhbmQgdGhpcyBjYWxsIHdpbGwgYmUgdGhlIGxhc3QuXG4gICAgICovXG4gICAgZG9uZTogYm9vbGVhbjtcbiAgfT47XG4gIHRvb2xzPzoge1xuICAgIFtuYW1lIGluIGtleW9mIFRTXToge1xuICAgICAgZGVzY3JpcHRpb24/OiBzdHJpbmc7XG4gICAgICBwYXJhbWV0ZXJzOiBUU1tuYW1lXTtcbiAgICAgIHJlbmRlcjogUmVuZGVyZXI8ei5pbmZlcjxUU1tuYW1lXT4+O1xuICAgIH07XG4gIH07XG4gIGZ1bmN0aW9ucz86IHtcbiAgICBbbmFtZSBpbiBrZXlvZiBGU106IHtcbiAgICAgIGRlc2NyaXB0aW9uPzogc3RyaW5nO1xuICAgICAgcGFyYW1ldGVyczogRlNbbmFtZV07XG4gICAgICByZW5kZXI6IFJlbmRlcmVyPHouaW5mZXI8RlNbbmFtZV0+PjtcbiAgICB9O1xuICB9O1xuICBpbml0aWFsPzogUmVhY3ROb2RlO1xuICB0ZW1wZXJhdHVyZT86IG51bWJlcjtcbn0pOiBSZWFjdE5vZGUge1xuICBjb25zdCB1aSA9IGNyZWF0ZVN0cmVhbWFibGVVSShvcHRpb25zLmluaXRpYWwpO1xuXG4gIC8vIFRoZSBkZWZhdWx0IHRleHQgcmVuZGVyZXIganVzdCByZXR1cm5zIHRoZSBjb250ZW50IGFzIHN0cmluZy5cbiAgY29uc3QgdGV4dCA9IG9wdGlvbnMudGV4dFxuICAgID8gb3B0aW9ucy50ZXh0XG4gICAgOiAoeyBjb250ZW50IH06IHsgY29udGVudDogc3RyaW5nIH0pID0+IGNvbnRlbnQ7XG5cbiAgY29uc3QgZnVuY3Rpb25zID0gb3B0aW9ucy5mdW5jdGlvbnNcbiAgICA/IE9iamVjdC5lbnRyaWVzKG9wdGlvbnMuZnVuY3Rpb25zKS5tYXAoXG4gICAgICAgIChbbmFtZSwgeyBkZXNjcmlwdGlvbiwgcGFyYW1ldGVycyB9XSkgPT4ge1xuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBuYW1lLFxuICAgICAgICAgICAgZGVzY3JpcHRpb24sXG4gICAgICAgICAgICBwYXJhbWV0ZXJzOiB6b2RUb0pzb25TY2hlbWEocGFyYW1ldGVycykgYXMgUmVjb3JkPHN0cmluZywgdW5rbm93bj4sXG4gICAgICAgICAgfTtcbiAgICAgICAgfSxcbiAgICAgIClcbiAgICA6IHVuZGVmaW5lZDtcblxuICBjb25zdCB0b29scyA9IG9wdGlvbnMudG9vbHNcbiAgICA/IE9iamVjdC5lbnRyaWVzKG9wdGlvbnMudG9vbHMpLm1hcChcbiAgICAgICAgKFtuYW1lLCB7IGRlc2NyaXB0aW9uLCBwYXJhbWV0ZXJzIH1dKSA9PiB7XG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHR5cGU6ICdmdW5jdGlvbicgYXMgY29uc3QsXG4gICAgICAgICAgICBmdW5jdGlvbjoge1xuICAgICAgICAgICAgICBuYW1lLFxuICAgICAgICAgICAgICBkZXNjcmlwdGlvbixcbiAgICAgICAgICAgICAgcGFyYW1ldGVyczogem9kVG9Kc29uU2NoZW1hKHBhcmFtZXRlcnMpIGFzIFJlY29yZDxcbiAgICAgICAgICAgICAgICBzdHJpbmcsXG4gICAgICAgICAgICAgICAgdW5rbm93blxuICAgICAgICAgICAgICA+LFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICB9O1xuICAgICAgICB9LFxuICAgICAgKVxuICAgIDogdW5kZWZpbmVkO1xuXG4gIGlmIChmdW5jdGlvbnMgJiYgdG9vbHMpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICBcIllvdSBjYW4ndCBoYXZlIGJvdGggZnVuY3Rpb25zIGFuZCB0b29scyBkZWZpbmVkLiBQbGVhc2UgY2hvb3NlIG9uZSBvciB0aGUgb3RoZXIuXCIsXG4gICAgKTtcbiAgfVxuXG4gIGxldCBmaW5pc2hlZDogUHJvbWlzZTx2b2lkPiB8IHVuZGVmaW5lZDtcblxuICBhc3luYyBmdW5jdGlvbiBoYW5kbGVSZW5kZXIoXG4gICAgYXJnczogYW55LFxuICAgIHJlbmRlcmVyOiB1bmRlZmluZWQgfCBSZW5kZXJlcjxhbnk+LFxuICAgIHJlczogUmV0dXJuVHlwZTx0eXBlb2YgY3JlYXRlU3RyZWFtYWJsZVVJPixcbiAgKSB7XG4gICAgaWYgKCFyZW5kZXJlcikgcmV0dXJuO1xuXG4gICAgY29uc3QgcmVzb2x2YWJsZSA9IGNyZWF0ZVJlc29sdmFibGVQcm9taXNlPHZvaWQ+KCk7XG5cbiAgICBpZiAoZmluaXNoZWQpIHtcbiAgICAgIGZpbmlzaGVkID0gZmluaXNoZWQudGhlbigoKSA9PiByZXNvbHZhYmxlLnByb21pc2UpO1xuICAgIH0gZWxzZSB7XG4gICAgICBmaW5pc2hlZCA9IHJlc29sdmFibGUucHJvbWlzZTtcbiAgICB9XG5cbiAgICBjb25zdCB2YWx1ZSA9IHJlbmRlcmVyKGFyZ3MpO1xuICAgIGlmIChcbiAgICAgIHZhbHVlIGluc3RhbmNlb2YgUHJvbWlzZSB8fFxuICAgICAgKHZhbHVlICYmXG4gICAgICAgIHR5cGVvZiB2YWx1ZSA9PT0gJ29iamVjdCcgJiZcbiAgICAgICAgJ3RoZW4nIGluIHZhbHVlICYmXG4gICAgICAgIHR5cGVvZiB2YWx1ZS50aGVuID09PSAnZnVuY3Rpb24nKVxuICAgICkge1xuICAgICAgY29uc3Qgbm9kZSA9IGF3YWl0ICh2YWx1ZSBhcyBQcm9taXNlPFJlYWN0LlJlYWN0Tm9kZT4pO1xuICAgICAgcmVzLnVwZGF0ZShub2RlKTtcbiAgICAgIHJlc29sdmFibGUucmVzb2x2ZSh2b2lkIDApO1xuICAgIH0gZWxzZSBpZiAoXG4gICAgICB2YWx1ZSAmJlxuICAgICAgdHlwZW9mIHZhbHVlID09PSAnb2JqZWN0JyAmJlxuICAgICAgU3ltYm9sLmFzeW5jSXRlcmF0b3IgaW4gdmFsdWVcbiAgICApIHtcbiAgICAgIGNvbnN0IGl0ID0gdmFsdWUgYXMgQXN5bmNHZW5lcmF0b3I8XG4gICAgICAgIFJlYWN0LlJlYWN0Tm9kZSxcbiAgICAgICAgUmVhY3QuUmVhY3ROb2RlLFxuICAgICAgICB2b2lkXG4gICAgICA+O1xuICAgICAgd2hpbGUgKHRydWUpIHtcbiAgICAgICAgY29uc3QgeyBkb25lLCB2YWx1ZSB9ID0gYXdhaXQgaXQubmV4dCgpO1xuICAgICAgICByZXMudXBkYXRlKHZhbHVlKTtcbiAgICAgICAgaWYgKGRvbmUpIGJyZWFrO1xuICAgICAgfVxuICAgICAgcmVzb2x2YWJsZS5yZXNvbHZlKHZvaWQgMCk7XG4gICAgfSBlbHNlIGlmICh2YWx1ZSAmJiB0eXBlb2YgdmFsdWUgPT09ICdvYmplY3QnICYmIFN5bWJvbC5pdGVyYXRvciBpbiB2YWx1ZSkge1xuICAgICAgY29uc3QgaXQgPSB2YWx1ZSBhcyBHZW5lcmF0b3I8UmVhY3QuUmVhY3ROb2RlLCBSZWFjdC5SZWFjdE5vZGUsIHZvaWQ+O1xuICAgICAgd2hpbGUgKHRydWUpIHtcbiAgICAgICAgY29uc3QgeyBkb25lLCB2YWx1ZSB9ID0gaXQubmV4dCgpO1xuICAgICAgICByZXMudXBkYXRlKHZhbHVlKTtcbiAgICAgICAgaWYgKGRvbmUpIGJyZWFrO1xuICAgICAgfVxuICAgICAgcmVzb2x2YWJsZS5yZXNvbHZlKHZvaWQgMCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJlcy51cGRhdGUodmFsdWUpO1xuICAgICAgcmVzb2x2YWJsZS5yZXNvbHZlKHZvaWQgMCk7XG4gICAgfVxuICB9XG5cbiAgKGFzeW5jICgpID0+IHtcbiAgICBsZXQgaGFzRnVuY3Rpb24gPSBmYWxzZTtcbiAgICBsZXQgY29udGVudCA9ICcnO1xuXG4gICAgY29uc3VtZVN0cmVhbShcbiAgICAgIE9wZW5BSVN0cmVhbShcbiAgICAgICAgKGF3YWl0IG9wdGlvbnMucHJvdmlkZXIuY2hhdC5jb21wbGV0aW9ucy5jcmVhdGUoe1xuICAgICAgICAgIG1vZGVsOiBvcHRpb25zLm1vZGVsLFxuICAgICAgICAgIG1lc3NhZ2VzOiBvcHRpb25zLm1lc3NhZ2VzLFxuICAgICAgICAgIHRlbXBlcmF0dXJlOiBvcHRpb25zLnRlbXBlcmF0dXJlLFxuICAgICAgICAgIHN0cmVhbTogdHJ1ZSxcbiAgICAgICAgICAuLi4oZnVuY3Rpb25zXG4gICAgICAgICAgICA/IHtcbiAgICAgICAgICAgICAgICBmdW5jdGlvbnMsXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIDoge30pLFxuICAgICAgICAgIC4uLih0b29sc1xuICAgICAgICAgICAgPyB7XG4gICAgICAgICAgICAgICAgdG9vbHMsXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIDoge30pLFxuICAgICAgICB9KSkgYXMgYW55LFxuICAgICAgICB7XG4gICAgICAgICAgLi4uKGZ1bmN0aW9uc1xuICAgICAgICAgICAgPyB7XG4gICAgICAgICAgICAgICAgYXN5bmMgZXhwZXJpbWVudGFsX29uRnVuY3Rpb25DYWxsKGZ1bmN0aW9uQ2FsbFBheWxvYWQpIHtcbiAgICAgICAgICAgICAgICAgIGhhc0Z1bmN0aW9uID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgIGhhbmRsZVJlbmRlcihcbiAgICAgICAgICAgICAgICAgICAgZnVuY3Rpb25DYWxsUGF5bG9hZC5hcmd1bWVudHMsXG4gICAgICAgICAgICAgICAgICAgIG9wdGlvbnMuZnVuY3Rpb25zPy5bZnVuY3Rpb25DYWxsUGF5bG9hZC5uYW1lIGFzIGFueV1cbiAgICAgICAgICAgICAgICAgICAgICA/LnJlbmRlcixcbiAgICAgICAgICAgICAgICAgICAgdWksXG4gICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIDoge30pLFxuICAgICAgICAgIC4uLih0b29sc1xuICAgICAgICAgICAgPyB7XG4gICAgICAgICAgICAgICAgYXN5bmMgZXhwZXJpbWVudGFsX29uVG9vbENhbGwodG9vbENhbGxQYXlsb2FkOiBhbnkpIHtcbiAgICAgICAgICAgICAgICAgIGhhc0Z1bmN0aW9uID0gdHJ1ZTtcblxuICAgICAgICAgICAgICAgICAgLy8gVE9ETzogV2UgbWlnaHQgbmVlZCBQcm9taXNlLmFsbCBoZXJlP1xuICAgICAgICAgICAgICAgICAgZm9yIChjb25zdCB0b29sIG9mIHRvb2xDYWxsUGF5bG9hZC50b29scykge1xuICAgICAgICAgICAgICAgICAgICBoYW5kbGVSZW5kZXIoXG4gICAgICAgICAgICAgICAgICAgICAgdG9vbC5mdW5jLmFyZ3VtZW50cyxcbiAgICAgICAgICAgICAgICAgICAgICBvcHRpb25zLnRvb2xzPy5bdG9vbC5mdW5jLm5hbWUgYXMgYW55XT8ucmVuZGVyLFxuICAgICAgICAgICAgICAgICAgICAgIHVpLFxuICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIDoge30pLFxuICAgICAgICAgIG9uVGV4dChjaHVuaykge1xuICAgICAgICAgICAgY29udGVudCArPSBjaHVuaztcbiAgICAgICAgICAgIGhhbmRsZVJlbmRlcih7IGNvbnRlbnQsIGRvbmU6IGZhbHNlLCBkZWx0YTogY2h1bmsgfSwgdGV4dCwgdWkpO1xuICAgICAgICAgIH0sXG4gICAgICAgICAgYXN5bmMgb25GaW5hbCgpIHtcbiAgICAgICAgICAgIGlmIChoYXNGdW5jdGlvbikge1xuICAgICAgICAgICAgICBhd2FpdCBmaW5pc2hlZDtcbiAgICAgICAgICAgICAgdWkuZG9uZSgpO1xuICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGhhbmRsZVJlbmRlcih7IGNvbnRlbnQsIGRvbmU6IHRydWUgfSwgdGV4dCwgdWkpO1xuICAgICAgICAgICAgYXdhaXQgZmluaXNoZWQ7XG4gICAgICAgICAgICB1aS5kb25lKCk7XG4gICAgICAgICAgfSxcbiAgICAgICAgfSxcbiAgICAgICksXG4gICAgKTtcbiAgfSkoKTtcblxuICByZXR1cm4gdWkudmFsdWU7XG59XG4iLCJpbXBvcnQge1xuICBjcmVhdGVQYXJzZXIsXG4gIHR5cGUgRXZlbnRTb3VyY2VQYXJzZXIsXG4gIHR5cGUgUGFyc2VkRXZlbnQsXG4gIHR5cGUgUmVjb25uZWN0SW50ZXJ2YWwsXG59IGZyb20gJ2V2ZW50c291cmNlLXBhcnNlcic7XG5pbXBvcnQgeyBPcGVuQUlTdHJlYW1DYWxsYmFja3MgfSBmcm9tICcuL29wZW5haS1zdHJlYW0nO1xuXG5leHBvcnQgaW50ZXJmYWNlIEZ1bmN0aW9uQ2FsbFBheWxvYWQge1xuICBuYW1lOiBzdHJpbmc7XG4gIGFyZ3VtZW50czogUmVjb3JkPHN0cmluZywgdW5rbm93bj47XG59XG5leHBvcnQgaW50ZXJmYWNlIFRvb2xDYWxsUGF5bG9hZCB7XG4gIHRvb2xzOiB7XG4gICAgaWQ6IHN0cmluZztcbiAgICB0eXBlOiAnZnVuY3Rpb24nO1xuICAgIGZ1bmM6IHtcbiAgICAgIG5hbWU6IHN0cmluZztcbiAgICAgIGFyZ3VtZW50czogUmVjb3JkPHN0cmluZywgdW5rbm93bj47XG4gICAgfTtcbiAgfVtdO1xufVxuXG4vKipcbiAqIENvbmZpZ3VyYXRpb24gb3B0aW9ucyBhbmQgaGVscGVyIGNhbGxiYWNrIG1ldGhvZHMgZm9yIEFJU3RyZWFtIHN0cmVhbSBsaWZlY3ljbGUgZXZlbnRzLlxuICogQGludGVyZmFjZVxuICovXG5leHBvcnQgaW50ZXJmYWNlIEFJU3RyZWFtQ2FsbGJhY2tzQW5kT3B0aW9ucyB7XG4gIC8qKiBgb25TdGFydGA6IENhbGxlZCBvbmNlIHdoZW4gdGhlIHN0cmVhbSBpcyBpbml0aWFsaXplZC4gKi9cbiAgb25TdGFydD86ICgpID0+IFByb21pc2U8dm9pZD4gfCB2b2lkO1xuICAvKiogYG9uQ29tcGxldGlvbmA6IENhbGxlZCBmb3IgZWFjaCB0b2tlbml6ZWQgbWVzc2FnZS4gKi9cbiAgb25Db21wbGV0aW9uPzogKGNvbXBsZXRpb246IHN0cmluZykgPT4gUHJvbWlzZTx2b2lkPiB8IHZvaWQ7XG4gIC8qKiBgb25GaW5hbGA6IENhbGxlZCBvbmNlIHdoZW4gdGhlIHN0cmVhbSBpcyBjbG9zZWQgd2l0aCB0aGUgZmluYWwgY29tcGxldGlvbiBtZXNzYWdlLiAqL1xuICBvbkZpbmFsPzogKGNvbXBsZXRpb246IHN0cmluZykgPT4gUHJvbWlzZTx2b2lkPiB8IHZvaWQ7XG4gIC8qKiBgb25Ub2tlbmA6IENhbGxlZCBmb3IgZWFjaCB0b2tlbml6ZWQgbWVzc2FnZS4gKi9cbiAgb25Ub2tlbj86ICh0b2tlbjogc3RyaW5nKSA9PiBQcm9taXNlPHZvaWQ+IHwgdm9pZDtcbiAgLyoqIGBvblRleHRgOiBDYWxsZWQgZm9yIGVhY2ggdGV4dCBjaHVuay4gKi9cbiAgb25UZXh0PzogKHRleHQ6IHN0cmluZykgPT4gUHJvbWlzZTx2b2lkPiB8IHZvaWQ7XG4gIC8qKlxuICAgKiBAZGVwcmVjYXRlZCBUaGlzIGZsYWcgaXMgbm8gbG9uZ2VyIHVzZWQgYW5kIG9ubHkgcmV0YWluZWQgZm9yIGJhY2t3YXJkcyBjb21wYXRpYmlsaXR5LlxuICAgKiBZb3UgY2FuIHJlbW92ZSBpdCBmcm9tIHlvdXIgY29kZS5cbiAgICovXG4gIGV4cGVyaW1lbnRhbF9zdHJlYW1EYXRhPzogYm9vbGVhbjtcbn1cblxuLyoqXG4gKiBPcHRpb25zIGZvciB0aGUgQUlTdHJlYW1QYXJzZXIuXG4gKiBAaW50ZXJmYWNlXG4gKiBAcHJvcGVydHkge3N0cmluZ30gZXZlbnQgLSBUaGUgZXZlbnQgKHR5cGUpIGZyb20gdGhlIHNlcnZlciBzaWRlIGV2ZW50IHN0cmVhbS5cbiAqL1xuZXhwb3J0IGludGVyZmFjZSBBSVN0cmVhbVBhcnNlck9wdGlvbnMge1xuICBldmVudD86IHN0cmluZztcbn1cblxuLyoqXG4gKiBDdXN0b20gcGFyc2VyIGZvciBBSVN0cmVhbSBkYXRhLlxuICogQGludGVyZmFjZVxuICogQHBhcmFtIHtzdHJpbmd9IGRhdGEgLSBUaGUgZGF0YSB0byBiZSBwYXJzZWQuXG4gKiBAcGFyYW0ge0FJU3RyZWFtUGFyc2VyT3B0aW9uc30gb3B0aW9ucyAtIFRoZSBvcHRpb25zIGZvciB0aGUgcGFyc2VyLlxuICogQHJldHVybnMge3N0cmluZyB8IHZvaWR9IFRoZSBwYXJzZWQgZGF0YSBvciB2b2lkLlxuICovXG5leHBvcnQgaW50ZXJmYWNlIEFJU3RyZWFtUGFyc2VyIHtcbiAgKGRhdGE6IHN0cmluZywgb3B0aW9uczogQUlTdHJlYW1QYXJzZXJPcHRpb25zKTpcbiAgICB8IHN0cmluZ1xuICAgIHwgdm9pZFxuICAgIHwgeyBpc1RleHQ6IGZhbHNlOyBjb250ZW50OiBzdHJpbmcgfTtcbn1cblxuLyoqXG4gKiBDcmVhdGVzIGEgVHJhbnNmb3JtU3RyZWFtIHRoYXQgcGFyc2VzIGV2ZW50cyBmcm9tIGFuIEV2ZW50U291cmNlIHN0cmVhbSB1c2luZyBhIGN1c3RvbSBwYXJzZXIuXG4gKiBAcGFyYW0ge0FJU3RyZWFtUGFyc2VyfSBjdXN0b21QYXJzZXIgLSBGdW5jdGlvbiB0byBoYW5kbGUgZXZlbnQgZGF0YS5cbiAqIEByZXR1cm5zIHtUcmFuc2Zvcm1TdHJlYW08VWludDhBcnJheSwgc3RyaW5nPn0gVHJhbnNmb3JtU3RyZWFtIHBhcnNpbmcgZXZlbnRzLlxuICovXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlRXZlbnRTdHJlYW1UcmFuc2Zvcm1lcihcbiAgY3VzdG9tUGFyc2VyPzogQUlTdHJlYW1QYXJzZXIsXG4pOiBUcmFuc2Zvcm1TdHJlYW08VWludDhBcnJheSwgc3RyaW5nIHwgeyBpc1RleHQ6IGZhbHNlOyBjb250ZW50OiBzdHJpbmcgfT4ge1xuICBjb25zdCB0ZXh0RGVjb2RlciA9IG5ldyBUZXh0RGVjb2RlcigpO1xuICBsZXQgZXZlbnRTb3VyY2VQYXJzZXI6IEV2ZW50U291cmNlUGFyc2VyO1xuXG4gIHJldHVybiBuZXcgVHJhbnNmb3JtU3RyZWFtKHtcbiAgICBhc3luYyBzdGFydChjb250cm9sbGVyKTogUHJvbWlzZTx2b2lkPiB7XG4gICAgICBldmVudFNvdXJjZVBhcnNlciA9IGNyZWF0ZVBhcnNlcihcbiAgICAgICAgKGV2ZW50OiBQYXJzZWRFdmVudCB8IFJlY29ubmVjdEludGVydmFsKSA9PiB7XG4gICAgICAgICAgaWYgKFxuICAgICAgICAgICAgKCdkYXRhJyBpbiBldmVudCAmJlxuICAgICAgICAgICAgICBldmVudC50eXBlID09PSAnZXZlbnQnICYmXG4gICAgICAgICAgICAgIGV2ZW50LmRhdGEgPT09ICdbRE9ORV0nKSB8fFxuICAgICAgICAgICAgLy8gUmVwbGljYXRlIGRvZXNuJ3Qgc2VuZCBbRE9ORV0gYnV0IGRvZXMgc2VuZCBhICdkb25lJyBldmVudFxuICAgICAgICAgICAgLy8gQHNlZSBodHRwczovL3JlcGxpY2F0ZS5jb20vZG9jcy9zdHJlYW1pbmdcbiAgICAgICAgICAgIChldmVudCBhcyBhbnkpLmV2ZW50ID09PSAnZG9uZSdcbiAgICAgICAgICApIHtcbiAgICAgICAgICAgIGNvbnRyb2xsZXIudGVybWluYXRlKCk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKCdkYXRhJyBpbiBldmVudCkge1xuICAgICAgICAgICAgY29uc3QgcGFyc2VkTWVzc2FnZSA9IGN1c3RvbVBhcnNlclxuICAgICAgICAgICAgICA/IGN1c3RvbVBhcnNlcihldmVudC5kYXRhLCB7XG4gICAgICAgICAgICAgICAgICBldmVudDogZXZlbnQuZXZlbnQsXG4gICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgOiBldmVudC5kYXRhO1xuICAgICAgICAgICAgaWYgKHBhcnNlZE1lc3NhZ2UpIGNvbnRyb2xsZXIuZW5xdWV1ZShwYXJzZWRNZXNzYWdlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICApO1xuICAgIH0sXG5cbiAgICB0cmFuc2Zvcm0oY2h1bmspIHtcbiAgICAgIGV2ZW50U291cmNlUGFyc2VyLmZlZWQodGV4dERlY29kZXIuZGVjb2RlKGNodW5rKSk7XG4gICAgfSxcbiAgfSk7XG59XG5cbi8qKlxuICogQ3JlYXRlcyBhIHRyYW5zZm9ybSBzdHJlYW0gdGhhdCBlbmNvZGVzIGlucHV0IG1lc3NhZ2VzIGFuZCBpbnZva2VzIG9wdGlvbmFsIGNhbGxiYWNrIGZ1bmN0aW9ucy5cbiAqIFRoZSB0cmFuc2Zvcm0gc3RyZWFtIHVzZXMgdGhlIHByb3ZpZGVkIGNhbGxiYWNrcyB0byBleGVjdXRlIGN1c3RvbSBsb2dpYyBhdCBkaWZmZXJlbnQgc3RhZ2VzIG9mIHRoZSBzdHJlYW0ncyBsaWZlY3ljbGUuXG4gKiAtIGBvblN0YXJ0YDogQ2FsbGVkIG9uY2Ugd2hlbiB0aGUgc3RyZWFtIGlzIGluaXRpYWxpemVkLlxuICogLSBgb25Ub2tlbmA6IENhbGxlZCBmb3IgZWFjaCB0b2tlbml6ZWQgbWVzc2FnZS5cbiAqIC0gYG9uQ29tcGxldGlvbmA6IENhbGxlZCBldmVyeSB0aW1lIGFuIEFJU3RyZWFtIGNvbXBsZXRpb24gbWVzc2FnZSBpcyByZWNlaXZlZC4gVGhpcyBjYW4gb2NjdXIgbXVsdGlwbGUgdGltZXMgd2hlbiB1c2luZyBlLmcuIE9wZW5BSSBmdW5jdGlvbnNcbiAqIC0gYG9uRmluYWxgOiBDYWxsZWQgb25jZSB3aGVuIHRoZSBzdHJlYW0gaXMgY2xvc2VkIHdpdGggdGhlIGZpbmFsIGNvbXBsZXRpb24gbWVzc2FnZS5cbiAqXG4gKiBUaGlzIGZ1bmN0aW9uIGlzIHVzZWZ1bCB3aGVuIHlvdSB3YW50IHRvIHByb2Nlc3MgYSBzdHJlYW0gb2YgbWVzc2FnZXMgYW5kIHBlcmZvcm0gc3BlY2lmaWMgYWN0aW9ucyBkdXJpbmcgdGhlIHN0cmVhbSdzIGxpZmVjeWNsZS5cbiAqXG4gKiBAcGFyYW0ge0FJU3RyZWFtQ2FsbGJhY2tzQW5kT3B0aW9uc30gW2NhbGxiYWNrc10gLSBBbiBvYmplY3QgY29udGFpbmluZyB0aGUgY2FsbGJhY2sgZnVuY3Rpb25zLlxuICogQHJldHVybiB7VHJhbnNmb3JtU3RyZWFtPHN0cmluZywgVWludDhBcnJheT59IEEgdHJhbnNmb3JtIHN0cmVhbSB0aGF0IGVuY29kZXMgaW5wdXQgbWVzc2FnZXMgYXMgVWludDhBcnJheSBhbmQgYWxsb3dzIHRoZSBleGVjdXRpb24gb2YgY3VzdG9tIGxvZ2ljIHRocm91Z2ggY2FsbGJhY2tzLlxuICpcbiAqIEBleGFtcGxlXG4gKiBjb25zdCBjYWxsYmFja3MgPSB7XG4gKiAgIG9uU3RhcnQ6IGFzeW5jICgpID0+IGNvbnNvbGUubG9nKCdTdHJlYW0gc3RhcnRlZCcpLFxuICogICBvblRva2VuOiBhc3luYyAodG9rZW4pID0+IGNvbnNvbGUubG9nKGBUb2tlbjogJHt0b2tlbn1gKSxcbiAqICAgb25Db21wbGV0aW9uOiBhc3luYyAoY29tcGxldGlvbikgPT4gY29uc29sZS5sb2coYENvbXBsZXRpb246ICR7Y29tcGxldGlvbn1gKVxuICogICBvbkZpbmFsOiBhc3luYyAoKSA9PiBkYXRhLmNsb3NlKClcbiAqIH07XG4gKiBjb25zdCB0cmFuc2Zvcm1lciA9IGNyZWF0ZUNhbGxiYWNrc1RyYW5zZm9ybWVyKGNhbGxiYWNrcyk7XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVDYWxsYmFja3NUcmFuc2Zvcm1lcihcbiAgY2I6IEFJU3RyZWFtQ2FsbGJhY2tzQW5kT3B0aW9ucyB8IE9wZW5BSVN0cmVhbUNhbGxiYWNrcyB8IHVuZGVmaW5lZCxcbik6IFRyYW5zZm9ybVN0cmVhbTxzdHJpbmcgfCB7IGlzVGV4dDogZmFsc2U7IGNvbnRlbnQ6IHN0cmluZyB9LCBVaW50OEFycmF5PiB7XG4gIGNvbnN0IHRleHRFbmNvZGVyID0gbmV3IFRleHRFbmNvZGVyKCk7XG4gIGxldCBhZ2dyZWdhdGVkUmVzcG9uc2UgPSAnJztcbiAgY29uc3QgY2FsbGJhY2tzID0gY2IgfHwge307XG5cbiAgcmV0dXJuIG5ldyBUcmFuc2Zvcm1TdHJlYW0oe1xuICAgIGFzeW5jIHN0YXJ0KCk6IFByb21pc2U8dm9pZD4ge1xuICAgICAgaWYgKGNhbGxiYWNrcy5vblN0YXJ0KSBhd2FpdCBjYWxsYmFja3Mub25TdGFydCgpO1xuICAgIH0sXG5cbiAgICBhc3luYyB0cmFuc2Zvcm0obWVzc2FnZSwgY29udHJvbGxlcik6IFByb21pc2U8dm9pZD4ge1xuICAgICAgY29uc3QgY29udGVudCA9IHR5cGVvZiBtZXNzYWdlID09PSAnc3RyaW5nJyA/IG1lc3NhZ2UgOiBtZXNzYWdlLmNvbnRlbnQ7XG5cbiAgICAgIGNvbnRyb2xsZXIuZW5xdWV1ZSh0ZXh0RW5jb2Rlci5lbmNvZGUoY29udGVudCkpO1xuXG4gICAgICBhZ2dyZWdhdGVkUmVzcG9uc2UgKz0gY29udGVudDtcblxuICAgICAgaWYgKGNhbGxiYWNrcy5vblRva2VuKSBhd2FpdCBjYWxsYmFja3Mub25Ub2tlbihjb250ZW50KTtcbiAgICAgIGlmIChjYWxsYmFja3Mub25UZXh0ICYmIHR5cGVvZiBtZXNzYWdlID09PSAnc3RyaW5nJykge1xuICAgICAgICBhd2FpdCBjYWxsYmFja3Mub25UZXh0KG1lc3NhZ2UpO1xuICAgICAgfVxuICAgIH0sXG5cbiAgICBhc3luYyBmbHVzaCgpOiBQcm9taXNlPHZvaWQ+IHtcbiAgICAgIGNvbnN0IGlzT3BlbkFJQ2FsbGJhY2tzID0gaXNPZlR5cGVPcGVuQUlTdHJlYW1DYWxsYmFja3MoY2FsbGJhY2tzKTtcbiAgICAgIC8vIElmIGl0J3MgT3BlbkFJQ2FsbGJhY2tzLCBpdCBoYXMgYW4gZXhwZXJpbWVudGFsX29uRnVuY3Rpb25DYWxsIHdoaWNoIG1lYW5zIHRoYXQgdGhlIGNyZWF0ZUZ1bmN0aW9uQ2FsbFRyYW5zZm9ybWVyXG4gICAgICAvLyB3aWxsIGhhbmRsZSBjYWxsaW5nIG9uQ29tcGxldGUuXG4gICAgICBpZiAoY2FsbGJhY2tzLm9uQ29tcGxldGlvbikge1xuICAgICAgICBhd2FpdCBjYWxsYmFja3Mub25Db21wbGV0aW9uKGFnZ3JlZ2F0ZWRSZXNwb25zZSk7XG4gICAgICB9XG5cbiAgICAgIGlmIChjYWxsYmFja3Mub25GaW5hbCAmJiAhaXNPcGVuQUlDYWxsYmFja3MpIHtcbiAgICAgICAgYXdhaXQgY2FsbGJhY2tzLm9uRmluYWwoYWdncmVnYXRlZFJlc3BvbnNlKTtcbiAgICAgIH1cbiAgICB9LFxuICB9KTtcbn1cblxuZnVuY3Rpb24gaXNPZlR5cGVPcGVuQUlTdHJlYW1DYWxsYmFja3MoXG4gIGNhbGxiYWNrczogQUlTdHJlYW1DYWxsYmFja3NBbmRPcHRpb25zIHwgT3BlbkFJU3RyZWFtQ2FsbGJhY2tzLFxuKTogY2FsbGJhY2tzIGlzIE9wZW5BSVN0cmVhbUNhbGxiYWNrcyB7XG4gIHJldHVybiAnZXhwZXJpbWVudGFsX29uRnVuY3Rpb25DYWxsJyBpbiBjYWxsYmFja3M7XG59XG4vKipcbiAqIFJldHVybnMgYSBzdGF0ZWZ1bCBmdW5jdGlvbiB0aGF0LCB3aGVuIGludm9rZWQsIHRyaW1zIGxlYWRpbmcgd2hpdGVzcGFjZVxuICogZnJvbSB0aGUgaW5wdXQgdGV4dC4gVGhlIHRyaW1taW5nIG9ubHkgb2NjdXJzIG9uIHRoZSBmaXJzdCBpbnZvY2F0aW9uLCBlbnN1cmluZyB0aGF0XG4gKiBzdWJzZXF1ZW50IGNhbGxzIGRvIG5vdCBhbHRlciB0aGUgaW5wdXQgdGV4dC4gVGhpcyBpcyBwYXJ0aWN1bGFybHkgdXNlZnVsIGluIHNjZW5hcmlvc1xuICogd2hlcmUgYSB0ZXh0IHN0cmVhbSBpcyBiZWluZyBwcm9jZXNzZWQgYW5kIG9ubHkgdGhlIGluaXRpYWwgd2hpdGVzcGFjZSBzaG91bGQgYmUgcmVtb3ZlZC5cbiAqXG4gKiBAcmV0dXJuIHtmdW5jdGlvbihzdHJpbmcpOiBzdHJpbmd9IEEgZnVuY3Rpb24gdGhhdCB0YWtlcyBhIHN0cmluZyBhcyBpbnB1dCBhbmQgcmV0dXJucyBhIHN0cmluZ1xuICogd2l0aCBsZWFkaW5nIHdoaXRlc3BhY2UgcmVtb3ZlZCBpZiBpdCBpcyB0aGUgZmlyc3QgaW52b2NhdGlvbjsgb3RoZXJ3aXNlLCBpdCByZXR1cm5zIHRoZSBpbnB1dCB1bmNoYW5nZWQuXG4gKlxuICogQGV4YW1wbGVcbiAqIGNvbnN0IHRyaW1TdGFydCA9IHRyaW1TdGFydE9mU3RyZWFtSGVscGVyKCk7XG4gKiBjb25zdCBvdXRwdXQxID0gdHJpbVN0YXJ0KFwiICAgdGV4dFwiKTsgLy8gXCJ0ZXh0XCJcbiAqIGNvbnN0IG91dHB1dDIgPSB0cmltU3RhcnQoXCIgICB0ZXh0XCIpOyAvLyBcIiAgIHRleHRcIlxuICpcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHRyaW1TdGFydE9mU3RyZWFtSGVscGVyKCk6ICh0ZXh0OiBzdHJpbmcpID0+IHN0cmluZyB7XG4gIGxldCBpc1N0cmVhbVN0YXJ0ID0gdHJ1ZTtcblxuICByZXR1cm4gKHRleHQ6IHN0cmluZyk6IHN0cmluZyA9PiB7XG4gICAgaWYgKGlzU3RyZWFtU3RhcnQpIHtcbiAgICAgIHRleHQgPSB0ZXh0LnRyaW1TdGFydCgpO1xuICAgICAgaWYgKHRleHQpIGlzU3RyZWFtU3RhcnQgPSBmYWxzZTtcbiAgICB9XG4gICAgcmV0dXJuIHRleHQ7XG4gIH07XG59XG5cbi8qKlxuICogUmV0dXJucyBhIFJlYWRhYmxlU3RyZWFtIGNyZWF0ZWQgZnJvbSB0aGUgcmVzcG9uc2UsIHBhcnNlZCBhbmQgaGFuZGxlZCB3aXRoIGN1c3RvbSBsb2dpYy5cbiAqIFRoZSBzdHJlYW0gZ29lcyB0aHJvdWdoIHR3byB0cmFuc2Zvcm1hdGlvbiBzdGFnZXMsIGZpcnN0IHBhcnNpbmcgdGhlIGV2ZW50cyBhbmQgdGhlblxuICogaW52b2tpbmcgdGhlIHByb3ZpZGVkIGNhbGxiYWNrcy5cbiAqXG4gKiBGb3IgMnh4IEhUVFAgcmVzcG9uc2VzOlxuICogLSBUaGUgZnVuY3Rpb24gY29udGludWVzIHdpdGggc3RhbmRhcmQgc3RyZWFtIHByb2Nlc3NpbmcuXG4gKlxuICogRm9yIG5vbi0yeHggSFRUUCByZXNwb25zZXM6XG4gKiAtIElmIHRoZSByZXNwb25zZSBib2R5IGlzIGRlZmluZWQsIGl0IGFzeW5jaHJvbm91c2x5IGV4dHJhY3RzIGFuZCBkZWNvZGVzIHRoZSByZXNwb25zZSBib2R5LlxuICogLSBJdCB0aGVuIGNyZWF0ZXMgYSBjdXN0b20gUmVhZGFibGVTdHJlYW0gdG8gcHJvcGFnYXRlIGEgZGV0YWlsZWQgZXJyb3IgbWVzc2FnZS5cbiAqXG4gKiBAcGFyYW0ge1Jlc3BvbnNlfSByZXNwb25zZSAtIFRoZSByZXNwb25zZS5cbiAqIEBwYXJhbSB7QUlTdHJlYW1QYXJzZXJ9IGN1c3RvbVBhcnNlciAtIFRoZSBjdXN0b20gcGFyc2VyIGZ1bmN0aW9uLlxuICogQHBhcmFtIHtBSVN0cmVhbUNhbGxiYWNrc0FuZE9wdGlvbnN9IGNhbGxiYWNrcyAtIFRoZSBjYWxsYmFja3MuXG4gKiBAcmV0dXJuIHtSZWFkYWJsZVN0cmVhbX0gVGhlIEFJU3RyZWFtLlxuICogQHRocm93cyBXaWxsIHRocm93IGFuIGVycm9yIGlmIHRoZSByZXNwb25zZSBpcyBub3QgT0suXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBBSVN0cmVhbShcbiAgcmVzcG9uc2U6IFJlc3BvbnNlLFxuICBjdXN0b21QYXJzZXI/OiBBSVN0cmVhbVBhcnNlcixcbiAgY2FsbGJhY2tzPzogQUlTdHJlYW1DYWxsYmFja3NBbmRPcHRpb25zLFxuKTogUmVhZGFibGVTdHJlYW08VWludDhBcnJheT4ge1xuICBpZiAoIXJlc3BvbnNlLm9rKSB7XG4gICAgaWYgKHJlc3BvbnNlLmJvZHkpIHtcbiAgICAgIGNvbnN0IHJlYWRlciA9IHJlc3BvbnNlLmJvZHkuZ2V0UmVhZGVyKCk7XG4gICAgICByZXR1cm4gbmV3IFJlYWRhYmxlU3RyZWFtKHtcbiAgICAgICAgYXN5bmMgc3RhcnQoY29udHJvbGxlcikge1xuICAgICAgICAgIGNvbnN0IHsgZG9uZSwgdmFsdWUgfSA9IGF3YWl0IHJlYWRlci5yZWFkKCk7XG4gICAgICAgICAgaWYgKCFkb25lKSB7XG4gICAgICAgICAgICBjb25zdCBlcnJvclRleHQgPSBuZXcgVGV4dERlY29kZXIoKS5kZWNvZGUodmFsdWUpO1xuICAgICAgICAgICAgY29udHJvbGxlci5lcnJvcihuZXcgRXJyb3IoYFJlc3BvbnNlIGVycm9yOiAke2Vycm9yVGV4dH1gKSk7XG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBuZXcgUmVhZGFibGVTdHJlYW0oe1xuICAgICAgICBzdGFydChjb250cm9sbGVyKSB7XG4gICAgICAgICAgY29udHJvbGxlci5lcnJvcihuZXcgRXJyb3IoJ1Jlc3BvbnNlIGVycm9yOiBObyByZXNwb25zZSBib2R5JykpO1xuICAgICAgICB9LFxuICAgICAgfSk7XG4gICAgfVxuICB9XG5cbiAgY29uc3QgcmVzcG9uc2VCb2R5U3RyZWFtID0gcmVzcG9uc2UuYm9keSB8fCBjcmVhdGVFbXB0eVJlYWRhYmxlU3RyZWFtKCk7XG5cbiAgcmV0dXJuIHJlc3BvbnNlQm9keVN0cmVhbVxuICAgIC5waXBlVGhyb3VnaChjcmVhdGVFdmVudFN0cmVhbVRyYW5zZm9ybWVyKGN1c3RvbVBhcnNlcikpXG4gICAgLnBpcGVUaHJvdWdoKGNyZWF0ZUNhbGxiYWNrc1RyYW5zZm9ybWVyKGNhbGxiYWNrcykpO1xufVxuXG4vLyBvdXRwdXRzIGxpbmVzIGxpa2Vcbi8vIDA6IGNodW5rXG4vLyAwOiBtb3JlIGNodW5rXG4vLyAxOiBhIGZjdCBjYWxsXG4vLyB6OiBhZGRlZCBkYXRhIGZyb20gRGF0YVxuXG4vKipcbiAqIENyZWF0ZXMgYW4gZW1wdHkgUmVhZGFibGVTdHJlYW0gdGhhdCBpbW1lZGlhdGVseSBjbG9zZXMgdXBvbiBjcmVhdGlvbi5cbiAqIFRoaXMgZnVuY3Rpb24gaXMgdXNlZCBhcyBhIGZhbGxiYWNrIGZvciBjcmVhdGluZyBhIFJlYWRhYmxlU3RyZWFtIHdoZW4gdGhlIHJlc3BvbnNlIGJvZHkgaXMgbnVsbCBvciB1bmRlZmluZWQsXG4gKiBlbnN1cmluZyB0aGF0IHRoZSBzdWJzZXF1ZW50IHBpcGVsaW5lIHByb2Nlc3NpbmcgZG9lc24ndCBmYWlsIGR1ZSB0byBhIGxhY2sgb2YgYSBzdHJlYW0uXG4gKlxuICogQHJldHVybnMge1JlYWRhYmxlU3RyZWFtfSBBbiBlbXB0eSBhbmQgY2xvc2VkIFJlYWRhYmxlU3RyZWFtIGluc3RhbmNlLlxuICovXG5mdW5jdGlvbiBjcmVhdGVFbXB0eVJlYWRhYmxlU3RyZWFtKCk6IFJlYWRhYmxlU3RyZWFtIHtcbiAgcmV0dXJuIG5ldyBSZWFkYWJsZVN0cmVhbSh7XG4gICAgc3RhcnQoY29udHJvbGxlcikge1xuICAgICAgY29udHJvbGxlci5jbG9zZSgpO1xuICAgIH0sXG4gIH0pO1xufVxuXG4vKipcbiAqIEltcGxlbWVudHMgUmVhZGFibGVTdHJlYW0uZnJvbShhc3luY0l0ZXJhYmxlKSwgd2hpY2ggaXNuJ3QgZG9jdW1lbnRlZCBpbiBNRE4gYW5kIGlzbid0IGltcGxlbWVudGVkIGluIG5vZGUuXG4gKiBodHRwczovL2dpdGh1Yi5jb20vd2hhdHdnL3N0cmVhbXMvY29tbWl0LzhkN2EwYmYyNmViMmNjMjNlODg0ZGRiYWFjN2MxZGE0YjkxY2YyYmNcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHJlYWRhYmxlRnJvbUFzeW5jSXRlcmFibGU8VD4oaXRlcmFibGU6IEFzeW5jSXRlcmFibGU8VD4pIHtcbiAgbGV0IGl0ID0gaXRlcmFibGVbU3ltYm9sLmFzeW5jSXRlcmF0b3JdKCk7XG4gIHJldHVybiBuZXcgUmVhZGFibGVTdHJlYW08VD4oe1xuICAgIGFzeW5jIHB1bGwoY29udHJvbGxlcikge1xuICAgICAgY29uc3QgeyBkb25lLCB2YWx1ZSB9ID0gYXdhaXQgaXQubmV4dCgpO1xuICAgICAgaWYgKGRvbmUpIGNvbnRyb2xsZXIuY2xvc2UoKTtcbiAgICAgIGVsc2UgY29udHJvbGxlci5lbnF1ZXVlKHZhbHVlKTtcbiAgICB9LFxuXG4gICAgYXN5bmMgY2FuY2VsKHJlYXNvbikge1xuICAgICAgYXdhaXQgaXQucmV0dXJuPy4ocmVhc29uKTtcbiAgICB9LFxuICB9KTtcbn1cbiIsImltcG9ydCB7IEpTT05WYWx1ZSwgZm9ybWF0U3RyZWFtUGFydCB9IGZyb20gJ0BhaS1zZGsvdWktdXRpbHMnO1xuaW1wb3J0IHsgSEFOR0lOR19TVFJFQU1fV0FSTklOR19USU1FX01TIH0gZnJvbSAnLi4vdXRpbC9jb25zdGFudHMnO1xuXG4vKipcbiAqIEEgc3RyZWFtIHdyYXBwZXIgdG8gc2VuZCBjdXN0b20gSlNPTi1lbmNvZGVkIGRhdGEgYmFjayB0byB0aGUgY2xpZW50LlxuICovXG5leHBvcnQgY2xhc3MgU3RyZWFtRGF0YSB7XG4gIHByaXZhdGUgZW5jb2RlciA9IG5ldyBUZXh0RW5jb2RlcigpO1xuXG4gIHByaXZhdGUgY29udHJvbGxlcjogUmVhZGFibGVTdHJlYW1Db250cm9sbGVyPFVpbnQ4QXJyYXk+IHwgbnVsbCA9IG51bGw7XG4gIHB1YmxpYyBzdHJlYW06IFJlYWRhYmxlU3RyZWFtPFVpbnQ4QXJyYXk+O1xuXG4gIHByaXZhdGUgaXNDbG9zZWQ6IGJvb2xlYW4gPSBmYWxzZTtcbiAgcHJpdmF0ZSB3YXJuaW5nVGltZW91dDogTm9kZUpTLlRpbWVvdXQgfCBudWxsID0gbnVsbDtcblxuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBjb25zdCBzZWxmID0gdGhpcztcblxuICAgIHRoaXMuc3RyZWFtID0gbmV3IFJlYWRhYmxlU3RyZWFtKHtcbiAgICAgIHN0YXJ0OiBhc3luYyBjb250cm9sbGVyID0+IHtcbiAgICAgICAgc2VsZi5jb250cm9sbGVyID0gY29udHJvbGxlcjtcblxuICAgICAgICAvLyBTZXQgYSB0aW1lb3V0IHRvIHNob3cgYSB3YXJuaW5nIGlmIHRoZSBzdHJlYW0gaXMgbm90IGNsb3NlZCB3aXRoaW4gMyBzZWNvbmRzXG4gICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gJ2RldmVsb3BtZW50Jykge1xuICAgICAgICAgIHNlbGYud2FybmluZ1RpbWVvdXQgPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgIGNvbnNvbGUud2FybihcbiAgICAgICAgICAgICAgJ1RoZSBkYXRhIHN0cmVhbSBpcyBoYW5naW5nLiBEaWQgeW91IGZvcmdldCB0byBjbG9zZSBpdCB3aXRoIGBkYXRhLmNsb3NlKClgPycsXG4gICAgICAgICAgICApO1xuICAgICAgICAgIH0sIEhBTkdJTkdfU1RSRUFNX1dBUk5JTkdfVElNRV9NUyk7XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBwdWxsOiBjb250cm9sbGVyID0+IHtcbiAgICAgICAgLy8gTm8tb3A6IHdlIGRvbid0IG5lZWQgdG8gZG8gYW55dGhpbmcgc3BlY2lhbCBvbiBwdWxsXG4gICAgICB9LFxuICAgICAgY2FuY2VsOiByZWFzb24gPT4ge1xuICAgICAgICB0aGlzLmlzQ2xvc2VkID0gdHJ1ZTtcbiAgICAgIH0sXG4gICAgfSk7XG4gIH1cblxuICBhc3luYyBjbG9zZSgpOiBQcm9taXNlPHZvaWQ+IHtcbiAgICBpZiAodGhpcy5pc0Nsb3NlZCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdEYXRhIFN0cmVhbSBoYXMgYWxyZWFkeSBiZWVuIGNsb3NlZC4nKTtcbiAgICB9XG5cbiAgICBpZiAoIXRoaXMuY29udHJvbGxlcikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdTdHJlYW0gY29udHJvbGxlciBpcyBub3QgaW5pdGlhbGl6ZWQuJyk7XG4gICAgfVxuXG4gICAgdGhpcy5jb250cm9sbGVyLmNsb3NlKCk7XG4gICAgdGhpcy5pc0Nsb3NlZCA9IHRydWU7XG5cbiAgICAvLyBDbGVhciB0aGUgd2FybmluZyB0aW1lb3V0IGlmIHRoZSBzdHJlYW0gaXMgY2xvc2VkXG4gICAgaWYgKHRoaXMud2FybmluZ1RpbWVvdXQpIHtcbiAgICAgIGNsZWFyVGltZW91dCh0aGlzLndhcm5pbmdUaW1lb3V0KTtcbiAgICB9XG4gIH1cblxuICBhcHBlbmQodmFsdWU6IEpTT05WYWx1ZSk6IHZvaWQge1xuICAgIGlmICh0aGlzLmlzQ2xvc2VkKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0RhdGEgU3RyZWFtIGhhcyBhbHJlYWR5IGJlZW4gY2xvc2VkLicpO1xuICAgIH1cblxuICAgIGlmICghdGhpcy5jb250cm9sbGVyKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1N0cmVhbSBjb250cm9sbGVyIGlzIG5vdCBpbml0aWFsaXplZC4nKTtcbiAgICB9XG5cbiAgICB0aGlzLmNvbnRyb2xsZXIuZW5xdWV1ZShcbiAgICAgIHRoaXMuZW5jb2Rlci5lbmNvZGUoZm9ybWF0U3RyZWFtUGFydCgnZGF0YScsIFt2YWx1ZV0pKSxcbiAgICApO1xuICB9XG5cbiAgYXBwZW5kTWVzc2FnZUFubm90YXRpb24odmFsdWU6IEpTT05WYWx1ZSk6IHZvaWQge1xuICAgIGlmICh0aGlzLmlzQ2xvc2VkKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0RhdGEgU3RyZWFtIGhhcyBhbHJlYWR5IGJlZW4gY2xvc2VkLicpO1xuICAgIH1cblxuICAgIGlmICghdGhpcy5jb250cm9sbGVyKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1N0cmVhbSBjb250cm9sbGVyIGlzIG5vdCBpbml0aWFsaXplZC4nKTtcbiAgICB9XG5cbiAgICB0aGlzLmNvbnRyb2xsZXIuZW5xdWV1ZShcbiAgICAgIHRoaXMuZW5jb2Rlci5lbmNvZGUoZm9ybWF0U3RyZWFtUGFydCgnbWVzc2FnZV9hbm5vdGF0aW9ucycsIFt2YWx1ZV0pKSxcbiAgICApO1xuICB9XG59XG5cbi8qKlxuICogQSBUcmFuc2Zvcm1TdHJlYW0gZm9yIExMTXMgdGhhdCBkbyBub3QgaGF2ZSB0aGVpciBvd24gdHJhbnNmb3JtIHN0cmVhbSBoYW5kbGVycyBtYW5hZ2luZyBlbmNvZGluZyAoZS5nLiBPcGVuQUlTdHJlYW0gaGFzIG9uZSBmb3IgZnVuY3Rpb24gY2FsbCBoYW5kbGluZykuXG4gKiBUaGlzIGFzc3VtZXMgZXZlcnkgY2h1bmsgaXMgYSAndGV4dCcgY2h1bmsuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVTdHJlYW1EYXRhVHJhbnNmb3JtZXIoKSB7XG4gIGNvbnN0IGVuY29kZXIgPSBuZXcgVGV4dEVuY29kZXIoKTtcbiAgY29uc3QgZGVjb2RlciA9IG5ldyBUZXh0RGVjb2RlcigpO1xuICByZXR1cm4gbmV3IFRyYW5zZm9ybVN0cmVhbSh7XG4gICAgdHJhbnNmb3JtOiBhc3luYyAoY2h1bmssIGNvbnRyb2xsZXIpID0+IHtcbiAgICAgIGNvbnN0IG1lc3NhZ2UgPSBkZWNvZGVyLmRlY29kZShjaHVuayk7XG4gICAgICBjb250cm9sbGVyLmVucXVldWUoZW5jb2Rlci5lbmNvZGUoZm9ybWF0U3RyZWFtUGFydCgndGV4dCcsIG1lc3NhZ2UpKSk7XG4gICAgfSxcbiAgfSk7XG59XG5cbi8qKlxuQGRlcHJlY2F0ZWQgVXNlIGBTdHJlYW1EYXRhYCBpbnN0ZWFkLlxuICovXG5leHBvcnQgY2xhc3MgZXhwZXJpbWVudGFsX1N0cmVhbURhdGEgZXh0ZW5kcyBTdHJlYW1EYXRhIHt9XG4iLCJpbXBvcnQge1xuICBDcmVhdGVNZXNzYWdlLFxuICBGdW5jdGlvbkNhbGwsXG4gIEpTT05WYWx1ZSxcbiAgVG9vbENhbGwsXG4gIGNyZWF0ZUNodW5rRGVjb2RlcixcbiAgZm9ybWF0U3RyZWFtUGFydCxcbn0gZnJvbSAnQGFpLXNkay91aS11dGlscyc7XG5pbXBvcnQge1xuICBBSVN0cmVhbSxcbiAgRnVuY3Rpb25DYWxsUGF5bG9hZCxcbiAgVG9vbENhbGxQYXlsb2FkLFxuICBjcmVhdGVDYWxsYmFja3NUcmFuc2Zvcm1lcixcbiAgcmVhZGFibGVGcm9tQXN5bmNJdGVyYWJsZSxcbiAgdHJpbVN0YXJ0T2ZTdHJlYW1IZWxwZXIsXG4gIHR5cGUgQUlTdHJlYW1DYWxsYmFja3NBbmRPcHRpb25zLFxufSBmcm9tICcuL2FpLXN0cmVhbSc7XG5pbXBvcnQgeyBBenVyZUNoYXRDb21wbGV0aW9ucyB9IGZyb20gJy4vYXp1cmUtb3BlbmFpLXR5cGVzJztcbmltcG9ydCB7IGNyZWF0ZVN0cmVhbURhdGFUcmFuc2Zvcm1lciB9IGZyb20gJy4vc3RyZWFtLWRhdGEnO1xuXG5leHBvcnQgdHlwZSBPcGVuQUlTdHJlYW1DYWxsYmFja3MgPSBBSVN0cmVhbUNhbGxiYWNrc0FuZE9wdGlvbnMgJiB7XG4gIC8qKlxuICAgKiBAZXhhbXBsZVxuICAgKiBgYGBqc1xuICAgKiBjb25zdCByZXNwb25zZSA9IGF3YWl0IG9wZW5haS5jaGF0LmNvbXBsZXRpb25zLmNyZWF0ZSh7XG4gICAqICAgbW9kZWw6ICdncHQtMy41LXR1cmJvLTA2MTMnLFxuICAgKiAgIHN0cmVhbTogdHJ1ZSxcbiAgICogICBtZXNzYWdlcyxcbiAgICogICBmdW5jdGlvbnMsXG4gICAqIH0pXG4gICAqXG4gICAqIGNvbnN0IHN0cmVhbSA9IE9wZW5BSVN0cmVhbShyZXNwb25zZSwge1xuICAgKiAgIGV4cGVyaW1lbnRhbF9vbkZ1bmN0aW9uQ2FsbDogYXN5bmMgKGZ1bmN0aW9uQ2FsbFBheWxvYWQsIGNyZWF0ZUZ1bmN0aW9uQ2FsbE1lc3NhZ2VzKSA9PiB7XG4gICAqICAgICAvLyAuLi4gcnVuIHlvdXIgY3VzdG9tIGxvZ2ljIGhlcmVcbiAgICogICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IG15RnVuY3Rpb24oZnVuY3Rpb25DYWxsUGF5bG9hZClcbiAgICpcbiAgICogICAgIC8vIEFzayBmb3IgYW5vdGhlciBjb21wbGV0aW9uLCBvciByZXR1cm4gYSBzdHJpbmcgdG8gc2VuZCB0byB0aGUgY2xpZW50IGFzIGFuIGFzc2lzdGFudCBtZXNzYWdlLlxuICAgKiAgICAgcmV0dXJuIGF3YWl0IG9wZW5haS5jaGF0LmNvbXBsZXRpb25zLmNyZWF0ZSh7XG4gICAqICAgICAgIG1vZGVsOiAnZ3B0LTMuNS10dXJiby0wNjEzJyxcbiAgICogICAgICAgc3RyZWFtOiB0cnVlLFxuICAgKiAgICAgICAvLyBBcHBlbmQgdGhlIHJlbGV2YW50IFwiYXNzaXN0YW50XCIgYW5kIFwiZnVuY3Rpb25cIiBjYWxsIG1lc3NhZ2VzXG4gICAqICAgICAgIG1lc3NhZ2VzOiBbLi4ubWVzc2FnZXMsIC4uLmNyZWF0ZUZ1bmN0aW9uQ2FsbE1lc3NhZ2VzKHJlc3VsdCldLFxuICAgKiAgICAgICBmdW5jdGlvbnMsXG4gICAqICAgICB9KVxuICAgKiAgIH1cbiAgICogfSlcbiAgICogYGBgXG4gICAqL1xuICBleHBlcmltZW50YWxfb25GdW5jdGlvbkNhbGw/OiAoXG4gICAgZnVuY3Rpb25DYWxsUGF5bG9hZDogRnVuY3Rpb25DYWxsUGF5bG9hZCxcbiAgICBjcmVhdGVGdW5jdGlvbkNhbGxNZXNzYWdlczogKFxuICAgICAgZnVuY3Rpb25DYWxsUmVzdWx0OiBKU09OVmFsdWUsXG4gICAgKSA9PiBDcmVhdGVNZXNzYWdlW10sXG4gICkgPT4gUHJvbWlzZTxcbiAgICBSZXNwb25zZSB8IHVuZGVmaW5lZCB8IHZvaWQgfCBzdHJpbmcgfCBBc3luY0l0ZXJhYmxlT3BlbkFJU3RyZWFtUmV0dXJuVHlwZXNcbiAgPjtcbiAgLyoqXG4gICAqIEBleGFtcGxlXG4gICAqIGBgYGpzXG4gICAqIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgb3BlbmFpLmNoYXQuY29tcGxldGlvbnMuY3JlYXRlKHtcbiAgICogICBtb2RlbDogJ2dwdC0zLjUtdHVyYm8tMTEwNicsIC8vIG9yIGdwdC00LTExMDYtcHJldmlld1xuICAgKiAgIHN0cmVhbTogdHJ1ZSxcbiAgICogICBtZXNzYWdlcyxcbiAgICogICB0b29scyxcbiAgICogICB0b29sX2Nob2ljZTogXCJhdXRvXCIsIC8vIGF1dG8gaXMgZGVmYXVsdCwgYnV0IHdlJ2xsIGJlIGV4cGxpY2l0XG4gICAqIH0pXG4gICAqXG4gICAqIGNvbnN0IHN0cmVhbSA9IE9wZW5BSVN0cmVhbShyZXNwb25zZSwge1xuICAgKiAgIGV4cGVyaW1lbnRhbF9vblRvb2xDYWxsOiBhc3luYyAodG9vbENhbGxQYXlsb2FkLCBhcHBlbmRUb29sQ2FsbE1lc3NhZ2VzKSA9PiB7XG4gICAqICAgIGxldCBtZXNzYWdlczogQ3JlYXRlTWVzc2FnZVtdID0gW11cbiAgICogICAgLy8gICBUaGVyZSBtaWdodCBiZSBtdWx0aXBsZSB0b29sIGNhbGxzLCBzbyB3ZSBuZWVkIHRvIGl0ZXJhdGUgdGhyb3VnaCB0aGVtXG4gICAqICAgIGZvciAoY29uc3QgdG9vbCBvZiB0b29sQ2FsbFBheWxvYWQudG9vbHMpIHtcbiAgICogICAgIC8vIC4uLiBydW4geW91ciBjdXN0b20gbG9naWMgaGVyZVxuICAgKiAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgbXlGdW5jdGlvbih0b29sLmZ1bmN0aW9uKVxuICAgKiAgICAvLyBBcHBlbmQgdGhlIHJlbGV2YW50IFwiYXNzaXN0YW50XCIgYW5kIFwidG9vbFwiIGNhbGwgbWVzc2FnZXNcbiAgICogICAgIGFwcGVuZFRvb2xDYWxsTWVzc2FnZSh7dG9vbF9jYWxsX2lkOnRvb2wuaWQsIGZ1bmN0aW9uX25hbWU6dG9vbC5mdW5jdGlvbi5uYW1lLCB0b29sX2NhbGxfcmVzdWx0OnJlc3VsdH0pXG4gICAqICAgIH1cbiAgICogICAgIC8vIEFzayBmb3IgYW5vdGhlciBjb21wbGV0aW9uLCBvciByZXR1cm4gYSBzdHJpbmcgdG8gc2VuZCB0byB0aGUgY2xpZW50IGFzIGFuIGFzc2lzdGFudCBtZXNzYWdlLlxuICAgKiAgICAgcmV0dXJuIGF3YWl0IG9wZW5haS5jaGF0LmNvbXBsZXRpb25zLmNyZWF0ZSh7XG4gICAqICAgICAgIG1vZGVsOiAnZ3B0LTMuNS10dXJiby0xMTA2JywgLy8gb3IgZ3B0LTQtMTEwNi1wcmV2aWV3XG4gICAqICAgICAgIHN0cmVhbTogdHJ1ZSxcbiAgICogICAgICAgLy8gQXBwZW5kIHRoZSByZXN1bHRzIG1lc3NhZ2VzLCBjYWxsaW5nIGFwcGVuZFRvb2xDYWxsTWVzc2FnZSB3aXRob3V0XG4gICAqICAgICAgIC8vIGFueSBhcmd1bWVudHMgd2lsbCBqc3V0IHJldHVybiB0aGUgYWNjdW11bGF0ZWQgbWVzc2FnZXNcbiAgICogICAgICAgbWVzc2FnZXM6IFsuLi5tZXNzYWdlcywgLi4uYXBwZW5kVG9vbENhbGxNZXNzYWdlKCldLFxuICAgKiAgICAgICB0b29scyxcbiAgICogICAgICAgIHRvb2xfY2hvaWNlOiBcImF1dG9cIiwgLy8gYXV0byBpcyBkZWZhdWx0LCBidXQgd2UnbGwgYmUgZXhwbGljaXRcbiAgICogICAgIH0pXG4gICAqICAgfVxuICAgKiB9KVxuICAgKiBgYGBcbiAgICovXG4gIGV4cGVyaW1lbnRhbF9vblRvb2xDYWxsPzogKFxuICAgIHRvb2xDYWxsUGF5bG9hZDogVG9vbENhbGxQYXlsb2FkLFxuICAgIGFwcGVuZFRvb2xDYWxsTWVzc2FnZTogKHJlc3VsdD86IHtcbiAgICAgIHRvb2xfY2FsbF9pZDogc3RyaW5nO1xuICAgICAgZnVuY3Rpb25fbmFtZTogc3RyaW5nO1xuICAgICAgdG9vbF9jYWxsX3Jlc3VsdDogSlNPTlZhbHVlO1xuICAgIH0pID0+IENyZWF0ZU1lc3NhZ2VbXSxcbiAgKSA9PiBQcm9taXNlPFxuICAgIFJlc3BvbnNlIHwgdW5kZWZpbmVkIHwgdm9pZCB8IHN0cmluZyB8IEFzeW5jSXRlcmFibGVPcGVuQUlTdHJlYW1SZXR1cm5UeXBlc1xuICA+O1xufTtcblxuLy8gaHR0cHM6Ly9naXRodWIuY29tL29wZW5haS9vcGVuYWktbm9kZS9ibG9iLzA3YjM1MDRlMWM0MGZkOTI5ZjRhYWUxNjUxYjgzYWZjMTllM2JhZjgvc3JjL3Jlc291cmNlcy9jaGF0L2NvbXBsZXRpb25zLnRzI0wyOC1MNDBcbmludGVyZmFjZSBDaGF0Q29tcGxldGlvbkNodW5rIHtcbiAgaWQ6IHN0cmluZztcbiAgY2hvaWNlczogQXJyYXk8Q2hhdENvbXBsZXRpb25DaHVua0Nob2ljZT47XG4gIGNyZWF0ZWQ6IG51bWJlcjtcbiAgbW9kZWw6IHN0cmluZztcbiAgb2JqZWN0OiBzdHJpbmc7XG59XG5cbi8vIGh0dHBzOi8vZ2l0aHViLmNvbS9vcGVuYWkvb3BlbmFpLW5vZGUvYmxvYi8wN2IzNTA0ZTFjNDBmZDkyOWY0YWFlMTY1MWI4M2FmYzE5ZTNiYWY4L3NyYy9yZXNvdXJjZXMvY2hhdC9jb21wbGV0aW9ucy50cyNMNDMtTDQ5XG4vLyBVcGRhdGVkIGZvciBodHRwczovL2dpdGh1Yi5jb20vb3BlbmFpL29wZW5haS1ub2RlL2NvbW1pdC9mMTBjNzU3ZDgzMWQ5MDQwN2JhNDdiNDY1OWQ5Y2QzNGIxYTM1YjFkXG4vLyBVcGRhdGVkIHRvIGh0dHBzOi8vZ2l0aHViLmNvbS9vcGVuYWkvb3BlbmFpLW5vZGUvY29tbWl0Lzg0YjQzMjgwMDg5ZWFjZGYxOGYxNzE3MjM1OTE4NTY4MTFiZWRkY2VcbmludGVyZmFjZSBDaGF0Q29tcGxldGlvbkNodW5rQ2hvaWNlIHtcbiAgZGVsdGE6IENob2ljZURlbHRhO1xuICBmaW5pc2hfcmVhc29uOlxuICAgIHwgJ3N0b3AnXG4gICAgfCAnbGVuZ3RoJ1xuICAgIHwgJ3Rvb2xfY2FsbHMnXG4gICAgfCAnY29udGVudF9maWx0ZXInXG4gICAgfCAnZnVuY3Rpb25fY2FsbCdcbiAgICB8IG51bGw7XG4gIGluZGV4OiBudW1iZXI7XG59XG5cbi8vIGh0dHBzOi8vZ2l0aHViLmNvbS9vcGVuYWkvb3BlbmFpLW5vZGUvYmxvYi8wN2IzNTA0ZTFjNDBmZDkyOWY0YWFlMTY1MWI4M2FmYzE5ZTNiYWY4L3NyYy9yZXNvdXJjZXMvY2hhdC9jb21wbGV0aW9ucy50cyNMMTIzLUwxMzlcbi8vIFVwZGF0ZWQgdG8gaHR0cHM6Ly9naXRodWIuY29tL29wZW5haS9vcGVuYWktbm9kZS9jb21taXQvODRiNDMyODAwODllYWNkZjE4ZjE3MTcyMzU5MTg1NjgxMWJlZGRjZVxuaW50ZXJmYWNlIENob2ljZURlbHRhIHtcbiAgLyoqXG4gICAqIFRoZSBjb250ZW50cyBvZiB0aGUgY2h1bmsgbWVzc2FnZS5cbiAgICovXG4gIGNvbnRlbnQ/OiBzdHJpbmcgfCBudWxsO1xuXG4gIC8qKlxuICAgKiBUaGUgbmFtZSBhbmQgYXJndW1lbnRzIG9mIGEgZnVuY3Rpb24gdGhhdCBzaG91bGQgYmUgY2FsbGVkLCBhcyBnZW5lcmF0ZWQgYnkgdGhlXG4gICAqIG1vZGVsLlxuICAgKi9cbiAgZnVuY3Rpb25fY2FsbD86IEZ1bmN0aW9uQ2FsbDtcblxuICAvKipcbiAgICogVGhlIHJvbGUgb2YgdGhlIGF1dGhvciBvZiB0aGlzIG1lc3NhZ2UuXG4gICAqL1xuICByb2xlPzogJ3N5c3RlbScgfCAndXNlcicgfCAnYXNzaXN0YW50JyB8ICd0b29sJztcblxuICB0b29sX2NhbGxzPzogQXJyYXk8RGVsdGFUb29sQ2FsbD47XG59XG5cbi8vIEZyb20gaHR0cHM6Ly9naXRodWIuY29tL29wZW5haS9vcGVuYWktbm9kZS9ibG9iL21hc3Rlci9zcmMvcmVzb3VyY2VzL2NoYXQvY29tcGxldGlvbnMudHNcbi8vIFVwZGF0ZWQgdG8gaHR0cHM6Ly9naXRodWIuY29tL29wZW5haS9vcGVuYWktbm9kZS9jb21taXQvODRiNDMyODAwODllYWNkZjE4ZjE3MTcyMzU5MTg1NjgxMWJlZGRjZVxuaW50ZXJmYWNlIERlbHRhVG9vbENhbGwge1xuICBpbmRleDogbnVtYmVyO1xuXG4gIC8qKlxuICAgKiBUaGUgSUQgb2YgdGhlIHRvb2wgY2FsbC5cbiAgICovXG4gIGlkPzogc3RyaW5nO1xuXG4gIC8qKlxuICAgKiBUaGUgZnVuY3Rpb24gdGhhdCB0aGUgbW9kZWwgY2FsbGVkLlxuICAgKi9cbiAgZnVuY3Rpb24/OiBUb29sQ2FsbEZ1bmN0aW9uO1xuXG4gIC8qKlxuICAgKiBUaGUgdHlwZSBvZiB0aGUgdG9vbC4gQ3VycmVudGx5LCBvbmx5IGBmdW5jdGlvbmAgaXMgc3VwcG9ydGVkLlxuICAgKi9cbiAgdHlwZT86ICdmdW5jdGlvbic7XG59XG5cbi8vIEZyb20gaHR0cHM6Ly9naXRodWIuY29tL29wZW5haS9vcGVuYWktbm9kZS9ibG9iL21hc3Rlci9zcmMvcmVzb3VyY2VzL2NoYXQvY29tcGxldGlvbnMudHNcbi8vIFVwZGF0ZWQgdG8gaHR0cHM6Ly9naXRodWIuY29tL29wZW5haS9vcGVuYWktbm9kZS9jb21taXQvODRiNDMyODAwODllYWNkZjE4ZjE3MTcyMzU5MTg1NjgxMWJlZGRjZVxuaW50ZXJmYWNlIFRvb2xDYWxsRnVuY3Rpb24ge1xuICAvKipcbiAgICogVGhlIGFyZ3VtZW50cyB0byBjYWxsIHRoZSBmdW5jdGlvbiB3aXRoLCBhcyBnZW5lcmF0ZWQgYnkgdGhlIG1vZGVsIGluIEpTT05cbiAgICogZm9ybWF0LiBOb3RlIHRoYXQgdGhlIG1vZGVsIGRvZXMgbm90IGFsd2F5cyBnZW5lcmF0ZSB2YWxpZCBKU09OLCBhbmQgbWF5XG4gICAqIGhhbGx1Y2luYXRlIHBhcmFtZXRlcnMgbm90IGRlZmluZWQgYnkgeW91ciBmdW5jdGlvbiBzY2hlbWEuIFZhbGlkYXRlIHRoZVxuICAgKiBhcmd1bWVudHMgaW4geW91ciBjb2RlIGJlZm9yZSBjYWxsaW5nIHlvdXIgZnVuY3Rpb24uXG4gICAqL1xuICBhcmd1bWVudHM/OiBzdHJpbmc7XG5cbiAgLyoqXG4gICAqIFRoZSBuYW1lIG9mIHRoZSBmdW5jdGlvbiB0byBjYWxsLlxuICAgKi9cbiAgbmFtZT86IHN0cmluZztcbn1cblxuLyoqXG4gKiBodHRwczovL2dpdGh1Yi5jb20vb3BlbmFpL29wZW5haS1ub2RlL2Jsb2IvM2VjNDNlZTc5MGEyZWI2YTBjY2RkNWYyNWZhYTIzMjUxYjBmOWI4ZS9zcmMvcmVzb3VyY2VzL2NvbXBsZXRpb25zLnRzI0wyOEMxLUw2NEMxXG4gKiBDb21wbGV0aW9ucyBBUEkuIFN0cmVhbWVkIGFuZCBub24tc3RyZWFtZWQgcmVzcG9uc2VzIGFyZSB0aGUgc2FtZS5cbiAqL1xuaW50ZXJmYWNlIENvbXBsZXRpb24ge1xuICAvKipcbiAgICogQSB1bmlxdWUgaWRlbnRpZmllciBmb3IgdGhlIGNvbXBsZXRpb24uXG4gICAqL1xuICBpZDogc3RyaW5nO1xuXG4gIC8qKlxuICAgKiBUaGUgbGlzdCBvZiBjb21wbGV0aW9uIGNob2ljZXMgdGhlIG1vZGVsIGdlbmVyYXRlZCBmb3IgdGhlIGlucHV0IHByb21wdC5cbiAgICovXG4gIGNob2ljZXM6IEFycmF5PENvbXBsZXRpb25DaG9pY2U+O1xuXG4gIC8qKlxuICAgKiBUaGUgVW5peCB0aW1lc3RhbXAgb2Ygd2hlbiB0aGUgY29tcGxldGlvbiB3YXMgY3JlYXRlZC5cbiAgICovXG4gIGNyZWF0ZWQ6IG51bWJlcjtcblxuICAvKipcbiAgICogVGhlIG1vZGVsIHVzZWQgZm9yIGNvbXBsZXRpb24uXG4gICAqL1xuICBtb2RlbDogc3RyaW5nO1xuXG4gIC8qKlxuICAgKiBUaGUgb2JqZWN0IHR5cGUsIHdoaWNoIGlzIGFsd2F5cyBcInRleHRfY29tcGxldGlvblwiXG4gICAqL1xuICBvYmplY3Q6IHN0cmluZztcblxuICAvKipcbiAgICogVXNhZ2Ugc3RhdGlzdGljcyBmb3IgdGhlIGNvbXBsZXRpb24gcmVxdWVzdC5cbiAgICovXG4gIHVzYWdlPzogQ29tcGxldGlvblVzYWdlO1xufVxuXG5pbnRlcmZhY2UgQ29tcGxldGlvbkNob2ljZSB7XG4gIC8qKlxuICAgKiBUaGUgcmVhc29uIHRoZSBtb2RlbCBzdG9wcGVkIGdlbmVyYXRpbmcgdG9rZW5zLiBUaGlzIHdpbGwgYmUgYHN0b3BgIGlmIHRoZSBtb2RlbFxuICAgKiBoaXQgYSBuYXR1cmFsIHN0b3AgcG9pbnQgb3IgYSBwcm92aWRlZCBzdG9wIHNlcXVlbmNlLCBvciBgbGVuZ3RoYCBpZiB0aGUgbWF4aW11bVxuICAgKiBudW1iZXIgb2YgdG9rZW5zIHNwZWNpZmllZCBpbiB0aGUgcmVxdWVzdCB3YXMgcmVhY2hlZC5cbiAgICovXG4gIGZpbmlzaF9yZWFzb246ICdzdG9wJyB8ICdsZW5ndGgnIHwgJ2NvbnRlbnRfZmlsdGVyJztcblxuICBpbmRleDogbnVtYmVyO1xuXG4gIC8vIGVkaXRlZDogUmVtb3ZlZCBDb21wbGV0aW9uQ2hvaWNlLmxvZ1Byb2JzIGFuZCByZXBsYWNlZCB3aXRoIGFueVxuICBsb2dwcm9iczogYW55IHwgbnVsbDtcblxuICB0ZXh0OiBzdHJpbmc7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgQ29tcGxldGlvblVzYWdlIHtcbiAgLyoqXG4gICAqIFVzYWdlIHN0YXRpc3RpY3MgZm9yIHRoZSBjb21wbGV0aW9uIHJlcXVlc3QuXG4gICAqL1xuXG4gIC8qKlxuICAgKiBOdW1iZXIgb2YgdG9rZW5zIGluIHRoZSBnZW5lcmF0ZWQgY29tcGxldGlvbi5cbiAgICovXG4gIGNvbXBsZXRpb25fdG9rZW5zOiBudW1iZXI7XG5cbiAgLyoqXG4gICAqIE51bWJlciBvZiB0b2tlbnMgaW4gdGhlIHByb21wdC5cbiAgICovXG4gIHByb21wdF90b2tlbnM6IG51bWJlcjtcblxuICAvKipcbiAgICogVG90YWwgbnVtYmVyIG9mIHRva2VucyB1c2VkIGluIHRoZSByZXF1ZXN0IChwcm9tcHQgKyBjb21wbGV0aW9uKS5cbiAgICovXG4gIHRvdGFsX3Rva2VuczogbnVtYmVyO1xufVxuXG4vKipcbiAqIENyZWF0ZXMgYSBwYXJzZXIgZnVuY3Rpb24gZm9yIHByb2Nlc3NpbmcgdGhlIE9wZW5BSSBzdHJlYW0gZGF0YS5cbiAqIFRoZSBwYXJzZXIgZXh0cmFjdHMgYW5kIHRyaW1zIHRleHQgY29udGVudCBmcm9tIHRoZSBKU09OIGRhdGEuIFRoaXMgcGFyc2VyXG4gKiBjYW4gaGFuZGxlIGRhdGEgZm9yIGNoYXQgb3IgY29tcGxldGlvbiBtb2RlbHMuXG4gKlxuICogQHJldHVybiB7KGRhdGE6IHN0cmluZykgPT4gc3RyaW5nIHwgdm9pZHwgeyBpc1RleHQ6IGZhbHNlOyBjb250ZW50OiBzdHJpbmcgfX1cbiAqIEEgcGFyc2VyIGZ1bmN0aW9uIHRoYXQgdGFrZXMgYSBKU09OIHN0cmluZyBhcyBpbnB1dCBhbmQgcmV0dXJucyB0aGUgZXh0cmFjdGVkIHRleHQgY29udGVudCxcbiAqIGEgY29tcGxleCBvYmplY3Qgd2l0aCBpc1RleHQ6IGZhbHNlIGZvciBmdW5jdGlvbi90b29sIGNhbGxzLCBvciBub3RoaW5nLlxuICovXG5mdW5jdGlvbiBwYXJzZU9wZW5BSVN0cmVhbSgpOiAoXG4gIGRhdGE6IHN0cmluZyxcbikgPT4gc3RyaW5nIHwgdm9pZCB8IHsgaXNUZXh0OiBmYWxzZTsgY29udGVudDogc3RyaW5nIH0ge1xuICBjb25zdCBleHRyYWN0ID0gY2h1bmtUb1RleHQoKTtcbiAgcmV0dXJuIGRhdGEgPT4gZXh0cmFjdChKU09OLnBhcnNlKGRhdGEpIGFzIE9wZW5BSVN0cmVhbVJldHVyblR5cGVzKTtcbn1cblxuLyoqXG4gKiBSZWFkcyBjaHVua3MgZnJvbSBPcGVuQUkncyBuZXcgU3RyZWFtYWJsZSBpbnRlcmZhY2UsIHdoaWNoIGlzIGVzc2VudGlhbGx5XG4gKiB0aGUgc2FtZSBhcyB0aGUgb2xkIFJlc3BvbnNlIGJvZHkgaW50ZXJmYWNlIHdpdGggYW4gaW5jbHVkZWQgU1NFIHBhcnNlclxuICogZG9pbmcgdGhlIHBhcnNpbmcgZm9yIHVzLlxuICovXG5hc3luYyBmdW5jdGlvbiogc3RyZWFtYWJsZShzdHJlYW06IEFzeW5jSXRlcmFibGVPcGVuQUlTdHJlYW1SZXR1cm5UeXBlcykge1xuICBjb25zdCBleHRyYWN0ID0gY2h1bmtUb1RleHQoKTtcblxuICBmb3IgYXdhaXQgKGxldCBjaHVuayBvZiBzdHJlYW0pIHtcbiAgICAvLyBjb252ZXJ0IGNodW5rIGlmIGl0IGlzIGFuIEF6dXJlIGNoYXQgY29tcGxldGlvbi4gQXp1cmUgZG9lcyBub3QgZXhwb3NlIGFsbFxuICAgIC8vIHByb3BlcnRpZXMgaW4gdGhlIGludGVyZmFjZXMsIGFuZCBhbHNvIHVzZXMgY2FtZWxDYXNlIGluc3RlYWQgb2Ygc25ha2VfY2FzZVxuICAgIGlmICgncHJvbXB0RmlsdGVyUmVzdWx0cycgaW4gY2h1bmspIHtcbiAgICAgIGNodW5rID0ge1xuICAgICAgICBpZDogY2h1bmsuaWQsXG4gICAgICAgIGNyZWF0ZWQ6IGNodW5rLmNyZWF0ZWQuZ2V0RGF0ZSgpLFxuICAgICAgICBvYmplY3Q6IChjaHVuayBhcyBhbnkpLm9iamVjdCwgLy8gbm90IGV4cG9zZWQgYnkgQXp1cmUgQVBJXG4gICAgICAgIG1vZGVsOiAoY2h1bmsgYXMgYW55KS5tb2RlbCwgLy8gbm90IGV4cG9zZWQgYnkgQXp1cmUgQVBJXG4gICAgICAgIGNob2ljZXM6IGNodW5rLmNob2ljZXMubWFwKGNob2ljZSA9PiAoe1xuICAgICAgICAgIGRlbHRhOiB7XG4gICAgICAgICAgICBjb250ZW50OiBjaG9pY2UuZGVsdGE/LmNvbnRlbnQsXG4gICAgICAgICAgICBmdW5jdGlvbl9jYWxsOiBjaG9pY2UuZGVsdGE/LmZ1bmN0aW9uQ2FsbCxcbiAgICAgICAgICAgIHJvbGU6IGNob2ljZS5kZWx0YT8ucm9sZSBhcyBhbnksXG4gICAgICAgICAgICB0b29sX2NhbGxzOiBjaG9pY2UuZGVsdGE/LnRvb2xDYWxscz8ubGVuZ3RoXG4gICAgICAgICAgICAgID8gY2hvaWNlLmRlbHRhPy50b29sQ2FsbHM/Lm1hcCgodG9vbENhbGwsIGluZGV4KSA9PiAoe1xuICAgICAgICAgICAgICAgICAgaW5kZXgsXG4gICAgICAgICAgICAgICAgICBpZDogdG9vbENhbGwuaWQsXG4gICAgICAgICAgICAgICAgICBmdW5jdGlvbjogdG9vbENhbGwuZnVuY3Rpb24sXG4gICAgICAgICAgICAgICAgICB0eXBlOiB0b29sQ2FsbC50eXBlLFxuICAgICAgICAgICAgICAgIH0pKVxuICAgICAgICAgICAgICA6IHVuZGVmaW5lZCxcbiAgICAgICAgICB9LFxuICAgICAgICAgIGZpbmlzaF9yZWFzb246IGNob2ljZS5maW5pc2hSZWFzb24gYXMgYW55LFxuICAgICAgICAgIGluZGV4OiBjaG9pY2UuaW5kZXgsXG4gICAgICAgIH0pKSxcbiAgICAgIH0gc2F0aXNmaWVzIENoYXRDb21wbGV0aW9uQ2h1bms7XG4gICAgfVxuXG4gICAgY29uc3QgdGV4dCA9IGV4dHJhY3QoY2h1bmspO1xuXG4gICAgaWYgKHRleHQpIHlpZWxkIHRleHQ7XG4gIH1cbn1cblxuZnVuY3Rpb24gY2h1bmtUb1RleHQoKTogKFxuICBjaHVuazogT3BlbkFJU3RyZWFtUmV0dXJuVHlwZXMsXG4pID0+IHN0cmluZyB8IHsgaXNUZXh0OiBmYWxzZTsgY29udGVudDogc3RyaW5nIH0gfCB2b2lkIHtcbiAgY29uc3QgdHJpbVN0YXJ0T2ZTdHJlYW0gPSB0cmltU3RhcnRPZlN0cmVhbUhlbHBlcigpO1xuICBsZXQgaXNGdW5jdGlvblN0cmVhbWluZ0luOiBib29sZWFuO1xuICByZXR1cm4ganNvbiA9PiB7XG4gICAgaWYgKGlzQ2hhdENvbXBsZXRpb25DaHVuayhqc29uKSkge1xuICAgICAgY29uc3QgZGVsdGEgPSBqc29uLmNob2ljZXNbMF0/LmRlbHRhO1xuICAgICAgaWYgKGRlbHRhLmZ1bmN0aW9uX2NhbGw/Lm5hbWUpIHtcbiAgICAgICAgaXNGdW5jdGlvblN0cmVhbWluZ0luID0gdHJ1ZTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBpc1RleHQ6IGZhbHNlLFxuICAgICAgICAgIGNvbnRlbnQ6IGB7XCJmdW5jdGlvbl9jYWxsXCI6IHtcIm5hbWVcIjogXCIke2RlbHRhLmZ1bmN0aW9uX2NhbGwubmFtZX1cIiwgXCJhcmd1bWVudHNcIjogXCJgLFxuICAgICAgICB9O1xuICAgICAgfSBlbHNlIGlmIChkZWx0YS50b29sX2NhbGxzPy5bMF0/LmZ1bmN0aW9uPy5uYW1lKSB7XG4gICAgICAgIGlzRnVuY3Rpb25TdHJlYW1pbmdJbiA9IHRydWU7XG4gICAgICAgIGNvbnN0IHRvb2xDYWxsID0gZGVsdGEudG9vbF9jYWxsc1swXTtcbiAgICAgICAgaWYgKHRvb2xDYWxsLmluZGV4ID09PSAwKSB7XG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGlzVGV4dDogZmFsc2UsXG4gICAgICAgICAgICBjb250ZW50OiBge1widG9vbF9jYWxsc1wiOlsge1wiaWRcIjogXCIke3Rvb2xDYWxsLmlkfVwiLCBcInR5cGVcIjogXCJmdW5jdGlvblwiLCBcImZ1bmN0aW9uXCI6IHtcIm5hbWVcIjogXCIke3Rvb2xDYWxsLmZ1bmN0aW9uPy5uYW1lfVwiLCBcImFyZ3VtZW50c1wiOiBcImAsXG4gICAgICAgICAgfTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgaXNUZXh0OiBmYWxzZSxcbiAgICAgICAgICAgIGNvbnRlbnQ6IGBcIn19LCB7XCJpZFwiOiBcIiR7dG9vbENhbGwuaWR9XCIsIFwidHlwZVwiOiBcImZ1bmN0aW9uXCIsIFwiZnVuY3Rpb25cIjoge1wibmFtZVwiOiBcIiR7dG9vbENhbGwuZnVuY3Rpb24/Lm5hbWV9XCIsIFwiYXJndW1lbnRzXCI6IFwiYCxcbiAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKGRlbHRhLmZ1bmN0aW9uX2NhbGw/LmFyZ3VtZW50cykge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIGlzVGV4dDogZmFsc2UsXG4gICAgICAgICAgY29udGVudDogY2xlYW51cEFyZ3VtZW50cyhkZWx0YS5mdW5jdGlvbl9jYWxsPy5hcmd1bWVudHMpLFxuICAgICAgICB9O1xuICAgICAgfSBlbHNlIGlmIChkZWx0YS50b29sX2NhbGxzPy5bMF0/LmZ1bmN0aW9uPy5hcmd1bWVudHMpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBpc1RleHQ6IGZhbHNlLFxuICAgICAgICAgIGNvbnRlbnQ6IGNsZWFudXBBcmd1bWVudHMoZGVsdGEudG9vbF9jYWxscz8uWzBdPy5mdW5jdGlvbj8uYXJndW1lbnRzKSxcbiAgICAgICAgfTtcbiAgICAgIH0gZWxzZSBpZiAoXG4gICAgICAgIGlzRnVuY3Rpb25TdHJlYW1pbmdJbiAmJlxuICAgICAgICAoanNvbi5jaG9pY2VzWzBdPy5maW5pc2hfcmVhc29uID09PSAnZnVuY3Rpb25fY2FsbCcgfHxcbiAgICAgICAgICBqc29uLmNob2ljZXNbMF0/LmZpbmlzaF9yZWFzb24gPT09ICdzdG9wJylcbiAgICAgICkge1xuICAgICAgICBpc0Z1bmN0aW9uU3RyZWFtaW5nSW4gPSBmYWxzZTsgLy8gUmVzZXQgdGhlIGZsYWdcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBpc1RleHQ6IGZhbHNlLFxuICAgICAgICAgIGNvbnRlbnQ6ICdcIn19JyxcbiAgICAgICAgfTtcbiAgICAgIH0gZWxzZSBpZiAoXG4gICAgICAgIGlzRnVuY3Rpb25TdHJlYW1pbmdJbiAmJlxuICAgICAgICBqc29uLmNob2ljZXNbMF0/LmZpbmlzaF9yZWFzb24gPT09ICd0b29sX2NhbGxzJ1xuICAgICAgKSB7XG4gICAgICAgIGlzRnVuY3Rpb25TdHJlYW1pbmdJbiA9IGZhbHNlOyAvLyBSZXNldCB0aGUgZmxhZ1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIGlzVGV4dDogZmFsc2UsXG4gICAgICAgICAgY29udGVudDogJ1wifX1dfScsXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgfVxuXG4gICAgY29uc3QgdGV4dCA9IHRyaW1TdGFydE9mU3RyZWFtKFxuICAgICAgaXNDaGF0Q29tcGxldGlvbkNodW5rKGpzb24pICYmIGpzb24uY2hvaWNlc1swXS5kZWx0YS5jb250ZW50XG4gICAgICAgID8ganNvbi5jaG9pY2VzWzBdLmRlbHRhLmNvbnRlbnRcbiAgICAgICAgOiBpc0NvbXBsZXRpb24oanNvbilcbiAgICAgICAgPyBqc29uLmNob2ljZXNbMF0udGV4dFxuICAgICAgICA6ICcnLFxuICAgICk7XG5cbiAgICByZXR1cm4gdGV4dDtcbiAgfTtcblxuICBmdW5jdGlvbiBjbGVhbnVwQXJndW1lbnRzKGFyZ3VtZW50Q2h1bms6IHN0cmluZykge1xuICAgIGxldCBlc2NhcGVkUGFydGlhbEpzb24gPSBhcmd1bWVudENodW5rXG4gICAgICAucmVwbGFjZSgvXFxcXC9nLCAnXFxcXFxcXFwnKSAvLyBSZXBsYWNlIGJhY2tzbGFzaGVzIGZpcnN0IHRvIHByZXZlbnQgZG91YmxlIGVzY2FwaW5nXG4gICAgICAucmVwbGFjZSgvXFwvL2csICdcXFxcLycpIC8vIEVzY2FwZSBzbGFzaGVzXG4gICAgICAucmVwbGFjZSgvXCIvZywgJ1xcXFxcIicpIC8vIEVzY2FwZSBkb3VibGUgcXVvdGVzXG4gICAgICAucmVwbGFjZSgvXFxuL2csICdcXFxcbicpIC8vIEVzY2FwZSBuZXcgbGluZXNcbiAgICAgIC5yZXBsYWNlKC9cXHIvZywgJ1xcXFxyJykgLy8gRXNjYXBlIGNhcnJpYWdlIHJldHVybnNcbiAgICAgIC5yZXBsYWNlKC9cXHQvZywgJ1xcXFx0JykgLy8gRXNjYXBlIHRhYnNcbiAgICAgIC5yZXBsYWNlKC9cXGYvZywgJ1xcXFxmJyk7IC8vIEVzY2FwZSBmb3JtIGZlZWRzXG5cbiAgICByZXR1cm4gYCR7ZXNjYXBlZFBhcnRpYWxKc29ufWA7XG4gIH1cbn1cblxuY29uc3QgX19pbnRlcm5hbF9fT3BlbkFJRm5NZXNzYWdlc1N5bWJvbCA9IFN5bWJvbChcbiAgJ2ludGVybmFsX29wZW5haV9mbl9tZXNzYWdlcycsXG4pO1xuXG50eXBlIEFzeW5jSXRlcmFibGVPcGVuQUlTdHJlYW1SZXR1cm5UeXBlcyA9XG4gIHwgQXN5bmNJdGVyYWJsZTxDaGF0Q29tcGxldGlvbkNodW5rPlxuICB8IEFzeW5jSXRlcmFibGU8Q29tcGxldGlvbj5cbiAgfCBBc3luY0l0ZXJhYmxlPEF6dXJlQ2hhdENvbXBsZXRpb25zPjtcblxudHlwZSBFeHRyYWN0VHlwZTxUPiA9IFQgZXh0ZW5kcyBBc3luY0l0ZXJhYmxlPGluZmVyIFU+ID8gVSA6IG5ldmVyO1xuXG50eXBlIE9wZW5BSVN0cmVhbVJldHVyblR5cGVzID1cbiAgRXh0cmFjdFR5cGU8QXN5bmNJdGVyYWJsZU9wZW5BSVN0cmVhbVJldHVyblR5cGVzPjtcblxuZnVuY3Rpb24gaXNDaGF0Q29tcGxldGlvbkNodW5rKFxuICBkYXRhOiBPcGVuQUlTdHJlYW1SZXR1cm5UeXBlcyxcbik6IGRhdGEgaXMgQ2hhdENvbXBsZXRpb25DaHVuayB7XG4gIHJldHVybiAoXG4gICAgJ2Nob2ljZXMnIGluIGRhdGEgJiZcbiAgICBkYXRhLmNob2ljZXMgJiZcbiAgICBkYXRhLmNob2ljZXNbMF0gJiZcbiAgICAnZGVsdGEnIGluIGRhdGEuY2hvaWNlc1swXVxuICApO1xufVxuXG5mdW5jdGlvbiBpc0NvbXBsZXRpb24oZGF0YTogT3BlbkFJU3RyZWFtUmV0dXJuVHlwZXMpOiBkYXRhIGlzIENvbXBsZXRpb24ge1xuICByZXR1cm4gKFxuICAgICdjaG9pY2VzJyBpbiBkYXRhICYmXG4gICAgZGF0YS5jaG9pY2VzICYmXG4gICAgZGF0YS5jaG9pY2VzWzBdICYmXG4gICAgJ3RleHQnIGluIGRhdGEuY2hvaWNlc1swXVxuICApO1xufVxuXG4vKipcbiAqIEBkZXByZWNhdGVkIFVzZSB0aGUgW09wZW5BSSBwcm92aWRlcl0oaHR0cHM6Ly9zZGsudmVyY2VsLmFpL3Byb3ZpZGVycy9haS1zZGstcHJvdmlkZXJzL29wZW5haSkgaW5zdGVhZC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIE9wZW5BSVN0cmVhbShcbiAgcmVzOiBSZXNwb25zZSB8IEFzeW5jSXRlcmFibGVPcGVuQUlTdHJlYW1SZXR1cm5UeXBlcyxcbiAgY2FsbGJhY2tzPzogT3BlbkFJU3RyZWFtQ2FsbGJhY2tzLFxuKTogUmVhZGFibGVTdHJlYW0ge1xuICAvLyBBbm5vdGF0ZSB0aGUgaW50ZXJuYWwgYG1lc3NhZ2VzYCBwcm9wZXJ0eSBmb3IgcmVjdXJzaXZlIGZ1bmN0aW9uIGNhbGxzXG4gIGNvbnN0IGNiOlxuICAgIHwgdW5kZWZpbmVkXG4gICAgfCAoT3BlbkFJU3RyZWFtQ2FsbGJhY2tzICYge1xuICAgICAgICBbX19pbnRlcm5hbF9fT3BlbkFJRm5NZXNzYWdlc1N5bWJvbF0/OiBDcmVhdGVNZXNzYWdlW107XG4gICAgICB9KSA9IGNhbGxiYWNrcztcblxuICBsZXQgc3RyZWFtOiBSZWFkYWJsZVN0cmVhbTxVaW50OEFycmF5PjtcbiAgaWYgKFN5bWJvbC5hc3luY0l0ZXJhdG9yIGluIHJlcykge1xuICAgIHN0cmVhbSA9IHJlYWRhYmxlRnJvbUFzeW5jSXRlcmFibGUoc3RyZWFtYWJsZShyZXMpKS5waXBlVGhyb3VnaChcbiAgICAgIGNyZWF0ZUNhbGxiYWNrc1RyYW5zZm9ybWVyKFxuICAgICAgICBjYj8uZXhwZXJpbWVudGFsX29uRnVuY3Rpb25DYWxsIHx8IGNiPy5leHBlcmltZW50YWxfb25Ub29sQ2FsbFxuICAgICAgICAgID8ge1xuICAgICAgICAgICAgICAuLi5jYixcbiAgICAgICAgICAgICAgb25GaW5hbDogdW5kZWZpbmVkLFxuICAgICAgICAgICAgfVxuICAgICAgICAgIDoge1xuICAgICAgICAgICAgICAuLi5jYixcbiAgICAgICAgICAgIH0sXG4gICAgICApLFxuICAgICk7XG4gIH0gZWxzZSB7XG4gICAgc3RyZWFtID0gQUlTdHJlYW0oXG4gICAgICByZXMsXG4gICAgICBwYXJzZU9wZW5BSVN0cmVhbSgpLFxuICAgICAgY2I/LmV4cGVyaW1lbnRhbF9vbkZ1bmN0aW9uQ2FsbCB8fCBjYj8uZXhwZXJpbWVudGFsX29uVG9vbENhbGxcbiAgICAgICAgPyB7XG4gICAgICAgICAgICAuLi5jYixcbiAgICAgICAgICAgIG9uRmluYWw6IHVuZGVmaW5lZCxcbiAgICAgICAgICB9XG4gICAgICAgIDoge1xuICAgICAgICAgICAgLi4uY2IsXG4gICAgICAgICAgfSxcbiAgICApO1xuICB9XG5cbiAgaWYgKGNiICYmIChjYi5leHBlcmltZW50YWxfb25GdW5jdGlvbkNhbGwgfHwgY2IuZXhwZXJpbWVudGFsX29uVG9vbENhbGwpKSB7XG4gICAgY29uc3QgZnVuY3Rpb25DYWxsVHJhbnNmb3JtZXIgPSBjcmVhdGVGdW5jdGlvbkNhbGxUcmFuc2Zvcm1lcihjYik7XG4gICAgcmV0dXJuIHN0cmVhbS5waXBlVGhyb3VnaChmdW5jdGlvbkNhbGxUcmFuc2Zvcm1lcik7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIHN0cmVhbS5waXBlVGhyb3VnaChjcmVhdGVTdHJlYW1EYXRhVHJhbnNmb3JtZXIoKSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gY3JlYXRlRnVuY3Rpb25DYWxsVHJhbnNmb3JtZXIoXG4gIGNhbGxiYWNrczogT3BlbkFJU3RyZWFtQ2FsbGJhY2tzICYge1xuICAgIFtfX2ludGVybmFsX19PcGVuQUlGbk1lc3NhZ2VzU3ltYm9sXT86IENyZWF0ZU1lc3NhZ2VbXTtcbiAgfSxcbik6IFRyYW5zZm9ybVN0cmVhbTxVaW50OEFycmF5LCBVaW50OEFycmF5PiB7XG4gIGNvbnN0IHRleHRFbmNvZGVyID0gbmV3IFRleHRFbmNvZGVyKCk7XG4gIGxldCBpc0ZpcnN0Q2h1bmsgPSB0cnVlO1xuICBsZXQgYWdncmVnYXRlZFJlc3BvbnNlID0gJyc7XG4gIGxldCBhZ2dyZWdhdGVkRmluYWxDb21wbGV0aW9uUmVzcG9uc2UgPSAnJztcbiAgbGV0IGlzRnVuY3Rpb25TdHJlYW1pbmdJbiA9IGZhbHNlO1xuXG4gIGxldCBmdW5jdGlvbkNhbGxNZXNzYWdlczogQ3JlYXRlTWVzc2FnZVtdID1cbiAgICBjYWxsYmFja3NbX19pbnRlcm5hbF9fT3BlbkFJRm5NZXNzYWdlc1N5bWJvbF0gfHwgW107XG5cbiAgY29uc3QgZGVjb2RlID0gY3JlYXRlQ2h1bmtEZWNvZGVyKCk7XG5cbiAgcmV0dXJuIG5ldyBUcmFuc2Zvcm1TdHJlYW0oe1xuICAgIGFzeW5jIHRyYW5zZm9ybShjaHVuaywgY29udHJvbGxlcik6IFByb21pc2U8dm9pZD4ge1xuICAgICAgY29uc3QgbWVzc2FnZSA9IGRlY29kZShjaHVuayk7XG4gICAgICBhZ2dyZWdhdGVkRmluYWxDb21wbGV0aW9uUmVzcG9uc2UgKz0gbWVzc2FnZTtcblxuICAgICAgY29uc3Qgc2hvdWxkSGFuZGxlQXNGdW5jdGlvbiA9XG4gICAgICAgIGlzRmlyc3RDaHVuayAmJlxuICAgICAgICAobWVzc2FnZS5zdGFydHNXaXRoKCd7XCJmdW5jdGlvbl9jYWxsXCI6JykgfHxcbiAgICAgICAgICBtZXNzYWdlLnN0YXJ0c1dpdGgoJ3tcInRvb2xfY2FsbHNcIjonKSk7XG5cbiAgICAgIGlmIChzaG91bGRIYW5kbGVBc0Z1bmN0aW9uKSB7XG4gICAgICAgIGlzRnVuY3Rpb25TdHJlYW1pbmdJbiA9IHRydWU7XG4gICAgICAgIGFnZ3JlZ2F0ZWRSZXNwb25zZSArPSBtZXNzYWdlO1xuICAgICAgICBpc0ZpcnN0Q2h1bmsgPSBmYWxzZTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICAvLyBTdHJlYW0gYXMgbm9ybWFsXG4gICAgICBpZiAoIWlzRnVuY3Rpb25TdHJlYW1pbmdJbikge1xuICAgICAgICBjb250cm9sbGVyLmVucXVldWUoXG4gICAgICAgICAgdGV4dEVuY29kZXIuZW5jb2RlKGZvcm1hdFN0cmVhbVBhcnQoJ3RleHQnLCBtZXNzYWdlKSksXG4gICAgICAgICk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGFnZ3JlZ2F0ZWRSZXNwb25zZSArPSBtZXNzYWdlO1xuICAgICAgfVxuICAgIH0sXG4gICAgYXN5bmMgZmx1c2goY29udHJvbGxlcik6IFByb21pc2U8dm9pZD4ge1xuICAgICAgdHJ5IHtcbiAgICAgICAgaWYgKFxuICAgICAgICAgICFpc0ZpcnN0Q2h1bmsgJiZcbiAgICAgICAgICBpc0Z1bmN0aW9uU3RyZWFtaW5nSW4gJiZcbiAgICAgICAgICAoY2FsbGJhY2tzLmV4cGVyaW1lbnRhbF9vbkZ1bmN0aW9uQ2FsbCB8fFxuICAgICAgICAgICAgY2FsbGJhY2tzLmV4cGVyaW1lbnRhbF9vblRvb2xDYWxsKVxuICAgICAgICApIHtcbiAgICAgICAgICBpc0Z1bmN0aW9uU3RyZWFtaW5nSW4gPSBmYWxzZTtcbiAgICAgICAgICBjb25zdCBwYXlsb2FkID0gSlNPTi5wYXJzZShhZ2dyZWdhdGVkUmVzcG9uc2UpO1xuICAgICAgICAgIC8vIEFwcGVuZCB0aGUgZnVuY3Rpb24gY2FsbCBtZXNzYWdlIHRvIHRoZSBsaXN0XG4gICAgICAgICAgbGV0IG5ld0Z1bmN0aW9uQ2FsbE1lc3NhZ2VzOiBDcmVhdGVNZXNzYWdlW10gPSBbXG4gICAgICAgICAgICAuLi5mdW5jdGlvbkNhbGxNZXNzYWdlcyxcbiAgICAgICAgICBdO1xuXG4gICAgICAgICAgbGV0IGZ1bmN0aW9uUmVzcG9uc2U6XG4gICAgICAgICAgICB8IFJlc3BvbnNlXG4gICAgICAgICAgICB8IHVuZGVmaW5lZFxuICAgICAgICAgICAgfCB2b2lkXG4gICAgICAgICAgICB8IHN0cmluZ1xuICAgICAgICAgICAgfCBBc3luY0l0ZXJhYmxlT3BlbkFJU3RyZWFtUmV0dXJuVHlwZXNcbiAgICAgICAgICAgIHwgdW5kZWZpbmVkID0gdW5kZWZpbmVkO1xuICAgICAgICAgIC8vIFRoaXMgY2FsbGJhY2tzLmV4cGVyaW1lbnRhbF9vbkZ1bmN0aW9uQ2FsbCBjaGVjayBzaG91bGQgbm90IGJlIG5lY2Vzc2FyeSBidXQgVFMgY29tcGxhaW5zXG4gICAgICAgICAgaWYgKGNhbGxiYWNrcy5leHBlcmltZW50YWxfb25GdW5jdGlvbkNhbGwpIHtcbiAgICAgICAgICAgIC8vIElmIHRoZSB1c2VyIGlzIHVzaW5nIHRoZSBleHBlcmltZW50YWxfb25GdW5jdGlvbkNhbGwgY2FsbGJhY2ssIHRoZXkgc2hvdWxkIG5vdCBiZSB1c2luZyB0b29sc1xuICAgICAgICAgICAgLy8gaWYgcGF5bG9hZC5mdW5jdGlvbl9jYWxsIGlzIG5vdCBkZWZpbmVkIGJ5IHRpbWUgd2UgZ2V0IGhlcmUgd2UgbXVzdCBoYXZlIGdvdHRlbiBhIHRvb2wgcmVzcG9uc2VcbiAgICAgICAgICAgIC8vIGFuZCB0aGUgdXNlciBoYWQgZGVmaW5lZCBleHBlcmltZW50YWxfb25Ub29sQ2FsbFxuICAgICAgICAgICAgaWYgKHBheWxvYWQuZnVuY3Rpb25fY2FsbCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgIGNvbnNvbGUud2FybihcbiAgICAgICAgICAgICAgICAnZXhwZXJpbWVudGFsX29uRnVuY3Rpb25DYWxsIHNob3VsZCBub3QgYmUgZGVmaW5lZCB3aGVuIHVzaW5nIHRvb2xzJyxcbiAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgY29uc3QgYXJndW1lbnRzUGF5bG9hZCA9IEpTT04ucGFyc2UoXG4gICAgICAgICAgICAgIHBheWxvYWQuZnVuY3Rpb25fY2FsbC5hcmd1bWVudHMsXG4gICAgICAgICAgICApO1xuXG4gICAgICAgICAgICBmdW5jdGlvblJlc3BvbnNlID0gYXdhaXQgY2FsbGJhY2tzLmV4cGVyaW1lbnRhbF9vbkZ1bmN0aW9uQ2FsbChcbiAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIG5hbWU6IHBheWxvYWQuZnVuY3Rpb25fY2FsbC5uYW1lLFxuICAgICAgICAgICAgICAgIGFyZ3VtZW50czogYXJndW1lbnRzUGF5bG9hZCxcbiAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgcmVzdWx0ID0+IHtcbiAgICAgICAgICAgICAgICAvLyBBcHBlbmQgdGhlIGZ1bmN0aW9uIGNhbGwgcmVxdWVzdCBhbmQgcmVzdWx0IG1lc3NhZ2VzIHRvIHRoZSBsaXN0XG4gICAgICAgICAgICAgICAgbmV3RnVuY3Rpb25DYWxsTWVzc2FnZXMgPSBbXG4gICAgICAgICAgICAgICAgICAuLi5mdW5jdGlvbkNhbGxNZXNzYWdlcyxcbiAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgcm9sZTogJ2Fzc2lzdGFudCcsXG4gICAgICAgICAgICAgICAgICAgIGNvbnRlbnQ6ICcnLFxuICAgICAgICAgICAgICAgICAgICBmdW5jdGlvbl9jYWxsOiBwYXlsb2FkLmZ1bmN0aW9uX2NhbGwsXG4gICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICByb2xlOiAnZnVuY3Rpb24nLFxuICAgICAgICAgICAgICAgICAgICBuYW1lOiBwYXlsb2FkLmZ1bmN0aW9uX2NhbGwubmFtZSxcbiAgICAgICAgICAgICAgICAgICAgY29udGVudDogSlNPTi5zdHJpbmdpZnkocmVzdWx0KSxcbiAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgXTtcbiAgICAgICAgICAgICAgICAvLyBSZXR1cm4gaXQgdG8gdGhlIHVzZXJcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3RnVuY3Rpb25DYWxsTWVzc2FnZXM7XG4gICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICApO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoY2FsbGJhY2tzLmV4cGVyaW1lbnRhbF9vblRvb2xDYWxsKSB7XG4gICAgICAgICAgICBjb25zdCB0b29sQ2FsbHM6IFRvb2xDYWxsUGF5bG9hZCA9IHtcbiAgICAgICAgICAgICAgdG9vbHM6IFtdLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGZvciAoY29uc3QgdG9vbCBvZiBwYXlsb2FkLnRvb2xfY2FsbHMpIHtcbiAgICAgICAgICAgICAgdG9vbENhbGxzLnRvb2xzLnB1c2goe1xuICAgICAgICAgICAgICAgIGlkOiB0b29sLmlkLFxuICAgICAgICAgICAgICAgIHR5cGU6ICdmdW5jdGlvbicsXG4gICAgICAgICAgICAgICAgZnVuYzoge1xuICAgICAgICAgICAgICAgICAgbmFtZTogdG9vbC5mdW5jdGlvbi5uYW1lLFxuICAgICAgICAgICAgICAgICAgYXJndW1lbnRzOiBKU09OLnBhcnNlKHRvb2wuZnVuY3Rpb24uYXJndW1lbnRzKSxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxldCByZXNwb25zZUluZGV4ID0gMDtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgIGZ1bmN0aW9uUmVzcG9uc2UgPSBhd2FpdCBjYWxsYmFja3MuZXhwZXJpbWVudGFsX29uVG9vbENhbGwoXG4gICAgICAgICAgICAgICAgdG9vbENhbGxzLFxuICAgICAgICAgICAgICAgIHJlc3VsdCA9PiB7XG4gICAgICAgICAgICAgICAgICBpZiAocmVzdWx0KSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHsgdG9vbF9jYWxsX2lkLCBmdW5jdGlvbl9uYW1lLCB0b29sX2NhbGxfcmVzdWx0IH0gPVxuICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdDtcbiAgICAgICAgICAgICAgICAgICAgLy8gQXBwZW5kIHRoZSBmdW5jdGlvbiBjYWxsIHJlcXVlc3QgYW5kIHJlc3VsdCBtZXNzYWdlcyB0byB0aGUgbGlzdFxuICAgICAgICAgICAgICAgICAgICBuZXdGdW5jdGlvbkNhbGxNZXNzYWdlcyA9IFtcbiAgICAgICAgICAgICAgICAgICAgICAuLi5uZXdGdW5jdGlvbkNhbGxNZXNzYWdlcyxcbiAgICAgICAgICAgICAgICAgICAgICAvLyBPbmx5IGFwcGVuZCB0aGUgYXNzaXN0YW50IG1lc3NhZ2UgaWYgaXQncyB0aGUgZmlyc3QgcmVzcG9uc2VcbiAgICAgICAgICAgICAgICAgICAgICAuLi4ocmVzcG9uc2VJbmRleCA9PT0gMFxuICAgICAgICAgICAgICAgICAgICAgICAgPyBbXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcm9sZTogJ2Fzc2lzdGFudCcgYXMgY29uc3QsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250ZW50OiAnJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRvb2xfY2FsbHM6IHBheWxvYWQudG9vbF9jYWxscy5tYXAoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICh0YzogVG9vbENhbGwpID0+ICh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWQ6IHRjLmlkLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6ICdmdW5jdGlvbicsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZnVuY3Rpb246IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5hbWU6IHRjLmZ1bmN0aW9uLm5hbWUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyB3ZSBzZW5kIHRoZSBhcmd1bWVudHMgYW4gb2JqZWN0IHRvIHRoZSB1c2VyLCBidXQgYXMgdGhlIEFQSSBleHBlY3RzIGEgc3RyaW5nLCB3ZSBuZWVkIHRvIHN0cmluZ2lmeSBpdFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYXJndW1lbnRzOiBKU09OLnN0cmluZ2lmeShcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGMuZnVuY3Rpb24uYXJndW1lbnRzLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgXVxuICAgICAgICAgICAgICAgICAgICAgICAgOiBbXSksXG4gICAgICAgICAgICAgICAgICAgICAgLy8gQXBwZW5kIHRoZSBmdW5jdGlvbiBjYWxsIHJlc3VsdCBtZXNzYWdlXG4gICAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgcm9sZTogJ3Rvb2wnLFxuICAgICAgICAgICAgICAgICAgICAgICAgdG9vbF9jYWxsX2lkLFxuICAgICAgICAgICAgICAgICAgICAgICAgbmFtZTogZnVuY3Rpb25fbmFtZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRlbnQ6IEpTT04uc3RyaW5naWZ5KHRvb2xfY2FsbF9yZXN1bHQpLFxuICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIF07XG4gICAgICAgICAgICAgICAgICAgIHJlc3BvbnNlSW5kZXgrKztcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIC8vIFJldHVybiBpdCB0byB0aGUgdXNlclxuICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ld0Z1bmN0aW9uQ2FsbE1lc3NhZ2VzO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGNhbGxpbmcgZXhwZXJpbWVudGFsX29uVG9vbENhbGw6JywgZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKCFmdW5jdGlvblJlc3BvbnNlKSB7XG4gICAgICAgICAgICAvLyBUaGUgdXNlciBkaWRuJ3QgZG8gYW55dGhpbmcgd2l0aCB0aGUgZnVuY3Rpb24gY2FsbCBvbiB0aGUgc2VydmVyIGFuZCB3YW50c1xuICAgICAgICAgICAgLy8gdG8gZWl0aGVyIGRvIG5vdGhpbmcgb3IgcnVuIGl0IG9uIHRoZSBjbGllbnRcbiAgICAgICAgICAgIC8vIHNvIHdlIGp1c3QgcmV0dXJuIHRoZSBmdW5jdGlvbiBjYWxsIGFzIGEgbWVzc2FnZVxuICAgICAgICAgICAgY29udHJvbGxlci5lbnF1ZXVlKFxuICAgICAgICAgICAgICB0ZXh0RW5jb2Rlci5lbmNvZGUoXG4gICAgICAgICAgICAgICAgZm9ybWF0U3RyZWFtUGFydChcbiAgICAgICAgICAgICAgICAgIHBheWxvYWQuZnVuY3Rpb25fY2FsbCA/ICdmdW5jdGlvbl9jYWxsJyA6ICd0b29sX2NhbGxzJyxcbiAgICAgICAgICAgICAgICAgIC8vIHBhcnNlIHRvIHByZXZlbnQgZG91YmxlLWVuY29kaW5nOlxuICAgICAgICAgICAgICAgICAgSlNPTi5wYXJzZShhZ2dyZWdhdGVkUmVzcG9uc2UpLFxuICAgICAgICAgICAgICAgICksXG4gICAgICAgICAgICAgICksXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIGZ1bmN0aW9uUmVzcG9uc2UgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAvLyBUaGUgdXNlciByZXR1cm5lZCBhIHN0cmluZywgc28gd2UganVzdCByZXR1cm4gaXQgYXMgYSBtZXNzYWdlXG4gICAgICAgICAgICBjb250cm9sbGVyLmVucXVldWUoXG4gICAgICAgICAgICAgIHRleHRFbmNvZGVyLmVuY29kZShmb3JtYXRTdHJlYW1QYXJ0KCd0ZXh0JywgZnVuY3Rpb25SZXNwb25zZSkpLFxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIGFnZ3JlZ2F0ZWRGaW5hbENvbXBsZXRpb25SZXNwb25zZSA9IGZ1bmN0aW9uUmVzcG9uc2U7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgLy8gUmVjdXJzaXZlbHk6XG5cbiAgICAgICAgICAvLyBXZSBkb24ndCB3YW50IHRvIHRyaWdnZXIgb25TdGFydCBvciBvbkNvbXBsZXRlIHJlY3Vyc2l2ZWx5XG4gICAgICAgICAgLy8gc28gd2UgcmVtb3ZlIHRoZW0gZnJvbSB0aGUgY2FsbGJhY2tzXG4gICAgICAgICAgLy8gc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS92ZXJjZWwvYWkvaXNzdWVzLzM1MVxuICAgICAgICAgIGNvbnN0IGZpbHRlcmVkQ2FsbGJhY2tzOiBPcGVuQUlTdHJlYW1DYWxsYmFja3MgPSB7XG4gICAgICAgICAgICAuLi5jYWxsYmFja3MsXG4gICAgICAgICAgICBvblN0YXJ0OiB1bmRlZmluZWQsXG4gICAgICAgICAgfTtcbiAgICAgICAgICAvLyBXZSBvbmx5IHdhbnQgb25GaW5hbCB0byBiZSBjYWxsZWQgdGhlIF9sYXN0XyB0aW1lXG4gICAgICAgICAgY2FsbGJhY2tzLm9uRmluYWwgPSB1bmRlZmluZWQ7XG5cbiAgICAgICAgICBjb25zdCBvcGVuQUlTdHJlYW0gPSBPcGVuQUlTdHJlYW0oZnVuY3Rpb25SZXNwb25zZSwge1xuICAgICAgICAgICAgLi4uZmlsdGVyZWRDYWxsYmFja3MsXG4gICAgICAgICAgICBbX19pbnRlcm5hbF9fT3BlbkFJRm5NZXNzYWdlc1N5bWJvbF06IG5ld0Z1bmN0aW9uQ2FsbE1lc3NhZ2VzLFxuICAgICAgICAgIH0gYXMgQUlTdHJlYW1DYWxsYmFja3NBbmRPcHRpb25zKTtcblxuICAgICAgICAgIGNvbnN0IHJlYWRlciA9IG9wZW5BSVN0cmVhbS5nZXRSZWFkZXIoKTtcblxuICAgICAgICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICAgICAgICBjb25zdCB7IGRvbmUsIHZhbHVlIH0gPSBhd2FpdCByZWFkZXIucmVhZCgpO1xuICAgICAgICAgICAgaWYgKGRvbmUpIHtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb250cm9sbGVyLmVucXVldWUodmFsdWUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgaWYgKGNhbGxiYWNrcy5vbkZpbmFsICYmIGFnZ3JlZ2F0ZWRGaW5hbENvbXBsZXRpb25SZXNwb25zZSkge1xuICAgICAgICAgIGF3YWl0IGNhbGxiYWNrcy5vbkZpbmFsKGFnZ3JlZ2F0ZWRGaW5hbENvbXBsZXRpb25SZXNwb25zZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuICB9KTtcbn1cbiIsIi8qKlxuICogQ29uc3VtZXMgYSBSZWFkYWJsZVN0cmVhbSB1bnRpbCBpdCdzIGZ1bGx5IHJlYWQuXG4gKlxuICogVGhpcyBmdW5jdGlvbiByZWFkcyB0aGUgc3RyZWFtIGNodW5rIGJ5IGNodW5rIHVudGlsIHRoZSBzdHJlYW0gaXMgZXhoYXVzdGVkLlxuICogSXQgZG9lc24ndCBwcm9jZXNzIG9yIHJldHVybiB0aGUgZGF0YSBmcm9tIHRoZSBzdHJlYW07IGl0IHNpbXBseSBlbnN1cmVzXG4gKiB0aGF0IHRoZSBlbnRpcmUgc3RyZWFtIGlzIHJlYWQuXG4gKlxuICogQHBhcmFtIHtSZWFkYWJsZVN0cmVhbX0gc3RyZWFtIC0gVGhlIFJlYWRhYmxlU3RyZWFtIHRvIGJlIGNvbnN1bWVkLlxuICogQHJldHVybnMge1Byb21pc2U8dm9pZD59IEEgcHJvbWlzZSB0aGF0IHJlc29sdmVzIHdoZW4gdGhlIHN0cmVhbSBpcyBmdWxseSBjb25zdW1lZC5cbiAqL1xuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGNvbnN1bWVTdHJlYW0oc3RyZWFtOiBSZWFkYWJsZVN0cmVhbSk6IFByb21pc2U8dm9pZD4ge1xuICBjb25zdCByZWFkZXIgPSBzdHJlYW0uZ2V0UmVhZGVyKCk7XG4gIHdoaWxlICh0cnVlKSB7XG4gICAgY29uc3QgeyBkb25lIH0gPSBhd2FpdCByZWFkZXIucmVhZCgpO1xuICAgIGlmIChkb25lKSBicmVhaztcbiAgfVxufVxuIiwiZXhwb3J0IGNvbnN0IFNUUkVBTUFCTEVfVkFMVUVfVFlQRSA9IFN5bWJvbC5mb3IoJ3VpLnN0cmVhbWFibGUudmFsdWUnKTtcblxuZXhwb3J0IHR5cGUgU3RyZWFtYWJsZVBhdGNoID0gdW5kZWZpbmVkIHwgWzAsIHN0cmluZ107IC8vIEFwcGVuZCBzdHJpbmcuXG5cbmRlY2xhcmUgY29uc3QgX19pbnRlcm5hbF9jdXJyOiB1bmlxdWUgc3ltYm9sO1xuZGVjbGFyZSBjb25zdCBfX2ludGVybmFsX2Vycm9yOiB1bmlxdWUgc3ltYm9sO1xuXG4vKipcbiAqIFN0cmVhbWFibGVWYWx1ZSBpcyBhIHZhbHVlIHRoYXQgY2FuIGJlIHN0cmVhbWVkIG92ZXIgdGhlIG5ldHdvcmsgdmlhIEFJIEFjdGlvbnMuXG4gKiBUbyByZWFkIHRoZSBzdHJlYW1lZCB2YWx1ZXMsIHVzZSB0aGUgYHJlYWRTdHJlYW1hYmxlVmFsdWVgIG9yIGB1c2VTdHJlYW1hYmxlVmFsdWVgIEFQSXMuXG4gKi9cbmV4cG9ydCB0eXBlIFN0cmVhbWFibGVWYWx1ZTxUID0gYW55LCBFID0gYW55PiA9IHtcbiAgLyoqXG4gICAqIEBpbnRlcm5hbCBVc2UgYHJlYWRTdHJlYW1hYmxlVmFsdWVgIHRvIHJlYWQgdGhlIHZhbHVlcy5cbiAgICovXG4gIHR5cGU/OiB0eXBlb2YgU1RSRUFNQUJMRV9WQUxVRV9UWVBFO1xuICAvKipcbiAgICogQGludGVybmFsIFVzZSBgcmVhZFN0cmVhbWFibGVWYWx1ZWAgdG8gcmVhZCB0aGUgdmFsdWVzLlxuICAgKi9cbiAgY3Vycj86IFQ7XG4gIC8qKlxuICAgKiBAaW50ZXJuYWwgVXNlIGByZWFkU3RyZWFtYWJsZVZhbHVlYCB0byByZWFkIHRoZSB2YWx1ZXMuXG4gICAqL1xuICBlcnJvcj86IEU7XG4gIC8qKlxuICAgKiBAaW50ZXJuYWwgVXNlIGByZWFkU3RyZWFtYWJsZVZhbHVlYCB0byByZWFkIHRoZSB2YWx1ZXMuXG4gICAqL1xuICBkaWZmPzogU3RyZWFtYWJsZVBhdGNoO1xuICAvKipcbiAgICogQGludGVybmFsIFVzZSBgcmVhZFN0cmVhbWFibGVWYWx1ZWAgdG8gcmVhZCB0aGUgdmFsdWVzLlxuICAgKi9cbiAgbmV4dD86IFByb21pc2U8U3RyZWFtYWJsZVZhbHVlPFQsIEU+PjtcblxuICAvLyBicmFuZGVkIHR5cGVzIHRvIG1haW50YWluIHR5cGUgc2lnbmF0dXJlIGFmdGVyIGludGVybmFsIHByb3BlcnRpZXMgYXJlIHN0cmlwcGVkLlxuICBbX19pbnRlcm5hbF9jdXJyXT86IFQ7XG4gIFtfX2ludGVybmFsX2Vycm9yXT86IEU7XG59O1xuIiwiaW1wb3J0IHsgSEFOR0lOR19TVFJFQU1fV0FSTklOR19USU1FX01TIH0gZnJvbSAnLi4vLi4vdXRpbC9jb25zdGFudHMnO1xuaW1wb3J0IHsgY3JlYXRlUmVzb2x2YWJsZVByb21pc2UgfSBmcm9tICcuLi8uLi91dGlsL2NyZWF0ZS1yZXNvbHZhYmxlLXByb21pc2UnO1xuaW1wb3J0IHtcbiAgU1RSRUFNQUJMRV9WQUxVRV9UWVBFLFxuICBTdHJlYW1hYmxlUGF0Y2gsXG4gIFN0cmVhbWFibGVWYWx1ZSxcbn0gZnJvbSAnLi9zdHJlYW1hYmxlLXZhbHVlJztcblxuY29uc3QgU1RSRUFNQUJMRV9WQUxVRV9JTlRFUk5BTF9MT0NLID0gU3ltYm9sKCdzdHJlYW1hYmxlLnZhbHVlLmxvY2snKTtcblxuLyoqXG4gKiBDcmVhdGUgYSB3cmFwcGVkLCBjaGFuZ2VhYmxlIHZhbHVlIHRoYXQgY2FuIGJlIHN0cmVhbWVkIHRvIHRoZSBjbGllbnQuXG4gKiBPbiB0aGUgY2xpZW50IHNpZGUsIHRoZSB2YWx1ZSBjYW4gYmUgYWNjZXNzZWQgdmlhIHRoZSByZWFkU3RyZWFtYWJsZVZhbHVlKCkgQVBJLlxuICovXG5mdW5jdGlvbiBjcmVhdGVTdHJlYW1hYmxlVmFsdWU8VCA9IGFueSwgRSA9IGFueT4oXG4gIGluaXRpYWxWYWx1ZT86IFQgfCBSZWFkYWJsZVN0cmVhbTxUPixcbikge1xuICBjb25zdCBpc1JlYWRhYmxlU3RyZWFtID1cbiAgICBpbml0aWFsVmFsdWUgaW5zdGFuY2VvZiBSZWFkYWJsZVN0cmVhbSB8fFxuICAgICh0eXBlb2YgaW5pdGlhbFZhbHVlID09PSAnb2JqZWN0JyAmJlxuICAgICAgaW5pdGlhbFZhbHVlICE9PSBudWxsICYmXG4gICAgICAnZ2V0UmVhZGVyJyBpbiBpbml0aWFsVmFsdWUgJiZcbiAgICAgIHR5cGVvZiBpbml0aWFsVmFsdWUuZ2V0UmVhZGVyID09PSAnZnVuY3Rpb24nICYmXG4gICAgICAnbG9ja2VkJyBpbiBpbml0aWFsVmFsdWUgJiZcbiAgICAgIHR5cGVvZiBpbml0aWFsVmFsdWUubG9ja2VkID09PSAnYm9vbGVhbicpO1xuXG4gIGlmICghaXNSZWFkYWJsZVN0cmVhbSkge1xuICAgIHJldHVybiBjcmVhdGVTdHJlYW1hYmxlVmFsdWVJbXBsPFQsIEU+KGluaXRpYWxWYWx1ZSk7XG4gIH1cblxuICBjb25zdCBzdHJlYW1hYmxlVmFsdWUgPSBjcmVhdGVTdHJlYW1hYmxlVmFsdWVJbXBsPFQsIEU+KCk7XG5cbiAgLy8gU2luY2UgdGhlIHN0cmVhbWFibGUgdmFsdWUgd2lsbCBiZSBmcm9tIGEgcmVhZGFibGUgc3RyZWFtLCBpdCdzIG5vdCBhbGxvd2VkXG4gIC8vIHRvIHVwZGF0ZSB0aGUgdmFsdWUgbWFudWFsbHkgYXMgdGhhdCBpbnRyb2R1Y2VzIHJhY2UgY29uZGl0aW9ucyBhbmRcbiAgLy8gdW5leHBlY3RlZCBiZWhhdmlvci5cbiAgLy8gV2UgbG9jayB0aGUgdmFsdWUgdG8gcHJldmVudCBhbnkgdXBkYXRlcyBmcm9tIHRoZSB1c2VyLlxuICBzdHJlYW1hYmxlVmFsdWVbU1RSRUFNQUJMRV9WQUxVRV9JTlRFUk5BTF9MT0NLXSA9IHRydWU7XG5cbiAgKGFzeW5jICgpID0+IHtcbiAgICB0cnkge1xuICAgICAgLy8gQ29uc3VtZSB0aGUgcmVhZGFibGUgc3RyZWFtIGFuZCB1cGRhdGUgdGhlIHZhbHVlLlxuICAgICAgY29uc3QgcmVhZGVyID0gaW5pdGlhbFZhbHVlLmdldFJlYWRlcigpO1xuXG4gICAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgICBjb25zdCB7IHZhbHVlLCBkb25lIH0gPSBhd2FpdCByZWFkZXIucmVhZCgpO1xuICAgICAgICBpZiAoZG9uZSkge1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gVW5sb2NrIHRoZSB2YWx1ZSB0byBhbGxvdyB1cGRhdGVzLlxuICAgICAgICBzdHJlYW1hYmxlVmFsdWVbU1RSRUFNQUJMRV9WQUxVRV9JTlRFUk5BTF9MT0NLXSA9IGZhbHNlO1xuICAgICAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJykge1xuICAgICAgICAgIHN0cmVhbWFibGVWYWx1ZS5hcHBlbmQodmFsdWUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHN0cmVhbWFibGVWYWx1ZS51cGRhdGUodmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIC8vIExvY2sgdGhlIHZhbHVlIGFnYWluLlxuICAgICAgICBzdHJlYW1hYmxlVmFsdWVbU1RSRUFNQUJMRV9WQUxVRV9JTlRFUk5BTF9MT0NLXSA9IHRydWU7XG4gICAgICB9XG5cbiAgICAgIHN0cmVhbWFibGVWYWx1ZVtTVFJFQU1BQkxFX1ZBTFVFX0lOVEVSTkFMX0xPQ0tdID0gZmFsc2U7XG4gICAgICBzdHJlYW1hYmxlVmFsdWUuZG9uZSgpO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIHN0cmVhbWFibGVWYWx1ZVtTVFJFQU1BQkxFX1ZBTFVFX0lOVEVSTkFMX0xPQ0tdID0gZmFsc2U7XG4gICAgICBzdHJlYW1hYmxlVmFsdWUuZXJyb3IoZSk7XG4gICAgfVxuICB9KSgpO1xuXG4gIHJldHVybiBzdHJlYW1hYmxlVmFsdWU7XG59XG5cbi8vIEl0J3MgbmVjZXNzYXJ5IHRvIGRlZmluZSB0aGUgdHlwZSBtYW51YWxseSBoZXJlLCBvdGhlcndpc2UgVHlwZVNjcmlwdCBjb21waWxlclxuLy8gd2lsbCBub3QgYmUgYWJsZSB0byBpbmZlciB0aGUgY29ycmVjdCByZXR1cm4gdHlwZSBhcyBpdCdzIGNpcmN1bGFyLlxudHlwZSBTdHJlYW1hYmxlVmFsdWVXcmFwcGVyPFQsIEU+ID0ge1xuICAvKipcbiAgICogVGhlIHZhbHVlIG9mIHRoZSBzdHJlYW1hYmxlLiBUaGlzIGNhbiBiZSByZXR1cm5lZCBmcm9tIGEgU2VydmVyIEFjdGlvbiBhbmRcbiAgICogcmVjZWl2ZWQgYnkgdGhlIGNsaWVudC4gVG8gcmVhZCB0aGUgc3RyZWFtZWQgdmFsdWVzLCB1c2UgdGhlXG4gICAqIGByZWFkU3RyZWFtYWJsZVZhbHVlYCBvciBgdXNlU3RyZWFtYWJsZVZhbHVlYCBBUElzLlxuICAgKi9cbiAgcmVhZG9ubHkgdmFsdWU6IFN0cmVhbWFibGVWYWx1ZTxULCBFPjtcblxuICAvKipcbiAgICogVGhpcyBtZXRob2QgdXBkYXRlcyB0aGUgY3VycmVudCB2YWx1ZSB3aXRoIGEgbmV3IG9uZS5cbiAgICovXG4gIHVwZGF0ZSh2YWx1ZTogVCk6IFN0cmVhbWFibGVWYWx1ZVdyYXBwZXI8VCwgRT47XG5cbiAgLyoqXG4gICAqIFRoaXMgbWV0aG9kIGlzIHVzZWQgdG8gYXBwZW5kIGEgZGVsdGEgc3RyaW5nIHRvIHRoZSBjdXJyZW50IHZhbHVlLiBJdFxuICAgKiByZXF1aXJlcyB0aGUgY3VycmVudCB2YWx1ZSBvZiB0aGUgc3RyZWFtYWJsZSB0byBiZSBhIHN0cmluZy5cbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICogYGBganN4XG4gICAqIGNvbnN0IHN0cmVhbWFibGUgPSBjcmVhdGVTdHJlYW1hYmxlVmFsdWUoJ2hlbGxvJyk7XG4gICAqIHN0cmVhbWFibGUuYXBwZW5kKCcgd29ybGQnKTtcbiAgICpcbiAgICogLy8gVGhlIHZhbHVlIHdpbGwgYmUgJ2hlbGxvIHdvcmxkJ1xuICAgKiBgYGBcbiAgICovXG4gIGFwcGVuZCh2YWx1ZTogVCk6IFN0cmVhbWFibGVWYWx1ZVdyYXBwZXI8VCwgRT47XG5cbiAgLyoqXG4gICAqIFRoaXMgbWV0aG9kIGlzIHVzZWQgdG8gc2lnbmFsIHRoYXQgdGhlcmUgaXMgYW4gZXJyb3IgaW4gdGhlIHZhbHVlIHN0cmVhbS5cbiAgICogSXQgd2lsbCBiZSB0aHJvd24gb24gdGhlIGNsaWVudCBzaWRlIHdoZW4gY29uc3VtZWQgdmlhXG4gICAqIGByZWFkU3RyZWFtYWJsZVZhbHVlYCBvciBgdXNlU3RyZWFtYWJsZVZhbHVlYC5cbiAgICovXG4gIGVycm9yKGVycm9yOiBhbnkpOiBTdHJlYW1hYmxlVmFsdWVXcmFwcGVyPFQsIEU+O1xuXG4gIC8qKlxuICAgKiBUaGlzIG1ldGhvZCBtYXJrcyB0aGUgdmFsdWUgYXMgZmluYWxpemVkLiBZb3UgY2FuIGVpdGhlciBjYWxsIGl0IHdpdGhvdXRcbiAgICogYW55IHBhcmFtZXRlcnMgb3Igd2l0aCBhIG5ldyB2YWx1ZSBhcyB0aGUgZmluYWwgc3RhdGUuXG4gICAqIE9uY2UgY2FsbGVkLCB0aGUgdmFsdWUgY2Fubm90IGJlIHVwZGF0ZWQgb3IgYXBwZW5kZWQgYW55bW9yZS5cbiAgICpcbiAgICogVGhpcyBtZXRob2QgaXMgYWx3YXlzICoqcmVxdWlyZWQqKiB0byBiZSBjYWxsZWQsIG90aGVyd2lzZSB0aGUgcmVzcG9uc2VcbiAgICogd2lsbCBiZSBzdHVjayBpbiBhIGxvYWRpbmcgc3RhdGUuXG4gICAqL1xuICBkb25lKC4uLmFyZ3M6IFtUXSB8IFtdKTogU3RyZWFtYWJsZVZhbHVlV3JhcHBlcjxULCBFPjtcblxuICAvKipcbiAgICogQGludGVybmFsIFRoaXMgaXMgYW4gaW50ZXJuYWwgbG9jayB0byBwcmV2ZW50IHRoZSB2YWx1ZSBmcm9tIGJlaW5nXG4gICAqIHVwZGF0ZWQgYnkgdGhlIHVzZXIuXG4gICAqL1xuICBbU1RSRUFNQUJMRV9WQUxVRV9JTlRFUk5BTF9MT0NLXTogYm9vbGVhbjtcbn07XG5cbmZ1bmN0aW9uIGNyZWF0ZVN0cmVhbWFibGVWYWx1ZUltcGw8VCA9IGFueSwgRSA9IGFueT4oaW5pdGlhbFZhbHVlPzogVCkge1xuICBsZXQgY2xvc2VkID0gZmFsc2U7XG4gIGxldCBsb2NrZWQgPSBmYWxzZTtcbiAgbGV0IHJlc29sdmFibGUgPSBjcmVhdGVSZXNvbHZhYmxlUHJvbWlzZTxTdHJlYW1hYmxlVmFsdWU8VCwgRT4+KCk7XG5cbiAgbGV0IGN1cnJlbnRWYWx1ZSA9IGluaXRpYWxWYWx1ZTtcbiAgbGV0IGN1cnJlbnRFcnJvcjogRSB8IHVuZGVmaW5lZDtcbiAgbGV0IGN1cnJlbnRQcm9taXNlOiB0eXBlb2YgcmVzb2x2YWJsZS5wcm9taXNlIHwgdW5kZWZpbmVkID1cbiAgICByZXNvbHZhYmxlLnByb21pc2U7XG4gIGxldCBjdXJyZW50UGF0Y2hWYWx1ZTogU3RyZWFtYWJsZVBhdGNoO1xuXG4gIGZ1bmN0aW9uIGFzc2VydFN0cmVhbShtZXRob2Q6IHN0cmluZykge1xuICAgIGlmIChjbG9zZWQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihtZXRob2QgKyAnOiBWYWx1ZSBzdHJlYW0gaXMgYWxyZWFkeSBjbG9zZWQuJyk7XG4gICAgfVxuICAgIGlmIChsb2NrZWQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgbWV0aG9kICsgJzogVmFsdWUgc3RyZWFtIGlzIGxvY2tlZCBhbmQgY2Fubm90IGJlIHVwZGF0ZWQuJyxcbiAgICAgICk7XG4gICAgfVxuICB9XG5cbiAgbGV0IHdhcm5pbmdUaW1lb3V0OiBOb2RlSlMuVGltZW91dCB8IHVuZGVmaW5lZDtcbiAgZnVuY3Rpb24gd2FyblVuY2xvc2VkU3RyZWFtKCkge1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gJ2RldmVsb3BtZW50Jykge1xuICAgICAgaWYgKHdhcm5pbmdUaW1lb3V0KSB7XG4gICAgICAgIGNsZWFyVGltZW91dCh3YXJuaW5nVGltZW91dCk7XG4gICAgICB9XG4gICAgICB3YXJuaW5nVGltZW91dCA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICBjb25zb2xlLndhcm4oXG4gICAgICAgICAgJ1RoZSBzdHJlYW1hYmxlIHZhbHVlIGhhcyBiZWVuIHNsb3cgdG8gdXBkYXRlLiBUaGlzIG1heSBiZSBhIGJ1ZyBvciBhIHBlcmZvcm1hbmNlIGlzc3VlIG9yIHlvdSBmb3Jnb3QgdG8gY2FsbCBgLmRvbmUoKWAuJyxcbiAgICAgICAgKTtcbiAgICAgIH0sIEhBTkdJTkdfU1RSRUFNX1dBUk5JTkdfVElNRV9NUyk7XG4gICAgfVxuICB9XG4gIHdhcm5VbmNsb3NlZFN0cmVhbSgpO1xuXG4gIGZ1bmN0aW9uIGNyZWF0ZVdyYXBwZWQoaW5pdGlhbENodW5rPzogYm9vbGVhbik6IFN0cmVhbWFibGVWYWx1ZTxULCBFPiB7XG4gICAgLy8gVGhpcyBtYWtlcyB0aGUgcGF5bG9hZCBtdWNoIHNtYWxsZXIgaWYgdGhlcmUncmUgbXV0YXRpdmUgdXBkYXRlcyBiZWZvcmUgdGhlIGZpcnN0IHJlYWQuXG4gICAgbGV0IGluaXQ6IFBhcnRpYWw8U3RyZWFtYWJsZVZhbHVlPFQsIEU+PjtcblxuICAgIGlmIChjdXJyZW50RXJyb3IgIT09IHVuZGVmaW5lZCkge1xuICAgICAgaW5pdCA9IHsgZXJyb3I6IGN1cnJlbnRFcnJvciB9O1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoY3VycmVudFBhdGNoVmFsdWUgJiYgIWluaXRpYWxDaHVuaykge1xuICAgICAgICBpbml0ID0geyBkaWZmOiBjdXJyZW50UGF0Y2hWYWx1ZSB9O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaW5pdCA9IHsgY3VycjogY3VycmVudFZhbHVlIH07XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGN1cnJlbnRQcm9taXNlKSB7XG4gICAgICBpbml0Lm5leHQgPSBjdXJyZW50UHJvbWlzZTtcbiAgICB9XG5cbiAgICBpZiAoaW5pdGlhbENodW5rKSB7XG4gICAgICBpbml0LnR5cGUgPSBTVFJFQU1BQkxFX1ZBTFVFX1RZUEU7XG4gICAgfVxuXG4gICAgcmV0dXJuIGluaXQ7XG4gIH1cblxuICAvLyBVcGRhdGUgdGhlIGludGVybmFsIGBjdXJyZW50VmFsdWVgIGFuZCBgY3VycmVudFBhdGNoVmFsdWVgIGlmIG5lZWRlZC5cbiAgZnVuY3Rpb24gdXBkYXRlVmFsdWVTdGF0ZXModmFsdWU6IFQpIHtcbiAgICAvLyBJZiB3ZSBjYW4gb25seSBzZW5kIGEgcGF0Y2ggb3ZlciB0aGUgd2lyZSwgaXQncyBiZXR0ZXIgdG8gZG8gc28uXG4gICAgY3VycmVudFBhdGNoVmFsdWUgPSB1bmRlZmluZWQ7XG4gICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgIGlmICh0eXBlb2YgY3VycmVudFZhbHVlID09PSAnc3RyaW5nJykge1xuICAgICAgICBpZiAodmFsdWUuc3RhcnRzV2l0aChjdXJyZW50VmFsdWUpKSB7XG4gICAgICAgICAgY3VycmVudFBhdGNoVmFsdWUgPSBbMCwgdmFsdWUuc2xpY2UoY3VycmVudFZhbHVlLmxlbmd0aCldO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgY3VycmVudFZhbHVlID0gdmFsdWU7XG4gIH1cblxuICBjb25zdCBzdHJlYW1hYmxlOiBTdHJlYW1hYmxlVmFsdWVXcmFwcGVyPFQsIEU+ID0ge1xuICAgIHNldCBbU1RSRUFNQUJMRV9WQUxVRV9JTlRFUk5BTF9MT0NLXShzdGF0ZTogYm9vbGVhbikge1xuICAgICAgbG9ja2VkID0gc3RhdGU7XG4gICAgfSxcbiAgICBnZXQgdmFsdWUoKSB7XG4gICAgICByZXR1cm4gY3JlYXRlV3JhcHBlZCh0cnVlKTtcbiAgICB9LFxuICAgIHVwZGF0ZSh2YWx1ZTogVCkge1xuICAgICAgYXNzZXJ0U3RyZWFtKCcudXBkYXRlKCknKTtcblxuICAgICAgY29uc3QgcmVzb2x2ZVByZXZpb3VzID0gcmVzb2x2YWJsZS5yZXNvbHZlO1xuICAgICAgcmVzb2x2YWJsZSA9IGNyZWF0ZVJlc29sdmFibGVQcm9taXNlKCk7XG5cbiAgICAgIHVwZGF0ZVZhbHVlU3RhdGVzKHZhbHVlKTtcbiAgICAgIGN1cnJlbnRQcm9taXNlID0gcmVzb2x2YWJsZS5wcm9taXNlO1xuICAgICAgcmVzb2x2ZVByZXZpb3VzKGNyZWF0ZVdyYXBwZWQoKSk7XG5cbiAgICAgIHdhcm5VbmNsb3NlZFN0cmVhbSgpO1xuXG4gICAgICByZXR1cm4gc3RyZWFtYWJsZTtcbiAgICB9LFxuICAgIGFwcGVuZCh2YWx1ZTogVCkge1xuICAgICAgYXNzZXJ0U3RyZWFtKCcuYXBwZW5kKCknKTtcblxuICAgICAgaWYgKFxuICAgICAgICB0eXBlb2YgY3VycmVudFZhbHVlICE9PSAnc3RyaW5nJyAmJlxuICAgICAgICB0eXBlb2YgY3VycmVudFZhbHVlICE9PSAndW5kZWZpbmVkJ1xuICAgICAgKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICBgLmFwcGVuZCgpOiBUaGUgY3VycmVudCB2YWx1ZSBpcyBub3QgYSBzdHJpbmcuIFJlY2VpdmVkOiAke3R5cGVvZiBjdXJyZW50VmFsdWV9YCxcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIGlmICh0eXBlb2YgdmFsdWUgIT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICBgLmFwcGVuZCgpOiBUaGUgdmFsdWUgaXMgbm90IGEgc3RyaW5nLiBSZWNlaXZlZDogJHt0eXBlb2YgdmFsdWV9YCxcbiAgICAgICAgKTtcbiAgICAgIH1cblxuICAgICAgY29uc3QgcmVzb2x2ZVByZXZpb3VzID0gcmVzb2x2YWJsZS5yZXNvbHZlO1xuICAgICAgcmVzb2x2YWJsZSA9IGNyZWF0ZVJlc29sdmFibGVQcm9taXNlKCk7XG5cbiAgICAgIGlmICh0eXBlb2YgY3VycmVudFZhbHVlID09PSAnc3RyaW5nJykge1xuICAgICAgICBjdXJyZW50UGF0Y2hWYWx1ZSA9IFswLCB2YWx1ZV07XG4gICAgICAgIChjdXJyZW50VmFsdWUgYXMgc3RyaW5nKSA9IGN1cnJlbnRWYWx1ZSArIHZhbHVlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY3VycmVudFBhdGNoVmFsdWUgPSB1bmRlZmluZWQ7XG4gICAgICAgIGN1cnJlbnRWYWx1ZSA9IHZhbHVlO1xuICAgICAgfVxuXG4gICAgICBjdXJyZW50UHJvbWlzZSA9IHJlc29sdmFibGUucHJvbWlzZTtcbiAgICAgIHJlc29sdmVQcmV2aW91cyhjcmVhdGVXcmFwcGVkKCkpO1xuXG4gICAgICB3YXJuVW5jbG9zZWRTdHJlYW0oKTtcblxuICAgICAgcmV0dXJuIHN0cmVhbWFibGU7XG4gICAgfSxcbiAgICBlcnJvcihlcnJvcjogYW55KSB7XG4gICAgICBhc3NlcnRTdHJlYW0oJy5lcnJvcigpJyk7XG5cbiAgICAgIGlmICh3YXJuaW5nVGltZW91dCkge1xuICAgICAgICBjbGVhclRpbWVvdXQod2FybmluZ1RpbWVvdXQpO1xuICAgICAgfVxuICAgICAgY2xvc2VkID0gdHJ1ZTtcbiAgICAgIGN1cnJlbnRFcnJvciA9IGVycm9yO1xuICAgICAgY3VycmVudFByb21pc2UgPSB1bmRlZmluZWQ7XG5cbiAgICAgIHJlc29sdmFibGUucmVzb2x2ZSh7IGVycm9yIH0pO1xuXG4gICAgICByZXR1cm4gc3RyZWFtYWJsZTtcbiAgICB9LFxuICAgIGRvbmUoLi4uYXJnczogW10gfCBbVF0pIHtcbiAgICAgIGFzc2VydFN0cmVhbSgnLmRvbmUoKScpO1xuXG4gICAgICBpZiAod2FybmluZ1RpbWVvdXQpIHtcbiAgICAgICAgY2xlYXJUaW1lb3V0KHdhcm5pbmdUaW1lb3V0KTtcbiAgICAgIH1cbiAgICAgIGNsb3NlZCA9IHRydWU7XG4gICAgICBjdXJyZW50UHJvbWlzZSA9IHVuZGVmaW5lZDtcblxuICAgICAgaWYgKGFyZ3MubGVuZ3RoKSB7XG4gICAgICAgIHVwZGF0ZVZhbHVlU3RhdGVzKGFyZ3NbMF0pO1xuICAgICAgICByZXNvbHZhYmxlLnJlc29sdmUoY3JlYXRlV3JhcHBlZCgpKTtcbiAgICAgICAgcmV0dXJuIHN0cmVhbWFibGU7XG4gICAgICB9XG5cbiAgICAgIHJlc29sdmFibGUucmVzb2x2ZSh7fSk7XG5cbiAgICAgIHJldHVybiBzdHJlYW1hYmxlO1xuICAgIH0sXG4gIH07XG5cbiAgcmV0dXJuIHN0cmVhbWFibGU7XG59XG5cbmV4cG9ydCB7IGNyZWF0ZVN0cmVhbWFibGVWYWx1ZSB9O1xuIl0sIm5hbWVzIjpbImpzb25kaWZmcGF0Y2giLCJBc3luY0xvY2FsU3RvcmFnZSIsImNyZWF0ZVJlc29sdmFibGVQcm9taXNlIiwicmVzb2x2ZSIsInJlamVjdCIsInByb21pc2UiLCJQcm9taXNlIiwicmVzIiwicmVqIiwiaXNGdW5jdGlvbiIsInZhbHVlIiwiYXN5bmNBSVN0YXRlU3RvcmFnZSIsImdldEFJU3RhdGVTdG9yZU9yVGhyb3ciLCJtZXNzYWdlIiwic3RvcmUiLCJnZXRTdG9yZSIsIkVycm9yIiwid2l0aEFJU3RhdGUiLCJzdGF0ZSIsIm9wdGlvbnMiLCJmbiIsInJ1biIsImN1cnJlbnRTdGF0ZSIsIm9yaWdpbmFsU3RhdGUiLCJzZWFsZWQiLCJnZXRBSVN0YXRlRGVsdGFQcm9taXNlIiwibXV0YXRpb25EZWx0YVByb21pc2UiLCJzZWFsTXV0YWJsZUFJU3RhdGUiLCJnZXRBSVN0YXRlIiwiYXJncyIsImxlbmd0aCIsImtleSIsIlN0cmluZyIsImdldE11dGFibGVBSVN0YXRlIiwibXV0YXRpb25EZWx0YVJlc29sdmUiLCJkb1VwZGF0ZSIsIm5ld1N0YXRlIiwiZG9uZSIsIl9hIiwiX2IiLCJvblNldEFJU3RhdGUiLCJjYWxsIiwibXV0YWJsZVN0YXRlIiwiZ2V0IiwidXBkYXRlIiwibmV3QUlTdGF0ZSIsImRvbmVBcmdzIiwiZGVsdGEiLCJkaWZmIiwiUmVhY3QiLCJJbnRlcm5hbEFJUHJvdmlkZXIiLCJqc3giLCJpbm5lckFjdGlvbiIsImFjdGlvbiIsInJlc3VsdCIsIndyYXBBY3Rpb24iLCJiaW5kIiwiY3JlYXRlQUkiLCJhY3Rpb25zIiwiaW5pdGlhbEFJU3RhdGUiLCJpbml0aWFsVUlTdGF0ZSIsIm9uR2V0VUlTdGF0ZSIsIndyYXBwZWRBY3Rpb25zIiwibmFtZSIsIndyYXBwZWRTeW5jVUlTdGF0ZSIsIkFJIiwicHJvcHMiLCJ1aVN0YXRlIiwiYWlTdGF0ZSIsImFpU3RhdGVEZWx0YSIsIm5ld0FJU3RhdGVEZWx0YSIsIm5ld1VJU3RhdGUiLCJpbml0aWFsQUlTdGF0ZVBhdGNoIiwiY2hpbGRyZW4iLCJzYWZlUGFyc2VKU09OIiwiZ2V0RXJyb3JNZXNzYWdlIiwiQUlTREtFcnJvciIsIm1hcmtlciIsInN5bWJvbCIsIlN5bWJvbCIsImZvciIsIkRvd25sb2FkRXJyb3IiLCJjb25zdHJ1Y3RvciIsInVybCIsInN0YXR1c0NvZGUiLCJzdGF0dXNUZXh0IiwiY2F1c2UiLCJpc0luc3RhbmNlIiwiZXJyb3IiLCJoYXNNYXJrZXIiLCJpc0Rvd25sb2FkRXJyb3IiLCJ0b0pTT04iLCJkb3dubG9hZCIsImZldGNoSW1wbGVtZW50YXRpb24iLCJmZXRjaCIsInVybFRleHQiLCJ0b1N0cmluZyIsInJlc3BvbnNlIiwib2siLCJzdGF0dXMiLCJkYXRhIiwiVWludDhBcnJheSIsImFycmF5QnVmZmVyIiwibWltZVR5cGUiLCJoZWFkZXJzIiwibWltZVR5cGVTaWduYXR1cmVzIiwiYnl0ZXMiLCJkZXRlY3RJbWFnZU1pbWVUeXBlIiwiaW1hZ2UiLCJldmVyeSIsImJ5dGUiLCJpbmRleCIsImNvbnZlcnRCYXNlNjRUb1VpbnQ4QXJyYXkiLCJjb252ZXJ0VWludDhBcnJheVRvQmFzZTY0IiwiSW52YWxpZERhdGFDb250ZW50RXJyb3IiLCJjb250ZW50IiwiaXNJbnZhbGlkRGF0YUNvbnRlbnRFcnJvciIsInN0YWNrIiwiY29udmVydERhdGFDb250ZW50VG9VaW50OEFycmF5IiwiQXJyYXlCdWZmZXIiLCJJbnZhbGlkTWVzc2FnZVJvbGVFcnJvciIsInJvbGUiLCJpc0ludmFsaWRNZXNzYWdlUm9sZUVycm9yIiwiY29udmVydFRvTGFuZ3VhZ2VNb2RlbFByb21wdCIsInByb21wdCIsIm1vZGVsU3VwcG9ydHNJbWFnZVVybHMiLCJkb3dubG9hZEltcGxlbWVudGF0aW9uIiwibGFuZ3VhZ2VNb2RlbE1lc3NhZ2VzIiwic3lzdGVtIiwicHVzaCIsImRvd25sb2FkZWRJbWFnZXMiLCJtZXNzYWdlcyIsImRvd25sb2FkSW1hZ2VzIiwicHJvbXB0VHlwZSIsInR5cGUiLCJ0ZXh0IiwibWFwIiwiY29udmVydFRvTGFuZ3VhZ2VNb2RlbE1lc3NhZ2UiLCJfZXhoYXVzdGl2ZUNoZWNrIiwicHJvdmlkZXJNZXRhZGF0YSIsImV4cGVyaW1lbnRhbF9wcm92aWRlck1ldGFkYXRhIiwicGFydCIsIl9jIiwiVVJMIiwiZG93bmxvYWRlZEltYWdlIiwicHJvdG9jb2wiLCJoZWFkZXIiLCJiYXNlNjRDb250ZW50Iiwic3BsaXQiLCJfaWdub3JlZCIsImltYWdlVWludDgiLCJmaWx0ZXIiLCJ0b29sQ2FsbElkIiwidG9vbE5hbWUiLCJ1cmxzIiwiQXJyYXkiLCJpc0FycmF5IiwiZmxhdCIsInN0YXJ0c1dpdGgiLCJhbGwiLCJPYmplY3QiLCJmcm9tRW50cmllcyIsIkludmFsaWRQcm9tcHRFcnJvciIsImdldFZhbGlkYXRlZFByb21wdCIsIkludmFsaWRBcmd1bWVudEVycm9yIiwicGFyYW1ldGVyIiwiaXNJbnZhbGlkQXJndW1lbnRFcnJvciIsInByZXBhcmVDYWxsU2V0dGluZ3MiLCJtYXhUb2tlbnMiLCJ0ZW1wZXJhdHVyZSIsInRvcFAiLCJwcmVzZW5jZVBlbmFsdHkiLCJmcmVxdWVuY3lQZW5hbHR5Iiwic3RvcFNlcXVlbmNlcyIsInNlZWQiLCJtYXhSZXRyaWVzIiwiTnVtYmVyIiwiaXNJbnRlZ2VyIiwiYXNTY2hlbWEiLCJpc05vbkVtcHR5T2JqZWN0Iiwib2JqZWN0Iiwia2V5cyIsInByZXBhcmVUb29sc0FuZFRvb2xDaG9pY2UiLCJ0b29scyIsInRvb2xDaG9pY2UiLCJlbnRyaWVzIiwidG9vbCIsImRlc2NyaXB0aW9uIiwicGFyYW1ldGVycyIsImpzb25TY2hlbWEiLCJjYWxjdWxhdGVDb21wbGV0aW9uVG9rZW5Vc2FnZSIsInVzYWdlIiwicHJvbXB0VG9rZW5zIiwiY29tcGxldGlvblRva2VucyIsInRvdGFsVG9rZW5zIiwiSW52YWxpZFRvb2xBcmd1bWVudHNFcnJvciIsInRvb2xBcmdzIiwiaXNJbnZhbGlkVG9vbEFyZ3VtZW50c0Vycm9yIiwiTm9TdWNoVG9vbEVycm9yIiwiYXZhaWxhYmxlVG9vbHMiLCJqb2luIiwiaXNOb1N1Y2hUb29sRXJyb3IiLCJpc0FzeW5jR2VuZXJhdG9yIiwiYXN5bmNJdGVyYXRvciIsImlzR2VuZXJhdG9yIiwiaXRlcmF0b3IiLCJBUElDYWxsRXJyb3IiLCJpc0Fib3J0RXJyb3IiLCJkZWxheSIsImRlbGF5SW5NcyIsInNldFRpbWVvdXQiLCJSZXRyeUVycm9yIiwicmVhc29uIiwiZXJyb3JzIiwibGFzdEVycm9yIiwiaXNSZXRyeUVycm9yIiwicmV0cnlXaXRoRXhwb25lbnRpYWxCYWNrb2ZmIiwiaW5pdGlhbERlbGF5SW5NcyIsImJhY2tvZmZGYWN0b3IiLCJmIiwiX3JldHJ5V2l0aEV4cG9uZW50aWFsQmFja29mZiIsImVycm9yTWVzc2FnZSIsIm5ld0Vycm9ycyIsInRyeU51bWJlciIsImlzQVBJQ2FsbEVycm9yIiwiaXNSZXRyeWFibGUiLCJIQU5HSU5HX1NUUkVBTV9XQVJOSU5HX1RJTUVfTVMiLCJTdXNwZW5zZSIsIkZyYWdtZW50IiwianN4cyIsIlIiLCJjIiwiY3VycmVudCIsIm4iLCJuZXh0IiwiY2h1bmsiLCJhcHBlbmQiLCJmYWxsYmFjayIsImNyZWF0ZVN1c3BlbmRlZENodW5rIiwiaW5pdGlhbFZhbHVlIiwicm93IiwiY3JlYXRlU3RyZWFtYWJsZVVJIiwiY3VycmVudFZhbHVlIiwiY2xvc2VkIiwiYXNzZXJ0U3RyZWFtIiwibWV0aG9kIiwid2FybmluZ1RpbWVvdXQiLCJ3YXJuVW5jbG9zZWRTdHJlYW0iLCJwcm9jZXNzIiwiY2xlYXJUaW1lb3V0IiwiY29uc29sZSIsIndhcm4iLCJzdHJlYW1hYmxlIiwicmVzb2x2YWJsZSIsImRlZmF1bHRUZXh0UmVuZGVyZXIiLCJzdHJlYW1VSSIsIm1vZGVsIiwiYWJvcnRTaWduYWwiLCJpbml0aWFsIiwib25GaW5pc2giLCJzZXR0aW5ncyIsInVpIiwidGV4dFJlbmRlciIsImZpbmlzaGVkIiwicmVuZGVyIiwicmVuZGVyZXIiLCJzdHJlYW1hYmxlVUkiLCJpc0xhc3RDYWxsIiwicmVuZGVyRmluaXNoZWQiLCJ0aGVuIiwicmVuZGVyZXJSZXN1bHQiLCJub2RlIiwicmV0cnkiLCJ2YWxpZGF0ZWRQcm9tcHQiLCJkb1N0cmVhbSIsIm1vZGUiLCJpbnB1dEZvcm1hdCIsInN1cHBvcnRzSW1hZ2VVcmxzIiwic3RyZWFtIiwiZm9ya2VkU3RyZWFtIiwidGVlIiwiaGFzVG9vbENhbGwiLCJyZWFkZXIiLCJnZXRSZWFkZXIiLCJyZWFkIiwidGV4dERlbHRhIiwicGFyc2VSZXN1bHQiLCJzY2hlbWEiLCJzdWNjZXNzIiwiZ2VuZXJhdGUiLCJmaW5pc2hSZWFzb24iLCJ3YXJuaW5ncyIsInJhd1Jlc3BvbnNlIiwiem9kVG9Kc29uU2NoZW1hIiwiY3JlYXRlUGFyc2VyIiwiY3JlYXRlRXZlbnRTdHJlYW1UcmFuc2Zvcm1lciIsImN1c3RvbVBhcnNlciIsInRleHREZWNvZGVyIiwiVGV4dERlY29kZXIiLCJldmVudFNvdXJjZVBhcnNlciIsIlRyYW5zZm9ybVN0cmVhbSIsInN0YXJ0IiwiY29udHJvbGxlciIsImV2ZW50IiwidGVybWluYXRlIiwicGFyc2VkTWVzc2FnZSIsImVucXVldWUiLCJ0cmFuc2Zvcm0iLCJmZWVkIiwiZGVjb2RlIiwiY3JlYXRlQ2FsbGJhY2tzVHJhbnNmb3JtZXIiLCJjYiIsInRleHRFbmNvZGVyIiwiVGV4dEVuY29kZXIiLCJhZ2dyZWdhdGVkUmVzcG9uc2UiLCJjYWxsYmFja3MiLCJvblN0YXJ0IiwiZW5jb2RlIiwib25Ub2tlbiIsIm9uVGV4dCIsImZsdXNoIiwiaXNPcGVuQUlDYWxsYmFja3MiLCJpc09mVHlwZU9wZW5BSVN0cmVhbUNhbGxiYWNrcyIsIm9uQ29tcGxldGlvbiIsIm9uRmluYWwiLCJ0cmltU3RhcnRPZlN0cmVhbUhlbHBlciIsImlzU3RyZWFtU3RhcnQiLCJ0cmltU3RhcnQiLCJBSVN0cmVhbSIsImJvZHkiLCJSZWFkYWJsZVN0cmVhbSIsImVycm9yVGV4dCIsInJlc3BvbnNlQm9keVN0cmVhbSIsImNyZWF0ZUVtcHR5UmVhZGFibGVTdHJlYW0iLCJwaXBlVGhyb3VnaCIsImNsb3NlIiwicmVhZGFibGVGcm9tQXN5bmNJdGVyYWJsZSIsIml0ZXJhYmxlIiwiaXQiLCJwdWxsIiwiY2FuY2VsIiwicmV0dXJuIiwiZm9ybWF0U3RyZWFtUGFydCIsImNyZWF0ZVN0cmVhbURhdGFUcmFuc2Zvcm1lciIsImVuY29kZXIiLCJkZWNvZGVyIiwiY3JlYXRlQ2h1bmtEZWNvZGVyIiwicGFyc2VPcGVuQUlTdHJlYW0iLCJleHRyYWN0IiwiY2h1bmtUb1RleHQiLCJKU09OIiwicGFyc2UiLCJpZCIsImNyZWF0ZWQiLCJnZXREYXRlIiwiY2hvaWNlcyIsImNob2ljZSIsIl9kIiwiX2UiLCJfZiIsIl9nIiwiZnVuY3Rpb25fY2FsbCIsImZ1bmN0aW9uQ2FsbCIsInRvb2xfY2FsbHMiLCJ0b29sQ2FsbHMiLCJ0b29sQ2FsbCIsImZ1bmN0aW9uIiwiZmluaXNoX3JlYXNvbiIsInRyaW1TdGFydE9mU3RyZWFtIiwiaXNGdW5jdGlvblN0cmVhbWluZ0luIiwianNvbiIsIl9oIiwiX2kiLCJfaiIsIl9rIiwiX2wiLCJfbSIsIl9uIiwiX28iLCJfcCIsIl9xIiwiX3IiLCJpc0NoYXRDb21wbGV0aW9uQ2h1bmsiLCJpc1RleHQiLCJhcmd1bWVudHMiLCJjbGVhbnVwQXJndW1lbnRzIiwiaXNDb21wbGV0aW9uIiwiYXJndW1lbnRDaHVuayIsImVzY2FwZWRQYXJ0aWFsSnNvbiIsInJlcGxhY2UiLCJfX2ludGVybmFsX19PcGVuQUlGbk1lc3NhZ2VzU3ltYm9sIiwiT3BlbkFJU3RyZWFtIiwiZXhwZXJpbWVudGFsX29uRnVuY3Rpb25DYWxsIiwiZXhwZXJpbWVudGFsX29uVG9vbENhbGwiLCJmdW5jdGlvbkNhbGxUcmFuc2Zvcm1lciIsImNyZWF0ZUZ1bmN0aW9uQ2FsbFRyYW5zZm9ybWVyIiwiaXNGaXJzdENodW5rIiwiYWdncmVnYXRlZEZpbmFsQ29tcGxldGlvblJlc3BvbnNlIiwiZnVuY3Rpb25DYWxsTWVzc2FnZXMiLCJzaG91bGRIYW5kbGVBc0Z1bmN0aW9uIiwicGF5bG9hZCIsIm5ld0Z1bmN0aW9uQ2FsbE1lc3NhZ2VzIiwiZnVuY3Rpb25SZXNwb25zZSIsImFyZ3VtZW50c1BheWxvYWQiLCJzdHJpbmdpZnkiLCJmdW5jIiwicmVzcG9uc2VJbmRleCIsInRvb2xfY2FsbF9pZCIsImZ1bmN0aW9uX25hbWUiLCJ0b29sX2NhbGxfcmVzdWx0IiwidGMiLCJlIiwiZmlsdGVyZWRDYWxsYmFja3MiLCJvcGVuQUlTdHJlYW0iLCJjb25zdW1lU3RyZWFtIiwiZnVuY3Rpb25zIiwiaGFuZGxlUmVuZGVyIiwiaGFzRnVuY3Rpb24iLCJwcm92aWRlciIsImNoYXQiLCJjb21wbGV0aW9ucyIsImNyZWF0ZSIsImZ1bmN0aW9uQ2FsbFBheWxvYWQiLCJ0b29sQ2FsbFBheWxvYWQiLCJTVFJFQU1BQkxFX1ZBTFVFX1RZUEUiLCJTVFJFQU1BQkxFX1ZBTFVFX0lOVEVSTkFMX0xPQ0siLCJjcmVhdGVTdHJlYW1hYmxlVmFsdWUiLCJpc1JlYWRhYmxlU3RyZWFtIiwibG9ja2VkIiwiY3JlYXRlU3RyZWFtYWJsZVZhbHVlSW1wbCIsInN0cmVhbWFibGVWYWx1ZSIsImN1cnJlbnRFcnJvciIsImN1cnJlbnRQcm9taXNlIiwiY3VycmVudFBhdGNoVmFsdWUiLCJjcmVhdGVXcmFwcGVkIiwiaW5pdGlhbENodW5rIiwiaW5pdCIsImN1cnIiLCJ1cGRhdGVWYWx1ZVN0YXRlcyIsInNsaWNlIiwicmVzb2x2ZVByZXZpb3VzIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(action-browser)/./node_modules/ai/rsc/dist/rsc-server.mjs\n");

/***/ }),

/***/ "(action-browser)/./node_modules/ai/rsc/dist/rsc-shared.mjs":
/*!*************************************************!*\
  !*** ./node_modules/ai/rsc/dist/rsc-shared.mjs ***!
  \*************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   InternalAIProvider: () => (/* binding */ e0),
/* harmony export */   readStreamableValue: () => (/* binding */ e1),
/* harmony export */   useAIState: () => (/* binding */ e2),
/* harmony export */   useActions: () => (/* binding */ e3),
/* harmony export */   useStreamableValue: () => (/* binding */ e4),
/* harmony export */   useSyncUIState: () => (/* binding */ e5),
/* harmony export */   useUIState: () => (/* binding */ e6)
/* harmony export */ });
/* harmony import */ var next_dist_build_webpack_loaders_next_flight_loader_module_proxy__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! next/dist/build/webpack/loaders/next-flight-loader/module-proxy */ "(action-browser)/./node_modules/next/dist/build/webpack/loaders/next-flight-loader/module-proxy.js");

const proxy = (0,next_dist_build_webpack_loaders_next_flight_loader_module_proxy__WEBPACK_IMPORTED_MODULE_0__.createProxy)(String.raw`/home/mfaqiri/Documents/projects/Ask_Doc/node_modules/ai/rsc/dist/rsc-shared.mjs`)

// Accessing the __esModule property and exporting $$typeof are required here.
// The __esModule getter forces the proxy target to create the default export
// and the $$typeof value is for rendering logic to determine if the module
// is a client boundary.
const { __esModule, $$typeof } = proxy;
const __default__ = proxy.default;

const e0 = (0,next_dist_build_webpack_loaders_next_flight_loader_module_proxy__WEBPACK_IMPORTED_MODULE_0__.createProxy)(String.raw`/home/mfaqiri/Documents/projects/Ask_Doc/node_modules/ai/rsc/dist/rsc-shared.mjs#InternalAIProvider`);

const e1 = (0,next_dist_build_webpack_loaders_next_flight_loader_module_proxy__WEBPACK_IMPORTED_MODULE_0__.createProxy)(String.raw`/home/mfaqiri/Documents/projects/Ask_Doc/node_modules/ai/rsc/dist/rsc-shared.mjs#readStreamableValue`);

const e2 = (0,next_dist_build_webpack_loaders_next_flight_loader_module_proxy__WEBPACK_IMPORTED_MODULE_0__.createProxy)(String.raw`/home/mfaqiri/Documents/projects/Ask_Doc/node_modules/ai/rsc/dist/rsc-shared.mjs#useAIState`);

const e3 = (0,next_dist_build_webpack_loaders_next_flight_loader_module_proxy__WEBPACK_IMPORTED_MODULE_0__.createProxy)(String.raw`/home/mfaqiri/Documents/projects/Ask_Doc/node_modules/ai/rsc/dist/rsc-shared.mjs#useActions`);

const e4 = (0,next_dist_build_webpack_loaders_next_flight_loader_module_proxy__WEBPACK_IMPORTED_MODULE_0__.createProxy)(String.raw`/home/mfaqiri/Documents/projects/Ask_Doc/node_modules/ai/rsc/dist/rsc-shared.mjs#useStreamableValue`);

const e5 = (0,next_dist_build_webpack_loaders_next_flight_loader_module_proxy__WEBPACK_IMPORTED_MODULE_0__.createProxy)(String.raw`/home/mfaqiri/Documents/projects/Ask_Doc/node_modules/ai/rsc/dist/rsc-shared.mjs#useSyncUIState`);

const e6 = (0,next_dist_build_webpack_loaders_next_flight_loader_module_proxy__WEBPACK_IMPORTED_MODULE_0__.createProxy)(String.raw`/home/mfaqiri/Documents/projects/Ask_Doc/node_modules/ai/rsc/dist/rsc-shared.mjs#useUIState`);


/***/ })

};
;